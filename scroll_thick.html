<!-- vim: sw=4 ts=4 expandtab smartindent ft=javascript
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ“œ</text></svg>">
    <title>Scroll WebGL Demo 0.1</title>
    <style> document, body { margin: 0px; padding: 0px; overflow: hidden; } </style>
  </head>

  <body>
    <canvas id="glcanvas"></canvas>
    <script>
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl2', {antialias: true});
const gl_anisotropy =
  gl.getExtension("EXT_texture_filter_anisotropic") ||
  gl.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
  gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
if (!gl) { alert('Failed to initialize WebGL'); }

(window.onresize = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    /* account for e.g. high-retina macbook screens */
    if (window.devicePixelRatio > 1) {
        canvas.style.width = `${canvas.width}px`;
        canvas.style.height = `${canvas.height}px`;
        canvas.width *= window.devicePixelRatio;
        canvas.height *= window.devicePixelRatio;
    }

    gl.viewport(
        0,
        0,
        canvas.width,
        canvas.height
    );
})();

function createProgram(gl, vertexSource, fragmentSource) {
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw new Error(gl.getShaderInfoLog(shader));
        }
        return shader;
    }

    const program = gl.createProgram();

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);

    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(program));
    }

    const wrapper = {program};

    const numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < numAttributes; i++) {
        const attribute = gl.getActiveAttrib(program, i);
        wrapper[attribute.name] = gl.getAttribLocation(program, attribute.name);
    }
    const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < numUniforms; i++) {
        const uniform = gl.getActiveUniform(program, i);
        wrapper[uniform.name] = gl.getUniformLocation(program, uniform.name);
    }

    return wrapper;
}


let shaders;
/* compile shaders */
{
    const paint_vs =
        'attribute vec3 a_pos;' +
        'attribute vec2 a_uv;' +

        'varying vec3 v_pos;' +

        'void main() {' +
        '  v_pos = a_pos;' +
        '  gl_Position = vec4(a_uv*2.0 - 1.0, 0.0, 1.0);' +
        '}';

    const paint_fs =
        'precision mediump float;' +

        'varying vec3 v_pos;' +

        'uniform mat4 u_matrix;' +
        'uniform vec4 u_color;' +
        'uniform vec2 u_stroke_from;' +
        'uniform vec2 u_stroke_to;' +
        'uniform vec2 u_aspect_ratio;' +
        'uniform sampler2D u_tex_depth;' +

        /* thanks iq! https://iquilezles.org/articles/distfunctions2d/ */
        'float sd_segment( in vec2 p, in vec2 a, in vec2 b ) {' +
        '    vec2 pa = p-a, ba = b-a;' +
        '    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );' +
        '    return length( pa - ba*h );' +
        '}' +

        'float decode_float_rgba(vec4 rgba) {' +
        '  return dot(rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0));' +
        '}' +

        'void main() {' +
        '  vec4 full_pos = u_matrix * vec4(v_pos.xyz, 1.0);' +
        '  vec2 screen_pos = full_pos.xy / full_pos.w;' +
        '' +
        '  float occluding_depth = decode_float_rgba(texture2D(u_tex_depth, (screen_pos * 0.5) + 0.5));' +
        '  float frag_depth = (full_pos.z / full_pos.w * 0.5) + 0.5;' +
        '' +
        '  const float bias = 0.00001;' +
        '  float occlusion = step(frag_depth - bias, occluding_depth);' +
        '' +
        '  vec2 ar = u_aspect_ratio;' +
        '  float dist = sd_segment(screen_pos*ar, u_stroke_from*ar, u_stroke_to*ar);' +
        '  const float brush_size = 0.18;' +
        '  gl_FragColor = smoothstep(0.023*brush_size, 0.02*brush_size, dist) * u_color * occlusion;' +
        // '  gl_FragColor = occlusion * u_color;' +
        '}';

    const vs_geo = `
        attribute vec3 a_pos;
        attribute vec2 a_uv;

        uniform mat4 u_matrix;

        varying vec2 v_uv;

        void main() {
            gl_Position = u_matrix * vec4(a_pos.xyz, 1.0);
            v_uv = a_uv;
        }`;

    const fs_geo = `
        precision mediump float;

        uniform sampler2D u_texture;
        uniform float u_color_mask;
        uniform float u_alpha_mask;

        varying vec2 v_uv;

        void main() {
            gl_FragColor = texture2D(u_texture, v_uv);
            gl_FragColor.a *= u_alpha_mask;
            if (gl_FragColor.a <= 0.0) discard;
            gl_FragColor.xyz *= u_color_mask;
        }`;


    const vs_grid = `#version 300 es
        in vec3 a_pos;
        in vec2 a_uv;

        uniform mat4 u_matrix;

        out vec2 v_uv;

        void main() {
            gl_Position = u_matrix * vec4(a_pos.xyz, 1);
            v_uv = (a_uv - 0.5)*abs(a_pos.xy*10.0);
        }`;

    const fs_grid = `#version 300 es
        precision mediump float;

        in vec2 v_uv;

        /* https://iquilezles.org/articles/filterableprocedurals/ */

        const float N = 30.0; // grid ratio
        float gridTextureGradBox(in vec2 p, in vec2 ddx, in vec2 ddy) {
            // filter kernel
            vec2 w = max(abs(ddx), abs(ddy)) + 0.01;

            // analytic (box) filtering
            vec2 a = p + 0.5*w;
            vec2 b = p - 0.5*w;
            vec2 i = (floor(a)+min(fract(a)*N,1.0)-
                      floor(b)-min(fract(b)*N,1.0))/(N*w);
            //pattern
            return (1.0-i.x)*(1.0-i.y);
        }

        out vec4 frag_color;

        void main() {
            // vec2 d = 1.0 - step(0.01, fract(v_uv*10.0));
            // gl_FragColor = vec4(max(d.x, d.y));

            vec2 uv = (v_uv - 0.5) + 0.5/N;
            float grid = gridTextureGradBox(uv, dFdx(uv), dFdy(uv));
            frag_color = vec4(1.0 - grid);
            frag_color *= 0.5;
            frag_color *= smoothstep(0.0, 0.8, 1.0 - length(v_uv)/9.5);
        }`;

    var depth_vs =
        'precision mediump float;' +

        'uniform mat4 u_matrix;' +

        'attribute vec4 a_pos;' +

        'varying vec4 v_pos;' +

        'void main() {' +
        '  gl_Position = v_pos = u_matrix * a_pos;' +
        '}';

    var depth_fs =
        'precision mediump float;' +

        'varying vec4 v_pos;' +

        'vec4 encode_float_rgba(float v) {' +
        '  vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;' +
        '  enc = fract(enc);' +
        '  enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);' +
        '  return enc;' +
        '}' +

        'void main() {' +
        '  float depth = v_pos.z / v_pos.w;' +
        '  gl_FragColor = encode_float_rgba(depth * 0.5 + 0.5);' +
        '}';


    shaders = {
        geo:   createProgram(gl, vs_geo  , fs_geo  ),
        grid:  createProgram(gl, vs_grid , fs_grid ),
        paint: createProgram(gl, paint_vs, paint_fs),
        depth: createProgram(gl, depth_vs, depth_fs),
    }
}

let emoji_atlas = gl.createTexture();
const ATLAS_SIZE = 2; /* in emoji */
const EMOJI_SIZE = 256;
{
    const canvas = document.createElement("canvas");

    canvas.width = canvas.height = ATLAS_SIZE * EMOJI_SIZE;

    const ctx = canvas.getContext("2d");

    {
        const atlas = ['âœ’ï¸', 'ðŸŒˆ', 'ðŸ¤š', 'ðŸ“œ'];
        const PAD = EMOJI_SIZE*0.2;
        ctx.font = (EMOJI_SIZE - PAD*2) + 'px sans-serif';

        let i = 0;
        for (const char of atlas) {
            const x = (           i % ATLAS_SIZE ) * EMOJI_SIZE;
            const y = (Math.floor(i / ATLAS_SIZE)) * EMOJI_SIZE;

            ctx.fillText(
                char,
                x + PAD,
                y + EMOJI_SIZE - PAD
            );

            i++;
        }
    }

    gl.bindTexture(gl.TEXTURE_2D, emoji_atlas);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
    gl.texImage2D(
        /* target         */ gl.TEXTURE_2D,
        /* level          */ 0,
        /* internalformat */ gl.RGBA,
        /* width          */ canvas.width,
        /* height         */ canvas.height,
        /* border,        */ 0,
        /* format,        */ gl.RGBA,
        /* type,          */ gl.UNSIGNED_BYTE,
        /* data           */ canvas
    );

    if (1) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        const shadowed = shadowForTexture(
            emoji_atlas,
            canvas.width,
            canvas.height,
            0
        );
        gl.disableVertexAttribArray(1);
        gl.deleteTexture(emoji_atlas);
        emoji_atlas = shadowed;
    }

    gl.bindTexture(gl.TEXTURE_2D, emoji_atlas);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);


    /* if you're going to use this multiple times in a single program,
     * consider modifying it to not immediately delete all the shaders.
     *
     * or just take the shader compilation hit -- i don't care what you do.
     *
     * note, if you don't care about supporting Safari, you can generate shadows entirely in canvas
     * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/filter
     *
     */
    function shadowForTexture(texture, texture_width, texture_height, texture_pad) {
        /* compile shaders */
        let shaders;
        {
            const vs_img = `
                attribute vec3 a_pos;
                attribute vec2 a_uv;

                uniform mat4 u_matrix;

                varying vec2 v_uv;

                void main() {
                    gl_Position = u_matrix * vec4(a_pos.xyz, 1);
                    v_uv = a_uv;
                }`;

            const fs_img = `
                precision mediump float;

                varying vec2 v_uv;

                uniform sampler2D u_texture;
                uniform vec4 u_mask;

                void main() {
                    gl_FragColor = texture2D(u_texture, v_uv);

                    /* somehow alpha got overmultiplied, freaky af */
                    // gl_FragColor.xyz /= gl_FragColor.w;

                    gl_FragColor.rgb *= u_mask.rgb;
                    gl_FragColor     *= u_mask.a;
                }`;


            const vs_fullscreen_blur = `#version 300 es
                precision mediump float;

                out vec2 v_texcoord;

                void main(void) {
                    float x = float((gl_VertexID & 1) << 2);
                    float y = float((gl_VertexID & 2) << 1);
                    v_texcoord.x = x * 0.5;
                    v_texcoord.y = y * 0.5;
                    gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);
                }
            `;

            const fs_fullscreen_blur = `#version 300 es
                precision mediump float;

                uniform sampler2D u_texture;
                uniform vec2 u_direction;

                in vec2 v_texcoord;

                out vec4 frag_color;

                void main(void) {
                    vec2 one_pixel = u_direction*(vec2(1) / vec2(textureSize(u_texture, 0)));

                    frag_color = texture(u_texture, v_texcoord) * 0.2270270270;

                    frag_color += texture(u_texture, v_texcoord + one_pixel    ) * 0.1945945946;
                    frag_color += texture(u_texture, v_texcoord - one_pixel    ) * 0.1945945946;

                    frag_color += texture(u_texture, v_texcoord + one_pixel*2.0) * 0.1216216216;
                    frag_color += texture(u_texture, v_texcoord - one_pixel*2.0) * 0.1216216216;

                    frag_color += texture(u_texture, v_texcoord + one_pixel*3.0) * 0.0540540541;
                    frag_color += texture(u_texture, v_texcoord - one_pixel*3.0) * 0.0540540541;

                    frag_color += texture(u_texture, v_texcoord + one_pixel*4.0) * 0.0162162162;
                    frag_color += texture(u_texture, v_texcoord - one_pixel*4.0) * 0.0162162162;
                }
            `;

            shaders = {
                img:             createProgram(gl, vs_img            , fs_img            ),
                fullscreen_blur: createProgram(gl, vs_fullscreen_blur, fs_fullscreen_blur),
            };
        }

        let prebaked;
        {
          /* some suggestions on AA/multisampling https://stackoverflow.com/a/55976760 */
          const canvas_width  = texture_width  + texture_pad*2;
          const canvas_height = texture_height + texture_pad*2;

          gl.viewport(
              0,
              0,
              canvas_width,
              canvas_height
          );

          /* this way we can just draw the image from (0, 0)..(width,height)
           * and it will have even padding on all sides */
          const pMatrix = mat4_ortho(
              mat4_create(),
              -texture_pad,
              texture_width +texture_pad,
              -texture_pad,
              texture_height+texture_pad,
              1,
              -1
          );

          const render_targets = [
            { tex: gl.createTexture(), fb: gl.createFramebuffer() },
            { tex: gl.createTexture(), fb: gl.createFramebuffer() },
          ];
         
          for (const rt of render_targets) {
              gl.bindTexture(gl.TEXTURE_2D, rt.tex);

              // Upload the image into the texture.
              gl.texImage2D(
                  /* target         */ gl.TEXTURE_2D,
                  /* level          */ 0,
                  /* internalformat */ gl.RGBA,
                  /* width          */ canvas_width ,
                  /* height         */ canvas_height,
                  /* border,        */ 0,
                  /* format,        */ gl.RGBA,
                  /* type,          */ gl.UNSIGNED_BYTE,
                  /* data           */ null
              );
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

              gl.bindFramebuffer(gl.FRAMEBUFFER, rt.fb);
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rt.tex, 0);
          }

          /* prebaked rt is bound */
          
          const img_vbuf_pos = gl.createBuffer();
          const img_vbuf_uv  = gl.createBuffer();
          const img_ibuf     = gl.createBuffer();

          {
            const img_idx = [];
            const img_pos = [];
            const img_uv  = [];

            {
                const min_x = 0;
                const min_y = 0;
                const max_x = texture_width;
                const max_y = texture_height;

                img_uv.push(
                    1, 0,
                    0, 0,
                    0, 1,
                    1, 1
                );

                const vbuf_i = img_pos.length / 3;
                img_pos.push(max_x, min_y, 0.1);
                img_pos.push(min_x, min_y, 0.1);
                img_pos.push(min_x, max_y, 0.1);
                img_pos.push(max_x, max_y, 0.1);

                img_idx.push(vbuf_i + 0, vbuf_i + 1, vbuf_i + 2, vbuf_i + 2, vbuf_i + 3, vbuf_i + 0);
            }

            /* set up premultiplied alpha */
            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.enable(gl.BLEND);

            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            /* clear all */
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            /* shadow img pass (see color mask) */
            function imgPass(u_mask_r, u_mask_g, u_mask_b, u_alpha_mask) {
                gl.useProgram(shaders.img.program);
                gl.enableVertexAttribArray(shaders.img.a_pos);
                gl.enableVertexAttribArray(shaders.img.a_uv);

                /* upload/bind atlas */
                {
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.uniform1i(shaders.img.u_texture, 0);
                }

                gl.uniformMatrix4fv(shaders.img.u_matrix, false, pMatrix);
                gl.uniform4f(shaders.img.u_mask, u_mask_r, u_mask_g, u_mask_b, u_alpha_mask);

                /* upload/bind geometry */

                {
                    gl.bindBuffer(gl.ARRAY_BUFFER, img_vbuf_pos);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(img_pos), gl.STATIC_DRAW);
                    gl.vertexAttribPointer(shaders.img.a_pos, 3, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, img_vbuf_uv);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(img_uv), gl.STATIC_DRAW);
                    gl.vertexAttribPointer(shaders.img.a_uv, 2, gl.FLOAT, true, 0, 0);

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, img_ibuf);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(img_idx), gl.STATIC_DRAW);
                }

                gl.drawElements(gl.TRIANGLES, img_idx.length, gl.UNSIGNED_SHORT, 0);
            }

            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.enable(gl.BLEND);

            imgPass(0.20, 0.20, 0.20, 0.20);

            /* blur time */
            {
                const passes = [
                    // [render_targets[1].fb, render_targets[0].tex, [ 0, 10]],
                    // [render_targets[0].fb, render_targets[1].tex, [ 9,  0]],
                    // [render_targets[1].fb, render_targets[0].tex, [ 0,  8]],
                    // [render_targets[0].fb, render_targets[1].tex, [ 7,  0]],
                    [render_targets[1].fb, render_targets[0].tex, [ 0,  6]],
                    [render_targets[0].fb, render_targets[1].tex, [ 5,  0]],
                    [render_targets[1].fb, render_targets[0].tex, [ 0,  4]],
                    [render_targets[0].fb, render_targets[1].tex, [ 3,  0]],
                    [render_targets[1].fb, render_targets[0].tex, [ 0,  2]],
                    [render_targets[0].fb, render_targets[1].tex, [ 1,  0]]
                ];
                for (const [dst_fb, src_tex, dir] of passes) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, dst_fb);

                    gl.useProgram(shaders.fullscreen_blur.program);

                    gl.uniform2fv(shaders.fullscreen_blur.u_direction, [dir[0]*2, dir[1]*2]);

                    /* bind tex */
                    {
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, src_tex);
                        gl.uniform1i(shaders.fullscreen_blur.u_texture, 0);
                    }

                    gl.drawArrays(gl.TRIANGLE_FAN, 0, 3);
                }
            }

            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.enable(gl.BLEND);
            imgPass(1, 1, 1, 1);
          }

          gl.deleteBuffer(img_vbuf_pos);
          gl.deleteBuffer(img_vbuf_uv );
          gl.deleteBuffer(img_ibuf    );

          gl.deleteProgram(shaders.img.program);
          gl.deleteShader(shaders.img.vs);
          gl.deleteShader(shaders.img.fs);

          gl.deleteProgram(shaders.fullscreen_blur.program);
          gl.deleteShader(shaders.fullscreen_blur.vs);
          gl.deleteShader(shaders.fullscreen_blur.fs);

          gl.deleteFramebuffer(render_targets[0].fb);
          gl.deleteFramebuffer(render_targets[1].fb);
          gl.deleteTexture(render_targets[1].tex);
          prebaked = render_targets[0].tex;

          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }

        return prebaked;
    }
}


let tex_skydome = gl.createTexture();
(async () => {
    const img = new Image();
    img.src = 'castle_zavelstein_cellar.jpg';
    await new Promise(res => img.onload = res);

    const canvas = document.createElement("canvas");
    canvas.width  = img.width;
    canvas.height = img.height;
    canvas.getContext("2d").drawImage(img, 0, 0);

    gl.bindTexture(gl.TEXTURE_2D, tex_skydome);
    gl.texImage2D(
        /* target         */ gl.TEXTURE_2D,
        /* level          */ 0,
        /* internalformat */ gl.RGBA,
        /* width          */ canvas.width,
        /* height         */ canvas.height,
        /* border,        */ 0,
        /* format,        */ gl.RGBA,
        /* type,          */ gl.UNSIGNED_BYTE,
        /* data           */ canvas
    );
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
})();

let tex_quill = gl.createTexture();
(async () => {
    const img = new Image();
    img.src = 'tex_quill.png';
    await new Promise(res => img.onload = res);

    const canvas = document.createElement("canvas");
    canvas.width  = img.width  * 1.2;
    canvas.height = img.height * 1.2;
    const ctx = canvas.getContext("2d");
    ctx.save();
    ctx.translate(canvas.width*0.5, 0);
    ctx.rotate(Math.PI/2 * 0.5);
    ctx.drawImage(img, 0, 0);
    ctx.restore();

    gl.bindTexture(gl.TEXTURE_2D, tex_quill);
    gl.texImage2D(
        /* target         */ gl.TEXTURE_2D,
        /* level          */ 0,
        /* internalformat */ gl.RGBA,
        /* width          */ canvas.width,
        /* height         */ canvas.height,
        /* border,        */ 0,
        /* format,        */ gl.RGBA,
        /* type,          */ gl.UNSIGNED_BYTE,
        /* data           */ canvas
    );
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    if (gl_anisotropy) {
      const max = gl.getParameter(gl_anisotropy.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      gl.texParameterf(gl.TEXTURE_2D, gl_anisotropy.TEXTURE_MAX_ANISOTROPY_EXT, max);
    }
})();

const SCROLL_WIDTH = 2000;
const SCROLL_LENGTH_WORLDSPACE = 7.198429;

const tex_scroll_fb   = gl.createFramebuffer();
const tex_scroll      = gl.createTexture();
let tex_scroll_loaded = false;
(async () => {
    const font = new FontFace("quill", "url(https://fonts.gstatic.com/s/medievalsharp/v26/EvOJzAlL3oU5AQl2mP5KdgptMqhwMinUPDg.woff2) format('woff2')")
    await font.load();
    document.fonts.add(font);
    document.body.classList.add("fonts-loaded");

    const img = new Image();
    img.src = 'tex_scroll.jpg';
    await new Promise(res => img.onload = res);

    const canvas = document.createElement("canvas");
    /* scroll is 2 units wide in worldspace so this gives us an aspect ratio. */
    canvas.width = SCROLL_WIDTH;
    canvas.height = SCROLL_WIDTH * (SCROLL_LENGTH_WORLDSPACE / 2.0);
    const ctx = canvas.getContext("2d");

    for (let i = 0, y = 0; y < canvas.height; y += img.height, i++) {
        ctx.save();
        ctx.translate(img.width*0.5, img.height*0.5 + y);
        if (i%2) ctx.rotate(Math.PI);
        else     ctx.scale(-1, 1);
        ctx.drawImage(img, -img.width*0.5, -img.height*0.5);
        ctx.restore();
    }

    const ITERATIONS = 20;
    for (let i = 0; i < ITERATIONS; i++) {
        ctx.save();

        if (i == (ITERATIONS - 1)) {
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = "rgb(15% 9% 7%)";
        } else {
            const shake = 15;
            ctx.translate((0.5 - Math.random())*shake,
                          (0.5 - Math.random())*shake);
            ctx.globalAlpha = 0.07*Math.random();
            ctx.fillStyle = "rgb(35% 10% 7%)";
        }

        const LINE_COUNT = 30;
        const lines = [
            1.0, '',
            1.0, '',
            1.5, 'SIGN OVER YOUR',
            1.5, '    FIRST BORN',
            0.8, '   by order of imperial decree',
            1.0, '',
            2.0, '    or else!',
            1.0, '',
            0.8, ''
        ];
        lines.push(1.0, '', 1.0, '', 1.0, '', ...lines);

        let y = 7/30;
        for (let i = 0; i < lines.length; i += 2) {
            const size = lines[i + 0];
            const text = lines[i + 1];

            ctx.font = (size * SCROLL_WIDTH * 0.08) + "px quill";
            y += 1/30;

            ctx.fillText(text, 50, y * canvas.height);
        }
        ctx.restore();
    }

    gl.bindTexture(gl.TEXTURE_2D, tex_scroll);
    gl.texImage2D(
        /* target         */ gl.TEXTURE_2D,
        /* level          */ 0,
        /* internalformat */ gl.RGBA,
        /* width          */ canvas.width,
        /* height         */ canvas.height,
        /* border,        */ 0,
        /* format,        */ gl.RGBA,
        /* type,          */ gl.UNSIGNED_BYTE,
        /* data           */ canvas
    );
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    tex_scroll_loaded = true;
    gl.bindFramebuffer(gl.FRAMEBUFFER, tex_scroll_fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex_scroll, 0);
})();

/* we need a depth texture so we can sample it when painting,
 * to determine if the fragment should be occluded */
let depth_color = gl.createTexture();
let depth_depth = gl.createTexture();
let depth_fb = gl.createFramebuffer();
const DEPTH_TEX_SIZE = 1 << 9;
{
    {
        gl.bindTexture(gl.TEXTURE_2D, depth_color);
        gl.texImage2D(
            /* target         */ gl.TEXTURE_2D,
            /* level          */ 0,
            /* internalformat */ gl.RGBA,
            /* width          */ DEPTH_TEX_SIZE,
            /* height         */ DEPTH_TEX_SIZE,
            /* border,        */ 0,
            /* format,        */ gl.RGBA,
            /* type,          */ gl.UNSIGNED_BYTE,
            /* data           */ null
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.bindFramebuffer(gl.FRAMEBUFFER, depth_fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, depth_color, 0);
    }
    {
        gl.bindTexture(gl.TEXTURE_2D, depth_depth);

        // define size and format of level 0
        gl.texImage2D(
            gl.TEXTURE_2D,
            /* level,          */ 0,
            /* internalFormat, */ gl.DEPTH_COMPONENT24,
            /* width,          */ DEPTH_TEX_SIZE,
            /* height,         */ DEPTH_TEX_SIZE,
            /* border,         */ 0,
            /* format,         */ gl.DEPTH_COMPONENT,
            /* type,           */ gl.UNSIGNED_INT,
            /* data            */ null
        );

        // set the filtering so we don't need mips
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        /* bind depth tex to our framebuffer */
        gl.bindFramebuffer(gl.FRAMEBUFFER, depth_fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depth_depth, 0);
    }
}

const buf = {
    scroll_v_pos: gl.createBuffer(),
    scroll_v_uv:  gl.createBuffer(),
    scroll_i:     gl.createBuffer(),

    quill_v_pos: gl.createBuffer(),
    quill_v_uv:  gl.createBuffer(),
    quill_i:     gl.createBuffer(),

    emoji_v_pos: gl.createBuffer(),
    emoji_v_uv:  gl.createBuffer(),
    emoji_i:     gl.createBuffer(),

    skydome_v_pos: gl.createBuffer(),
    skydome_v_uv:  gl.createBuffer(),
    skydome_i:     gl.createBuffer(),
    skydome_i_count: 0,

    grid_v_pos:  gl.createBuffer(),
    grid_v_uv:   gl.createBuffer(),
    grid_i:      gl.createBuffer(),
    grid_i_count: 0,
};

/* generate grid geometry */
{
    const grid_idx = [];
    const grid_pos = [];
    const grid_uv  = [];
    {
        const z = -1.5;
        const corners = [
            -999, -999, z,  -999,  999, z,   999,  999, z,   999, -999, z, /* Bottom face */
        ];

        for (let corner_i = 0; corner_i < corners.length; corner_i += 3)
            corners[corner_i+2] -= 0.025;

        for (let corner_i = 0; corner_i < corners.length; corner_i += 12) {
            grid_uv.push(
                255,   0,
                  0,   0,
                  0, 255,
                255, 255,
            );

            const vbuf_i = grid_pos.length / 3;
            grid_pos.push(corners[corner_i +  0], corners[corner_i +  1], corners[corner_i +  2]);
            grid_pos.push(corners[corner_i +  3], corners[corner_i +  4], corners[corner_i +  5]);
            grid_pos.push(corners[corner_i +  6], corners[corner_i +  7], corners[corner_i +  8]);
            grid_pos.push(corners[corner_i +  9], corners[corner_i + 10], corners[corner_i + 11]);

            grid_idx.push(
                vbuf_i + 0,
                vbuf_i + 1,
                vbuf_i + 2,
                vbuf_i + 2,
                vbuf_i + 3,
                vbuf_i + 0
            );
        }
    }

    {
        gl.bindBuffer(gl.ARRAY_BUFFER, buf.grid_v_pos);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(grid_pos), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, buf.grid_v_uv);
        gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(grid_uv), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.grid_i);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(grid_idx), gl.STATIC_DRAW);
    }
    buf.grid_i_count = grid_idx.length;
}

/* generate skydome geometry */
{
    const geo_idx = [];
    const geo_pos = [];
    const geo_uv  = [];
    {
        const WIDTH_SEGMENTS  = 1 << 6;
        const HEIGHT_SEGMENTS = 1 << 5;
        const RADIUS          = 100;

        const grid = [];
        let index = 0;
        for (let iy = 0; iy <= HEIGHT_SEGMENTS; iy++) {
            const v = iy / HEIGHT_SEGMENTS;

            /* poles */
            let u_offset = 0;
            if (iy == 0              ) u_offset =   0.5 / WIDTH_SEGMENTS;
            if (iy == HEIGHT_SEGMENTS) u_offset = - 0.5 / WIDTH_SEGMENTS;

            for (let ix = 0; ix <= WIDTH_SEGMENTS; ix++) {
                const u = ix / WIDTH_SEGMENTS;

                geo_uv.push(u + u_offset, 1 - v);

                geo_pos.push(
                    RADIUS * -Math.cos(u * Math.PI*2) * Math.sin(v * Math.PI),
                    RADIUS *  Math.sin(u * Math.PI*2) * Math.sin(v * Math.PI),
                    RADIUS * -Math.cos(v * Math.PI)
                );

                grid.push(index++);
            }
        }

        for (let iy = 0; iy < HEIGHT_SEGMENTS; iy++) {
            for (let ix = 0; ix < WIDTH_SEGMENTS; ix++) {
                const a = grid[(iy    )*(WIDTH_SEGMENTS + 1) + ix + 1];
                const b = grid[(iy    )*(WIDTH_SEGMENTS + 1) + ix    ];
                const c = grid[(iy + 1)*(WIDTH_SEGMENTS + 1) + ix    ];
                const d = grid[(iy + 1)*(WIDTH_SEGMENTS + 1) + ix + 1];

                if (iy !== 0                  ) geo_idx.push(a, b, d);
                if (iy !== HEIGHT_SEGMENTS - 1) geo_idx.push(b, c, d);
            }
        }
    }

    /* upload to GPU */
    {
        gl.bindBuffer(gl.ARRAY_BUFFER, buf.skydome_v_pos);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo_pos), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, buf.skydome_v_uv);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo_uv), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.skydome_i);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geo_idx), gl.STATIC_DRAW);
    }

    buf.skydome_i_count = geo_idx.length;
}

const INPUT_MODE_GRAB_SCROLL = 0;
const INPUT_MODE_PEN         = 1;
const INPUT_MODE_PEN_RAINBOW = 2;
const INPUT_MODE_COUNT       = 3;

const save = {
    quill: [0, 0],
    quill_inertia: [0, 0],

    input_mode_button_y_offsets: Array.from({ length: INPUT_MODE_COUNT }, _ => 0),

    scroll_prog: 0.9,
}

let input = {
    pitch:  Math.PI*0.30,
    yaw:   -Math.PI*0.15,

    dampedEvent: { button: 0, movementX: 0, movementY: 0 },
    hand_grabbing_parchment: false,

    cam_pivot_x:  0,
    cam_pivot_y:  0,
    cam_pivot_z: -0.15,

    zoom:        4,
    scroll:      0,

    pen_screen_x: 0,
    pen_screen_y: 0,
    mode: INPUT_MODE_GRAB_SCROLL,

    raw_mouse_x: 0,
    raw_mouse_y: 0,
    last_mouse_x: 0,
    last_mouse_y: 0,

    lmb_down: false,
    lmb_clicked: false,/* true for a frame after mousedown */
    rmb_down: false,
}

{
    const opts = { passive: false };

    window.addEventListener('wheel', e => {
        e.preventDefault();

        if (input.mouse_down) return;
        input.scroll += e.deltaY;
    }, opts);
    window.addEventListener('mousedown', ev => {
        ev.preventDefault();

        input.raw_mouse_x = ev.offsetX;
        input.raw_mouse_y = ev.offsetY;

        input.dampedEvent.button = ev.button;

        if (ev.button == 0) input.lmb_down = input.lmb_clicked = true;
        if (ev.button == 2) input.rmb_down = true;
    }, opts);
    window.addEventListener('mousemove', ev => {
        ev.preventDefault();

        if (input.lmb_down || input.rmb_down) {
            input.dampedEvent.movementX += ev.movementX;
            input.dampedEvent.movementY += ev.movementY;
        }

        input.raw_mouse_x = input.pen_screen_x = ev.offsetX;
        input.raw_mouse_y = input.pen_screen_y = ev.offsetY;
    }, opts);
    window.addEventListener("contextmenu", ev => {
        ev.preventDefault();
    }, opts);
    window.addEventListener('mouseup', ev => {
        ev.preventDefault();

        input.raw_mouse_x = ev.offsetX;
        input.raw_mouse_y = ev.offsetY;

        if (ev.button == 0) input.lmb_down = false;
        if (ev.button == 2) input.rmb_down = false;
    }, opts);
}

/* touch */
{
    const opts = { passive: false };

    let touch_x = 0;
    let touch_y = 0;
    window.addEventListener("touchstart", ev => {
        ev.preventDefault();

        input.raw_mouse_x = touch_x = ev.changedTouches[0].clientX;
        input.raw_mouse_y = touch_y = ev.changedTouches[0].clientY;

        input.lmb_down = true;
    }, opts);

    window.addEventListener("touchmove", ev => {
        ev.preventDefault();
        input.dampedEvent.button = 0;

        input.dampedEvent.movementX += ev.changedTouches[0].clientX - touch_x;
        input.dampedEvent.movementY += ev.changedTouches[0].clientY - touch_y;

        input.raw_mouse_x = input.pen_screen_x = touch_x = ev.changedTouches[0].clientX;
        input.raw_mouse_y = input.pen_screen_y = touch_y = ev.changedTouches[0].clientY;
    }, opts);

    window.addEventListener("touchend", ev => {
        ev.preventDefault();

        input.raw_mouse_x = ev.changedTouches[0].clientX;
        input.raw_mouse_y = ev.changedTouches[0].clientY;

        input.lmb_down = false;
    }, opts);
}

let then = 0;
let deltaTime = 0;
requestAnimationFrame(function frame(now) {
    requestAnimationFrame(frame);

    now *= 0.001;
    deltaTime = now - then;
    then = now;

    const ORTHO = false;
    const u_vp_inv = mat4_create();
    const u_vp = mat4_create();
    const scratch = mat4_create();
    const eye = [0, 0, 0, 1];
    {
        if (ORTHO) {
            const ar = window.innerWidth / window.innerHeight;
            const projection = mat4_ortho(mat4_create(), -ar, ar, -1, 1, -2, 2);

            mat4_mul(u_vp, projection, model);
        } else {
            const FIELD_OF_VIEW = 70 / 180 * Math.PI;
            const ar = window.innerWidth / window.innerHeight;
            const projection = mat4_perspective(mat4_create(), FIELD_OF_VIEW, ar, 0.01, 1000.0);

            const view = mat4_create();
            {
                eye[0] = input.zoom;
                eye[1] = 0;
                eye[2] = 0;
                eye[3] = 1;
                {
                    mat4_from_z_rotation(scratch, input.pitch);
                    mat4_mul(view, view, scratch);

                    mat4_from_y_rotation(scratch, input.yaw);
                    mat4_mul(view, view, scratch);

                    mat4_transform_vec4(eye, eye, view);
                }

                eye[0] += input.cam_pivot_x;
                eye[1] += input.cam_pivot_y;
                eye[2] += input.cam_pivot_z;
                mat4_target_to(
                    view,
                    eye,
                    [input.cam_pivot_x, input.cam_pivot_y, input.cam_pivot_z],
                    [                0,                 0,                 1]
                );
                mat4_invert(view, view);
            }

            mat4_mul(u_vp, projection, view);
            mat4_invert(u_vp_inv, u_vp);
        }
    }


    const quill_mouse_pos = [0, 0, 0, 1]; /* in worldspace */
    let quill_hovering_parchment;
    {
        const vec = quill_mouse_pos;
        function project_onto_parchment(screen_x, screen_y) {
            vec[0] = -1 + (screen_x / window.innerWidth )*2;
            vec[1] = +1 - (screen_y / window.innerHeight)*2;
            vec[2] = 1;
            vec[3] = 1;

            mat4_transform_vec4(vec, vec, u_vp_inv);
            vec[0] /= vec[3];
            vec[1] /= vec[3];
            vec[2] /= vec[3];

            let x =  0.00;
            let y =  1.00;
            let z =  0.40;
            x /= Math.sqrt(x*x + y*y + z*z);
            y /= Math.sqrt(x*x + y*y + z*z);
            z /= Math.sqrt(x*x + y*y + z*z);

            ray_hit_plane(
                vec,
                         eye[0],          eye[1],          eye[2], /* ray origin */
                vec[0] - eye[0], vec[1] - eye[1], vec[2] - eye[2], /* ray vector */

                0, 0.5, -1.5, /* plane origin */
                x,   y,    z, /* plane vector */
            );
        }
        project_onto_parchment(input.raw_mouse_x, input.raw_mouse_y);

        /* hardcoded parchment extents, WEEEE */
        quill_hovering_parchment = true;
        quill_hovering_parchment &&= Math.abs(-0.15 - vec[1]) < 0.5;
        quill_hovering_parchment &&= Math.abs(        vec[0]) < 1.1;

        if (input.mode == INPUT_MODE_GRAB_SCROLL) {
            quill_hovering_parchment = false;

            if (input.lmb_clicked && quill_hovering_parchment) {
                input.hand_grabbing_parchment = true;
            }
            if (!input.lmb_down && Math.abs(input.dampedEvent.movementY) < 1) {
                input.hand_grabbing_parchment = false;
            }
        }

        if (!quill_hovering_parchment) {
            const p = [-1.50, 0.00, -1.15, 1.0];
            mat4_transform_vec4(p, p, u_vp);
            input.pen_screen_x = (0.0 + (p[0] / p[3] + 1.0) / 2.0) * gl.canvas.width  / window.devicePixelRatio;
            input.pen_screen_y = (1.0 - (p[1] / p[3] + 1.0) / 2.0) * gl.canvas.height / window.devicePixelRatio;
        }

        const t = 1 - Math.pow(1 - 0.15, 60*deltaTime);
        save.quill[0] = lerp(save.quill[0], input.pen_screen_x, t);
        save.quill[1] = lerp(save.quill[1], input.pen_screen_y, t);

        project_onto_parchment(save.quill[0], save.quill[1]);
    }

    /* we could apply these changes directly in the event handlers, but the result feels "low fps"
     * because we don't get input events at 60fps. so instead, we apply the changes every frame
     * and simply "damp them" so that they get weaker every frame.
     *
     * one way this could be improved: fix how movement immediately stops when you release the mouse */
    {
        const ev = input.dampedEvent;

        /* based on the assumption that if you're zoomed in more,
         * you're doing finer-detailed work and want more precise movements. */
        const zoom_fudge = Math.sqrt(input.zoom/10.0)*2.0;

        document.body.style.cursor = 'grab';
        if (input.lmb_down || input.rmb_down) document.body.style.cursor = 'grabbing';
        if (quill_hovering_parchment)         document.body.style.cursor = 'crosshair';

        if (ev.button == 0 && !quill_hovering_parchment && !input.hand_grabbing_parchment) {
            input.pitch -= ev.movementX * 0.0005 * zoom_fudge;
            input.yaw   -= ev.movementY * 0.0005 * zoom_fudge;
            input.yaw = Math.max(-Math.PI*0.5 + 0.01, Math.min(Math.PI*0.5 - 0.01, input.yaw));
        }

        if (ev.button == 2) {

            const unit = [0, -ev.movementX*0.00075*zoom_fudge, ev.movementY*0.00075*zoom_fudge, 1];
            {
                const view    = mat4_create();
                const scratch = mat4_create();

                mat4_from_z_rotation(scratch, input.pitch);
                mat4_mul(view, view, scratch);

                mat4_from_y_rotation(scratch, input.yaw);
                mat4_mul(view, view, scratch);

                mat4_transform_vec4(unit, unit, view);
            }

            input.cam_pivot_x += unit[0];
            input.cam_pivot_y += unit[1];
            input.cam_pivot_z += unit[2];
        }

        ev.movementX *= Math.pow(1 - 0.17, 60*deltaTime);
        ev.movementY *= Math.pow(1 - 0.17, 60*deltaTime);
    }

    /* scroll parchment or zoom camera, depending */
    {
        /* i like math */
        const { sqrt, abs, sign, cbrt, pow, min, max } = Math;

        /* if hovering parchment, scroll, otherwise zoom camera (and decay scroll input) */
        if (quill_hovering_parchment || input.hand_grabbing_parchment) {
            let t = 0;
            if (quill_hovering_parchment) t = sqrt(abs(input.scroll)) * sign(input.scroll);
            if (input.hand_grabbing_parchment) t = input.dampedEvent.movementY * 0.5;

            save.scroll_prog += t * 0.05 * deltaTime;
            input.scroll *= pow(1 - 0.20, 60*deltaTime);

            /* clamp */
            save.scroll_prog = min(1.0, max(0.0, save.scroll_prog))
        } else {
            const t = cbrt(abs(input.scroll)) * sign(input.scroll);

            input.zoom += 0.005*t*input.zoom;
            input.scroll *= pow(1 - 0.5, 60*deltaTime);
            input.zoom = min(20, input.zoom);
        }
    }

    /* generate scroll geometry */
    const scroll_idx = [];
    const scroll_pos = [];
    const scroll_uv  = [];
    {
        let scroll_length = 0;
        function line(x0, z0, x1, z1) {
            const scroll_length_b4 = scroll_length;
            {
                const dx = x0 - x1;
                const dy = z0 - z1;
                scroll_length += Math.sqrt(dx*dx + dy*dy);
            }

            const corners = [
                -1, x0,  z0,   1, x0,  z0,   1, x1,  z1,  -1, x1,  z1, /* Top face    */
            ];

            for (let corner_i = 0; corner_i < corners.length; corner_i += 12) {
                scroll_uv.push(
                    1.0, scroll_length_b4 / SCROLL_LENGTH_WORLDSPACE,
                      0, scroll_length_b4 / SCROLL_LENGTH_WORLDSPACE,
                      0, scroll_length    / SCROLL_LENGTH_WORLDSPACE,
                    1.0, scroll_length    / SCROLL_LENGTH_WORLDSPACE
                )

                const vbuf_i = scroll_pos.length / 3;
                scroll_pos.push(corners[corner_i +  0], corners[corner_i +  1], corners[corner_i +  2]);
                scroll_pos.push(corners[corner_i +  3], corners[corner_i +  4], corners[corner_i +  5]);
                scroll_pos.push(corners[corner_i +  6], corners[corner_i +  7], corners[corner_i +  8]);
                scroll_pos.push(corners[corner_i +  9], corners[corner_i + 10], corners[corner_i + 11]);

                scroll_idx.push(
                  vbuf_i + 0,
                  vbuf_i + 1,
                  vbuf_i + 2,
                  vbuf_i + 2,
                  vbuf_i + 3,
                  vbuf_i + 0
                );
            }
        }

        function draw_curl(
            start_x,
            start_y,
            curl_radius,
            scroll_prog,
            rotation,
            backwards
        ) {
            let curl_length = 0;
            let max_curl_length = lerp(1.5, 3.5, scroll_prog);

            const coils = 4;
            const theta_max = coils * Math.PI * 2;
            const away_step = curl_radius / theta_max;
            const chord = (curl_radius / 25);
            const start = (curl_radius / 7 ) / away_step;

            const line_points = [];
            for (let theta = theta_max; curl_length < max_curl_length;) {
                const x0 = Math.cos(theta + rotation) * (away_step * theta);
                const y0 = Math.sin(theta + rotation) * (away_step * theta);

                theta -= chord / (away_step * theta);

                const r1 = theta;
                const x1 = Math.cos(theta + rotation) * (away_step * theta);
                const y1 = Math.sin(theta + rotation) * (away_step * theta);

                {
                    const dx = x0 - x1;
                    const dy = y0 - y1;
                    curl_length += Math.sqrt(dx*dx + dy*dy);
                }

                line_points.push(
                    start_x + x0, start_y + y0,
                    start_x + x1, start_y + y1,
                );
            }

            if (backwards) {
                for (let i = line_points.length-4; i >= 0; i -= 4) {
                    line(line_points[i + 2], line_points[i + 3],
                         line_points[i + 0], line_points[i + 1]);
                }
            } else
                for (let i = 0; i < line_points.length; i += 4) {
                    line(line_points[i + 0], line_points[i + 1],
                         line_points[i + 2], line_points[i + 3]);
                }
        }

        const scroll_prog = save.scroll_prog;
        const btm_scroll_x = -0.2;
        const scroll_height = 2.0;
        const btm_curl_radius = lerp(0.25, 0.34, 1.0 - scroll_prog);
        const top_curl_radius = lerp(0.25, 0.34,       scroll_prog);

        draw_curl(
            /* start_x     */ btm_scroll_x,
            /* start_y     */ scroll_height*0.5,
            /* curl_radius */ btm_curl_radius,

            /* scroll_prog */ 1 - scroll_prog,
            /* rotation    */ Math.PI,
            /* backwards   */ true
        );
        {
            function bezier4_sample(out, p0, p1, p2, p3, t) {
                out[0] = Math.pow(1 - t, 3) * p0[0] +
                         Math.pow(1 - t, 2) * 3 * t * p1[0] +
                         (1 - t) * 3 * t * t * p2[0] +
                         t * t * t * p3[0];
                out[1] = Math.pow(1 - t, 3) * p0[1] +
                         Math.pow(1 - t, 2) * 3 * t * p1[1] +
                         (1 - t) * 3 * t * t * p2[1] +
                         t * t * t * p3[1];
            }
            const bezier_i = 85;

            const a        = [           0 +  top_curl_radius, -scroll_height*0.5];
            const b        = [btm_scroll_x + -btm_curl_radius,  scroll_height*0.5];
            const control0 = [           0 +  top_curl_radius, -scroll_height*0.3];
            const control1 = [btm_scroll_x + -btm_curl_radius,  scroll_height*0.3];
            const out_from = [0, 0]
            const out_to   = [0, 0]

            for (let i = bezier_i; i > 0; i--) {
                const t0 = (i - 1)/bezier_i;
                bezier4_sample(out_from, a, control0, control1, b, t0);

                const t1 = (i + 0)/bezier_i;
                bezier4_sample(out_to  , a, control0, control1, b, t1);

                line(
                    out_to  [0], out_to  [1],
                    out_from[0], out_from[1],
                );
            }
        }
        draw_curl(
            /* start_x     */ 0,
            /* start_y     */ -scroll_height*0.5,
            /* curl_radius */ top_curl_radius,

            /* scroll_prog */ scroll_prog,
            /* rotation    */ 0,
            /* backwards   */ false
        );

        // console.log(scroll_length);
    }

    /* generate quill geometry */
    const quill_idx = [];
    const quill_pos = [];
    const quill_uv  = [];
    {
        const mat = mat4_create();
        {
            const t = Math.sin(now*1.5) * 0.05;

            save.quill_inertia[0] += save.quill[0] - input.pen_screen_x;
            save.quill_inertia[1] += save.quill[1] - input.pen_screen_y;
            save.quill_inertia[0] *= 1 - Math.pow(1 - 0.90, 60*deltaTime);
            save.quill_inertia[1] *= 1 - Math.pow(1 - 0.90, 60*deltaTime);

            const dx = save.quill_inertia[0] * (quill_hovering_parchment ? 0.002 : 0.0001);
            const dy = save.quill_inertia[1] * (quill_hovering_parchment ? 0.001 : 0.0001);

            mat4_mul(mat, mat, mat4_from_y_rotation(mat4_create(), dx));
            mat4_mul(mat, mat, mat4_from_x_rotation(mat4_create(), dy + Math.PI*0.21 + Math.PI*0.25 * t));
            mat4_mul(mat, mat, mat4_from_translation(mat4_create(), [1.08, 1.07, 0.00]));
            mat4_mul(mat, mat, mat4_from_x_rotation(mat4_create(), -Math.PI/2));
            mat4_mul(mat, mat, mat4_from_y_rotation(mat4_create(),  Math.PI  ));
        }

        const QUILL_HEIGHT   = 1;
        const QUILL_SPLIT    = -0.2;
        const QUILL_SPLIT_UV = 1.0 - (QUILL_SPLIT + 1.0) * 0.5;
        {
            const corners = [
              QUILL_SPLIT, QUILL_HEIGHT, -1,
              QUILL_SPLIT, QUILL_HEIGHT,  1,
                        1,          0.0,  1,
                        1,          0.0, -1, /* Front face  */
            ];

            for (let corner_i = 0; corner_i < corners.length; corner_i += 12) {
                quill_uv.push(
                    1.0, 0.0,
                    0.0, 0.0,
                    0.0, QUILL_SPLIT_UV,
                    1.0, QUILL_SPLIT_UV
                );

                const vbuf_i = quill_pos.length / 3;
                let p = [0, 0, 0, 1];
                for (let i = 0; i < 12; i += 3) {
                    mat4_transform_vec4_xyz(
                        p,
                        corners[corner_i + i + 0],
                        corners[corner_i + i + 1],
                        corners[corner_i + i + 2],
                        1.0,
                        mat
                    );
                    quill_pos.push(
                        p[0] + quill_mouse_pos[0],
                        p[1] + quill_mouse_pos[1],
                        p[2] + quill_mouse_pos[2]
                    );
                }

                quill_idx.push(
                  vbuf_i + 0,
                  vbuf_i + 1,
                  vbuf_i + 2,
                  vbuf_i + 2,
                  vbuf_i + 3,
                  vbuf_i + 0
                );
            }
        }

        {
            const corners = [
                     -1.0+2,          0.0, -1,
                     -1.0+2,          0.0,  1,
              QUILL_SPLIT+2, QUILL_HEIGHT,  1,
              QUILL_SPLIT+2, QUILL_HEIGHT, -1, /* Front face  */
            ];

            for (let corner_i = 0; corner_i < corners.length; corner_i += 12) {
                quill_uv.push(
                    1.0, QUILL_SPLIT_UV,
                    0.0, QUILL_SPLIT_UV,
                    0.0, 1.0,
                    1.0, 1.0
                );

                const vbuf_i = quill_pos.length / 3;
                let p = [0, 0, 0, 1];
                for (let i = 0; i < 12; i += 3) {
                    mat4_transform_vec4_xyz(
                        p,
                        corners[corner_i + i + 0],
                        corners[corner_i + i + 1],
                        corners[corner_i + i + 2],
                        1.0,
                        mat
                    );
                    quill_pos.push(
                        p[0] + quill_mouse_pos[0],
                        p[1] + quill_mouse_pos[1],
                        p[2] + quill_mouse_pos[2]
                    );
                }

                quill_idx.push(
                  vbuf_i + 0,
                  vbuf_i + 1,
                  vbuf_i + 2,
                  vbuf_i + 2,
                  vbuf_i + 3,
                  vbuf_i + 0
                );
            }
        }
    }

    /* generate emoji geometry */
    const emoji_idx = [];
    const emoji_pos = [];
    const emoji_uv  = [];
    {
        function moji(x, y, size, atlas_index) {

            /* generate UVs from atlas_index */
            {
                const u = (           atlas_index % ATLAS_SIZE );
                const v = (Math.floor(atlas_index / ATLAS_SIZE));

                emoji_uv.push(
                    (u+1)/ATLAS_SIZE, (v+1)/ATLAS_SIZE,
                    (u+0)/ATLAS_SIZE, (v+1)/ATLAS_SIZE,
                    (u+0)/ATLAS_SIZE, (v+0)/ATLAS_SIZE,
                    (u+1)/ATLAS_SIZE, (v+0)/ATLAS_SIZE,
                );
            }

            /* generate position + index */
            {
                const vbuf_i = emoji_pos.length / 3;
                const ar = window.innerHeight / window.innerWidth;
                emoji_pos.push(x+size*ar, y-size, 0.1);
                emoji_pos.push(x-size*ar, y-size, 0.1);
                emoji_pos.push(x-size*ar, y+size, 0.1);
                emoji_pos.push(x+size*ar, y+size, 0.1);

                emoji_idx.push(
                    vbuf_i + 0,
                    vbuf_i + 1,
                    vbuf_i + 2,
                    vbuf_i + 2,
                    vbuf_i + 3,
                    vbuf_i + 0
                );
            }
        }

        for (let i = 0; i < INPUT_MODE_COUNT; i++) {
            const ar = window.innerHeight / window.innerWidth;
            let x = -0.850 + ar*0.20*i;
            let y = -0.950;

            let hovered;
            {
                let norm_mouse_x = -1 + (input.raw_mouse_x / window.innerWidth )*2;
                let norm_mouse_y = +1 - (input.raw_mouse_y / window.innerHeight)*2;

                hovered = true;
                hovered &&= Math.abs(norm_mouse_x - x) < 0.1;
                hovered &&= Math.abs(norm_mouse_y - y) < 0.1;
            }

            {
                if (input.lmb_clicked && hovered) input.mode = i;

                let goal_y_offset = 0;
                if (i == input.mode) goal_y_offset = 0.06;
                if (hovered && input.mode != i) goal_y_offset = 0.08;

                save.input_mode_button_y_offsets[i] = lerp(
                    save.input_mode_button_y_offsets[i],
                    goal_y_offset,
                    1 - Math.pow(1 - 0.15, 60*deltaTime)
                );
                y += save.input_mode_button_y_offsets[i];
            }

            const ATLAS_PEN     = 0;
            const ATLAS_RAINBOW = 1;
            const ATLAS_HAND    = 2;
            const ATLAS_PAPER   = 3;

            switch (i) {
                case INPUT_MODE_GRAB_SCROLL: {
                    moji(x         , y,       0.10, ATLAS_PAPER);
                    moji(x+0.025*ar, y,       0.05, ATLAS_HAND);
                } break;

                case INPUT_MODE_PEN: {
                    moji(x         , y,       0.10, ATLAS_PEN);
                } break;

                case INPUT_MODE_PEN_RAINBOW: {
                    moji(x         , y,       0.10, ATLAS_RAINBOW);
                    moji(x-0.020*ar, y+0.030, 0.07, ATLAS_PEN);
                } break;
            }
        }
    }

    /* upload scroll geometry */
    {
        gl.bindBuffer(gl.ARRAY_BUFFER, buf.scroll_v_pos);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(scroll_pos), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, buf.scroll_v_uv);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(scroll_uv), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.scroll_i);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(scroll_idx), gl.STATIC_DRAW);
    }

    /* depth_pass */
    {
        /* bind depth and clear */
        {
            gl.viewport(
                0,
                0,
                DEPTH_TEX_SIZE,
                DEPTH_TEX_SIZE
            );
            gl.bindFramebuffer(gl.FRAMEBUFFER, depth_fb);

            /* enable depth */
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            /* set up premultiplied alpha */
            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.disable(gl.BLEND);

            /* clear all */
            gl.clearColor(1, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        }

        gl.useProgram(shaders.depth.program);
        gl.enableVertexAttribArray(shaders.depth.a_pos);

        gl.uniformMatrix4fv(shaders.depth.u_matrix, false, u_vp);

        /* upload/bind geometry */
        {
            gl.bindBuffer(gl.ARRAY_BUFFER, buf.scroll_v_pos);
            gl.vertexAttribPointer(shaders.paint.a_pos, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.scroll_i);
        }

        gl.drawElements(gl.TRIANGLES, scroll_idx.length, gl.UNSIGNED_SHORT, 0);
    }

    /* drawing pass */
    if (tex_scroll_loaded && input.mode != INPUT_MODE_GRAB_SCROLL) {
        /* bind to scroll texture */
        {
            gl.bindFramebuffer(gl.FRAMEBUFFER, tex_scroll_fb);
            gl.viewport(
                0,
                0,
                SCROLL_WIDTH,
                SCROLL_WIDTH * (SCROLL_LENGTH_WORLDSPACE / 2.0)
            );

            /* set up premultiplied alpha */
            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.enable(gl.BLEND);
        }

        gl.useProgram(shaders.paint.program);
        gl.enableVertexAttribArray(shaders.paint.a_pos);
        gl.enableVertexAttribArray(shaders.paint.a_uv);

        gl.uniformMatrix4fv(shaders.paint.u_matrix, false, u_vp);
        if (input.mode == INPUT_MODE_PEN_RAINBOW) {
            gl.uniform4fv(
                shaders.paint.u_color,
                hsl_to_rgb([Date.now() / 3000 % 1, 0.9, 0.75, 1.0])
                    // .map(x => x * (input.lmb_down && quill_hovering_parchment))
            );
        } else {
            gl.uniform4f(
                shaders.paint.u_color,
                0.30,
                0.22,
                0.15,
                0.9
            );
        }
        gl.uniform2f(
            shaders.paint.u_stroke_from,
            -1 + (input.last_mouse_x / window.innerWidth )*2 * input.lmb_down,
            +1 - (input.last_mouse_y / window.innerHeight)*2 * input.lmb_down
        );
        gl.uniform2f(
            shaders.paint.u_stroke_to,
            -1 + (input.raw_mouse_x / window.innerWidth )*2 * input.lmb_down,
            +1 - (input.raw_mouse_y / window.innerHeight)*2 * input.lmb_down
        );
        input.last_mouse_x = input.raw_mouse_x;
        input.last_mouse_y = input.raw_mouse_y;
        gl.uniform2f(
            shaders.paint.u_aspect_ratio,
            (window.innerWidth  / window.innerWidth),
            (window.innerHeight / window.innerWidth)
        );

        /* upload/bind scroll geometry for paint */
        {
            gl.bindBuffer(gl.ARRAY_BUFFER, buf.scroll_v_pos);
            gl.vertexAttribPointer(shaders.paint.a_pos, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, buf.scroll_v_uv);
            gl.vertexAttribPointer(shaders.paint.a_uv, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.scroll_i);
        }

        /* bind depth texture for paint occlusion */
        {
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, depth_color);
            gl.uniform1i(shaders.paint.u_tex_depth, 0);
        }

        gl.drawElements(gl.TRIANGLES, scroll_idx.length, gl.UNSIGNED_SHORT, 0);

        function hsl_to_rgb(arr) {
            function hue_to_rgb(p, q, t) {
              if (t < 0) t += 1;
              if (t > 1) t -= 1;
              if (t < 1/6) return p + (q - p) * 6 * t;
              if (t < 1/2) return q;
              if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
              return p;
            }

            const h = arr[0];
            const s = arr[1];
            const l = arr[2];

            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue_to_rgb(p, q, h + 1/3);
                g = hue_to_rgb(p, q, h);
                b = hue_to_rgb(p, q, h - 1/3);
            }

            arr[0] = r;
            arr[1] = g;
            arr[2] = b;
            return arr;
        }
    }

    {
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        gl.viewport(
            0,
            0,
            canvas.width,
            canvas.height
        );
    }

    {
        /* set up premultiplied alpha */
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);

        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        /* clear all */
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        /* skydome pass */
        {
            gl.useProgram(shaders.geo.program);
            gl.enableVertexAttribArray(shaders.geo.a_pos);
            gl.enableVertexAttribArray(shaders.geo.a_uv);

            gl.uniformMatrix4fv(shaders.geo.u_matrix, false, u_vp);
            gl.uniform1f(shaders.geo.u_color_mask, 0.4);
            gl.uniform1f(shaders.geo.u_alpha_mask, 1.0);

            /* upload/bind atlas */
            {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_skydome);
                gl.uniform1i(shaders.geo.u_texture, 0);
            }

            /* upload/bind geometry */
            {
                gl.bindBuffer(gl.ARRAY_BUFFER, buf.skydome_v_pos);
                gl.vertexAttribPointer(shaders.geo.a_pos, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, buf.skydome_v_uv);
                gl.vertexAttribPointer(shaders.geo.a_uv, 2, gl.FLOAT, true, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.skydome_i);
            }

            gl.drawElements(gl.TRIANGLES, buf.skydome_i_count, gl.UNSIGNED_SHORT, 0);
        }

        /* scroll pass */
        {
            gl.useProgram(shaders.geo.program);
            gl.enableVertexAttribArray(shaders.geo.a_pos);
            gl.enableVertexAttribArray(shaders.geo.a_uv);

            gl.uniformMatrix4fv(shaders.geo.u_matrix, false, u_vp);
            gl.uniform1f(shaders.geo.u_color_mask, 1.0);
            gl.uniform1f(shaders.geo.u_alpha_mask, 1.0);

            /* upload/bind texture */
            {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_scroll);
                gl.uniform1i(shaders.geo.u_texture, 0);
            }

            /* upload/bind geometry */
            {
                gl.bindBuffer(gl.ARRAY_BUFFER, buf.scroll_v_pos);
                gl.vertexAttribPointer(shaders.geo.a_pos, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, buf.scroll_v_uv);
                gl.vertexAttribPointer(shaders.geo.a_uv, 2, gl.FLOAT, true, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.scroll_i);
            }

            gl.drawElements(gl.TRIANGLES, scroll_idx.length, gl.UNSIGNED_SHORT, 0);
        }

        /* quill pass */
        {
            gl.useProgram(shaders.geo.program);
            gl.enableVertexAttribArray(shaders.geo.a_pos);
            gl.enableVertexAttribArray(shaders.geo.a_uv);

            gl.uniformMatrix4fv(shaders.geo.u_matrix, false, u_vp);
            gl.uniform1f(shaders.geo.u_color_mask, 1.0);
            gl.uniform1f(shaders.geo.u_alpha_mask, lerp(1.0, 0.1, input.lmb_down && quill_hovering_parchment));

            /* upload/bind texture */
            {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_quill);
                gl.uniform1i(shaders.geo.u_texture, 0);
            }

            /* upload/bind geometry */
            {
                gl.bindBuffer(gl.ARRAY_BUFFER, buf.quill_v_pos);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(quill_pos), gl.STATIC_DRAW);
                gl.vertexAttribPointer(shaders.geo.a_pos, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, buf.quill_v_uv);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(quill_uv), gl.STATIC_DRAW);
                gl.vertexAttribPointer(shaders.geo.a_uv, 2, gl.FLOAT, true, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.quill_i);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(quill_idx), gl.STATIC_DRAW);
            }

            gl.drawElements(gl.TRIANGLES, quill_idx.length, gl.UNSIGNED_SHORT, 0);
        }

        /* grid pass */
        {
            gl.useProgram(shaders.grid.program);
            gl.enableVertexAttribArray(shaders.grid.a_pos);
            gl.enableVertexAttribArray(shaders.grid.a_uv);

            gl.uniformMatrix4fv(shaders.grid.u_matrix, false, u_vp);

            /* upload/bind geometry */
            {
                gl.bindBuffer(gl.ARRAY_BUFFER, buf.grid_v_pos);
                gl.vertexAttribPointer(shaders.grid.a_pos, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, buf.grid_v_uv);
                gl.vertexAttribPointer(shaders.grid.a_uv, 2, gl.UNSIGNED_BYTE, true, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.grid_i);
            }

            gl.drawElements(gl.TRIANGLES, buf.grid_i_count, gl.UNSIGNED_SHORT, 0);
        }

        /* geo pass */
        {
            gl.disable(gl.DEPTH_TEST);

            gl.useProgram(shaders.geo.program);
            gl.enableVertexAttribArray(shaders.geo.a_pos);
            gl.enableVertexAttribArray(shaders.geo.a_uv);

            gl.uniformMatrix4fv(shaders.geo.u_matrix, false, mat4_create());
            gl.uniform1f(shaders.geo.u_color_mask, 1.0);
            gl.uniform1f(shaders.geo.u_alpha_mask, 1.0);

            /* upload/bind atlas */
            {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, emoji_atlas);
                gl.uniform1i(shaders.geo.u_texture, 0);
            }

            /* upload/bind geometry */
            {
                gl.bindBuffer(gl.ARRAY_BUFFER, buf.emoji_v_pos);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(emoji_pos), gl.STATIC_DRAW);
                gl.vertexAttribPointer(shaders.geo.a_pos, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, buf.emoji_v_uv);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(emoji_uv), gl.STATIC_DRAW);
                gl.vertexAttribPointer(shaders.geo.a_uv, 2, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.emoji_i);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(emoji_idx), gl.STATIC_DRAW);
            }

            gl.drawElements(gl.TRIANGLES, emoji_idx.length, gl.UNSIGNED_SHORT, 0);
        }

    }

    input.lmb_clicked = false;
})

function mat4_create() {
    let out = new Float32Array(16);
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
}

function mat4_ortho(out, left, right, bottom, top, near, far) {
    let lr = 1 / (left - right);
    let bt = 1 / (bottom - top);
    let nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
}

function mat4_invert(out, a) {
    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    let b00 = a00 * a11 - a01 * a10;
    let b01 = a00 * a12 - a02 * a10;
    let b02 = a00 * a13 - a03 * a10;
    let b03 = a01 * a12 - a02 * a11;
    let b04 = a01 * a13 - a03 * a11;
    let b05 = a02 * a13 - a03 * a12;
    let b06 = a20 * a31 - a21 * a30;
    let b07 = a20 * a32 - a22 * a30;
    let b08 = a20 * a33 - a23 * a30;
    let b09 = a21 * a32 - a22 * a31;
    let b10 = a21 * a33 - a23 * a31;
    let b11 = a22 * a33 - a23 * a32;
    /* Calculate the determinant */
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
        return null;
    }
    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
}

function mat4_perspective(out, fovy, aspect, near, far) {
    let f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
    } else {
        out[10] = -1;
        out[14] = -2 * near;
    }
    return out;
}

function mat4_from_x_rotation(out, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    /* Perform axis-specific matrix multiplication */
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

function mat4_from_y_rotation(out, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    /* Perform axis-specific matrix multiplication */
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

function mat4_from_z_rotation(out, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    /* Perform axis-specific matrix multiplication */
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

function mat4_from_scaling(out, x, y=x, z=x) {
    out[0] = x;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = y;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = z;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

function mat4_from_translation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

function mat4_transform_vec4(out, a, m) {
    let x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
}

function mat4_transform_vec4_xyz(out, x, y, z, w, m) {
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
}

function mat4_mul(out, a, b) {
    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    /* Cache only the current line of the second matrix */
    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}

function mat4_target_to(out, eye, target, up=VEC3_UP) {
    let eyex = eye[0], eyey = eye[1], eyez = eye[2],
         upx =  up[0],  upy =  up[1],  upz =  up[2];
    let z0 = eyex - target[0],
        z1 = eyey - target[1],
        z2 = eyez - target[2];
    let len = z0 * z0 + z1 * z1 + z2 * z2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        z0 *= len;
        z1 *= len;
        z2 *= len;
    }
    let x0 = upy * z2 - upz * z1,
        x1 = upz * z0 - upx * z2,
        x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
}

function lerp(v0, v1, t) { return (1 - t) * v0 + t * v1; }
function inv_lerp(min, max, p) { return (p - min) / (max - min); }

function ray_hit_plane(
    out,

    ray_origin_x, ray_origin_y, ray_origin_z,
    ray_vector_x, ray_vector_y, ray_vector_z,

    plane_origin_x, plane_origin_y, plane_origin_z,
    plane_vector_x, plane_vector_y, plane_vector_z
) {
    const delta_x = plane_origin_x - ray_origin_x;
    const delta_y = plane_origin_y - ray_origin_y;
    const delta_z = plane_origin_z - ray_origin_z;

    const ldot = delta_x*plane_vector_x +
                 delta_y*plane_vector_y +
                 delta_z*plane_vector_z ;

    const rdot = ray_vector_x*plane_vector_x +
                 ray_vector_y*plane_vector_y +
                 ray_vector_z*plane_vector_z ;

    const d = ldot / rdot;
    out[0] = ray_origin_x + ray_vector_x * d;
    out[1] = ray_origin_y + ray_vector_y * d;
    out[2] = ray_origin_z + ray_vector_z * d;

    return out;
}

    </script>
  </body>
</html>
