<!-- vim: sw=4 ts=4 expandtab smartindent ft=javascript
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WebGL Demo</title>
    <style> document, body { margin: 0px; padding: 0px; overflow: hidden; } </style>
  </head>

  <body>
    <canvas id="glcanvas"></canvas>
    <script>
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl2', {antialias: true});
gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
if (!gl) { alert('Failed to initialize WebGL'); }

(window.onresize = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    /* account for e.g. high-retina macbook screens */
    if (window.devicePixelRatio > 1) {
        canvas.style.width = `${canvas.width}px`;
        canvas.style.height = `${canvas.height}px`;
        canvas.width *= window.devicePixelRatio;
        canvas.height *= window.devicePixelRatio;
    }

    gl.viewport(
        0,
        0,
        canvas.width,
        canvas.height
    );
})();

function createProgram(gl, vertexSource, fragmentSource) {
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw new Error(gl.getShaderInfoLog(shader));
        }
        return shader;
    }

    const program = gl.createProgram();

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);

    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(program));
    }

    const wrapper = {program};

    const numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < numAttributes; i++) {
        const attribute = gl.getActiveAttrib(program, i);
        wrapper[attribute.name] = gl.getAttribLocation(program, attribute.name);
    }
    const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < numUniforms; i++) {
        const uniform = gl.getActiveUniform(program, i);
        wrapper[uniform.name] = gl.getUniformLocation(program, uniform.name);
    }

    return wrapper;
}

/* if you're going to use this multiple times in a single program,
 * consider modifying it to not immediately delete all the shaders.
 *
 * or just take the shader compilation hit -- i don't care what you do. */
function shadowForTexture(texture, texture_width, texture_height, texture_pad) {
    /* compile shaders */
    let shaders;
    {
        const vs_img = `
            attribute vec3 a_pos;
            attribute vec2 a_uv;

            uniform mat4 u_matrix;

            varying vec2 v_uv;

            void main() {
                gl_Position = u_matrix * vec4(a_pos.xyz, 1);
                v_uv = a_uv;
            }`;

        const fs_img = `
            precision mediump float;

            varying vec2 v_uv;

            uniform sampler2D u_texture;
            uniform vec2 u_mask;

            void main() {
                gl_FragColor = texture2D(u_texture, v_uv);

                /* somehow alpha got overmultiplied, freaky af */
                // gl_FragColor.xyz /= gl_FragColor.w;

                gl_FragColor.xyz *= u_mask.x;
                gl_FragColor.w   *= u_mask.y;
            }`;


        const vs_fullscreen_blur = `#version 300 es
            precision mediump float;

            out vec2 v_texcoord;

            void main(void) {
                float x = float((gl_VertexID & 1) << 2);
                float y = float((gl_VertexID & 2) << 1);
                v_texcoord.x = x * 0.5;
                v_texcoord.y = y * 0.5;
                gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);
            }
        `;

        const fs_fullscreen_blur = `#version 300 es
            precision mediump float;

            uniform sampler2D u_texture;
            uniform vec2 u_direction;

            in vec2 v_texcoord;

            out vec4 frag_color;

            void main(void) {
                vec2 one_pixel = u_direction*(vec2(1) / vec2(textureSize(u_texture, 0)));

                frag_color = texture(u_texture, v_texcoord) * 0.2270270270;

                frag_color += texture(u_texture, v_texcoord + one_pixel    ) * 0.1945945946;
                frag_color += texture(u_texture, v_texcoord - one_pixel    ) * 0.1945945946;

                frag_color += texture(u_texture, v_texcoord + one_pixel*2.0) * 0.1216216216;
                frag_color += texture(u_texture, v_texcoord - one_pixel*2.0) * 0.1216216216;

                frag_color += texture(u_texture, v_texcoord + one_pixel*3.0) * 0.0540540541;
                frag_color += texture(u_texture, v_texcoord - one_pixel*3.0) * 0.0540540541;

                frag_color += texture(u_texture, v_texcoord + one_pixel*4.0) * 0.0162162162;
                frag_color += texture(u_texture, v_texcoord - one_pixel*4.0) * 0.0162162162;
            }
        `;

        shaders = {
            img:             createProgram(gl, vs_img            , fs_img            ),
            fullscreen_blur: createProgram(gl, vs_fullscreen_blur, fs_fullscreen_blur),
        };
    }

    let prebaked;
    {
      /* some suggestions on AA/multisampling https://stackoverflow.com/a/55976760 */
      const canvas_width  = texture_width  + texture_pad*2;
      const canvas_height = texture_height + texture_pad*2;

      gl.viewport(
          0,
          0,
          canvas_width,
          canvas_height
      );

      /* this way we can just draw the image from (0, 0)..(width,height)
       * and it will have even padding on all sides */
      const pMatrix = mat4_ortho(
          mat4_create(),
          -texture_pad,
          texture_width +texture_pad,
          -texture_pad,
          texture_height+texture_pad,
          1,
          -1
      );

      const render_targets = [
        { tex: gl.createTexture(), fb: gl.createFramebuffer() },
        { tex: gl.createTexture(), fb: gl.createFramebuffer() },
      ];
     
      for (const rt of render_targets) {
          gl.bindTexture(gl.TEXTURE_2D, rt.tex);

          // Upload the image into the texture.
          gl.texImage2D(
              /* target         */ gl.TEXTURE_2D,
              /* level          */ 0,
              /* internalformat */ gl.RGBA,
              /* width          */ canvas_width ,
              /* height         */ canvas_height,
              /* border,        */ 0,
              /* format,        */ gl.RGBA,
              /* type,          */ gl.UNSIGNED_BYTE,
              /* data           */ null
          );
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

          gl.bindFramebuffer(gl.FRAMEBUFFER, rt.fb);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rt.tex, 0);
      }

      /* prebaked rt is bound */
      
      const img_vbuf_pos = gl.createBuffer();
      const img_vbuf_uv  = gl.createBuffer();
      const img_ibuf     = gl.createBuffer();

      {
        const img_idx = [];
        const img_pos = [];
        const img_uv  = [];

        {
            const min_x = 0;
            const min_y = 0;
            const max_x = texture_width;
            const max_y = texture_height;

            img_uv.push(
                1, 0,
                0, 0,
                0, 1,
                1, 1
            );

            const vbuf_i = img_pos.length / 3;
            img_pos.push(max_x, min_y, 0.1);
            img_pos.push(min_x, min_y, 0.1);
            img_pos.push(min_x, max_y, 0.1);
            img_pos.push(max_x, max_y, 0.1);

            img_idx.push(vbuf_i + 0, vbuf_i + 1, vbuf_i + 2, vbuf_i + 2, vbuf_i + 3, vbuf_i + 0);
        }

        /* set up premultiplied alpha */
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);

        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        /* clear all */
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        /* shadow img pass (see color mask) */
        function imgPass(u_color_mask, u_alpha_mask) {
            gl.useProgram(shaders.img.program);
            gl.enableVertexAttribArray(shaders.img.a_pos);
            gl.enableVertexAttribArray(shaders.img.a_uv);

            /* upload/bind atlas */
            {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(shaders.img.u_texture, 0);
            }

            gl.uniformMatrix4fv(shaders.img.u_matrix, false, pMatrix);
            gl.uniform2f(shaders.img.u_mask, u_color_mask, u_alpha_mask);

            /* upload/bind geometry */

            {
                gl.bindBuffer(gl.ARRAY_BUFFER, img_vbuf_pos);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(img_pos), gl.STATIC_DRAW);
                gl.vertexAttribPointer(shaders.img.a_pos, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, img_vbuf_uv);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(img_uv), gl.STATIC_DRAW);
                gl.vertexAttribPointer(shaders.img.a_uv, 2, gl.FLOAT, true, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, img_ibuf);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(img_idx), gl.STATIC_DRAW);
            }

            gl.drawElements(gl.TRIANGLES, img_idx.length, gl.UNSIGNED_SHORT, 0);
        }

        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);

        //imgPass(0.08, 0.2);
        imgPass(0, 0.02);

        /* blur time */
        {
            const passes = [
                [render_targets[1].fb, render_targets[0].tex, [ 0, 10]],
                [render_targets[0].fb, render_targets[1].tex, [ 9,  0]],
                [render_targets[1].fb, render_targets[0].tex, [ 0,  8]],
                [render_targets[0].fb, render_targets[1].tex, [ 7,  0]],
                [render_targets[1].fb, render_targets[0].tex, [ 0,  6]],
                [render_targets[0].fb, render_targets[1].tex, [ 5,  0]],
                [render_targets[1].fb, render_targets[0].tex, [ 0,  4]],
                [render_targets[0].fb, render_targets[1].tex, [ 3,  0]],
                [render_targets[1].fb, render_targets[0].tex, [ 0,  2]],
                [render_targets[0].fb, render_targets[1].tex, [ 1,  0]]
            ];
            for (const [dst_fb, src_tex, dir] of passes) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, dst_fb);

                gl.useProgram(shaders.fullscreen_blur.program);

                gl.uniform2fv(shaders.fullscreen_blur.u_direction, [dir[0]*2, dir[1]*2]);

                /* bind tex */
                {
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, src_tex);
                    gl.uniform1i(shaders.fullscreen_blur.u_texture, 0);
                }

                gl.drawArrays(gl.TRIANGLE_FAN, 0, 3);
            }
        }

        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
        imgPass(1, 1);
      }

      gl.deleteBuffer(img_vbuf_pos);
      gl.deleteBuffer(img_vbuf_uv );
      gl.deleteBuffer(img_ibuf    );

      gl.deleteProgram(shaders.img.program);
      gl.deleteShader(shaders.img.vs);
      gl.deleteShader(shaders.img.fs);

      gl.deleteProgram(shaders.fullscreen_blur.program);
      gl.deleteShader(shaders.fullscreen_blur.vs);
      gl.deleteShader(shaders.fullscreen_blur.fs);

      gl.deleteFramebuffer(render_targets[0].fb);
      gl.deleteFramebuffer(render_targets[1].fb);
      gl.deleteTexture(render_targets[1].tex);
      prebaked = render_targets[0].tex;

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    return prebaked;
}

let shaders;
/* compile shaders */
{
    const vs_geo = `
        attribute vec3 a_pos;
        attribute vec4 a_color;

        uniform mat4 u_matrix;

        varying vec4 v_color;

        void main() {
            gl_Position = u_matrix * vec4(a_pos.xyz, 1);
            v_color = a_color;
        }`;

    const fs_geo = `
        precision mediump float;

        varying vec4 v_color;

        void main() {
            gl_FragColor = vec4(1.0 - v_color.xyz*0.35, 1.0);
        }`;



    const vs_grid = `#version 300 es
        in vec3 a_pos;
        in vec2 a_uv;

        uniform mat4 u_matrix;

        out vec2 v_uv;

        void main() {
            gl_Position = u_matrix * vec4(a_pos.xyz, 1);
            v_uv = (a_uv - 0.5)*abs(a_pos.xy);
        }`;

    const fs_grid = `#version 300 es
        precision mediump float;

        in vec2 v_uv;

        /* https://iquilezles.org/articles/filterableprocedurals/ */

        const float N = 50.0; // grid ratio
        float gridTextureGradBox(in vec2 p, in vec2 ddx, in vec2 ddy) {
            // filter kernel
            vec2 w = max(abs(ddx), abs(ddy)) + 0.01;

            // analytic (box) filtering
            vec2 a = p + 0.5*w;                        
            vec2 b = p - 0.5*w;           
            vec2 i = (floor(a)+min(fract(a)*N,1.0)-
                      floor(b)-min(fract(b)*N,1.0))/(N*w);
            //pattern
            return (1.0-i.x)*(1.0-i.y);
        }

        out vec4 frag_color;

        void main() {
            // vec2 d = 1.0 - step(0.01, fract(v_uv*10.0));
            // gl_FragColor = vec4(max(d.x, d.y));

            vec2 uv = (v_uv - 0.5) + 0.5/N;
            float grid = gridTextureGradBox(uv, dFdx(uv), dFdy(uv));
            frag_color = vec4(1.0 - grid);
            frag_color *= 0.25;
            frag_color *= 0.3 + 0.6*smoothstep(0.0, 0.1, 1.0 - length(v_uv)/5.5);
        }`;



    shaders = {
        geo:     createProgram(gl, vs_geo   , fs_geo   ),
        grid:    createProgram(gl, vs_grid  , fs_grid  ),
    }
}

const buf = {
    geo_v_pos:   gl.createBuffer(),
    geo_v_color: gl.createBuffer(),
    geo_i:       gl.createBuffer(),

    grid_v_pos:  gl.createBuffer(),
    grid_v_uv:   gl.createBuffer(),
    grid_i:      gl.createBuffer(),
};

let input = {
    pitch:  Math.PI*0.25,
    yaw:   -Math.PI*0.25,
    eye: [0, 0, 0, 1],

    dampedEvent: { button: 0, movementX: 0, movementY: 0 },

    cam_pivot_x: 0,
    cam_pivot_y: 0,
    cam_pivot_z: 0,

    zoom:   10,
    scroll:  0,

    lmb_down: false,
    rmb_down: false,
}
let wheelTimeout;
window.onwheel = e => {
    if (input.mouse_down) return;
    input.scroll = Math.sign(e.deltaY);

    clearTimeout(wheelTimeout);
    wheelTimeout = setTimeout(() => input.scroll = 0, 100)
};
window.onmousedown = ev => {
    ev.preventDefault();

    if (ev.button == 0) input.lmb_down = true;
    if (ev.button == 2) input.rmb_down = true;
};
window.onmousemove = ev => {
    input.dampedEvent.button    = ev.button;
    input.dampedEvent.movementX = ev.movementX;
    input.dampedEvent.movementY = ev.movementY;
};
window.oncontextmenu = ev => ev.preventDefault();
window.onmouseup = ev => {
    ev.preventDefault();

    if (ev.button == 0) input.lmb_down = false;
    if (ev.button == 2) input.rmb_down = false;
};


const ATLAS_RESOLUTION    = 500;
const ATLAS_SHADOW_PAD    = 100;
const ATLAS_SCREEN_SIZE_Y = 100;
const ATLAS_ASPECT_RATIO = 1.85; /* width = ATLAS_ASPECT_RATIO * size_y */

const ALIGN_LEFT = 0;
const ALIGN_CENTER = 1;

const SUBSHADER_TEXT  = 0;
const SUBSHADER_IMAGE = 1;

/* higher number = prettier text using more VRAM */
const SDF_FONT_SIZE = 48;

class SensorRenderer {
    constructor(gl) {
        this.dynamic_scale = 32;
        this.color = [1.00, 0.64, 0.00, 1];

        this.z = -0.2;

        this.text_vbuf_pos = [];
        this.text_vbuf_uv  = [];
        this.text_ibuf     = [];

        this.pMatrix = mat4_create();

        /* maps character to location in spritesheet/font_atlas */
        this.sdfs = {};
        this.font_atlas = gl.createTexture();

        this.buf = {
            text_vbuf_pos: gl.createBuffer(),
            text_vbuf_uv:  gl.createBuffer(),
            text_ibuf:     gl.createBuffer()
        };

        /* compile shaders */
        {
            const vs_sensor = `
                attribute vec3 a_pos;
                attribute vec2 a_texcoord;

                uniform mat4 u_matrix;
                uniform vec2 u_texsize;

                varying vec2 v_texcoord;
                varying float v_variant;

                void main() {
                    v_variant = a_pos.z;

                    if (v_variant == ${SUBSHADER_TEXT.toFixed(1)}) {
                        gl_Position = u_matrix * vec4(a_pos.xy, 0, 1);
                        v_texcoord = a_texcoord / u_texsize;
                    } else {
                        gl_Position = u_matrix * vec4(a_pos.xy, 0.0, 1.0);
                        v_texcoord = a_texcoord;
                    }
                }`;

            const fs_sensor = `
                precision mediump float;

                uniform sampler2D u_tex_font;
                uniform sampler2D u_tex_atlas;
                uniform vec4 u_color;
                uniform float u_buffer;
                uniform float u_gamma;

                varying vec2 v_texcoord;
                varying float v_variant;

                void main() {
                    if (v_variant == ${SUBSHADER_TEXT.toFixed(1)}) {
                        float dist = texture2D(u_tex_font, v_texcoord).r;
                        float alpha = smoothstep(u_buffer - u_gamma, u_buffer + u_gamma, dist);
                        gl_FragColor = vec4(u_color.rgb, u_color.a) * alpha;
                    } else {
                        gl_FragColor = texture2D(u_tex_atlas, v_texcoord);
                    }
                }`;

            function createProgram(gl, vertexSource, fragmentSource) {
                function createShader(gl, type, source) {
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        throw new Error(gl.getShaderInfoLog(shader));
                    }
                    return shader;
                }

                const program = gl.createProgram();

                const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);

                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error(gl.getProgramInfoLog(program));
                }

                const wrapper = {program};

                const numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
                for (let i = 0; i < numAttributes; i++) {
                    const attribute = gl.getActiveAttrib(program, i);
                    wrapper[attribute.name] = gl.getAttribLocation(program, attribute.name);
                }
                const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
                for (let i = 0; i < numUniforms; i++) {
                    const uniform = gl.getActiveUniform(program, i);
                    wrapper[uniform.name] = gl.getUniformLocation(program, uniform.name);
                }

                return wrapper;
            }


            this.shaders = {
                sensor: createProgram(gl, vs_sensor, fs_sensor),
            }
        }

        this.image_atlas = gl.createTexture();
        {
            const canvas = document.createElement("canvas");
            const size_x = canvas.width  = ATLAS_RESOLUTION * ATLAS_ASPECT_RATIO;
            const size_y = canvas.height = ATLAS_RESOLUTION;
            const ctx = canvas.getContext("2d");

            const TRI_HEIGHT = 0.22 * ATLAS_RESOLUTION;
            const TRI_WIDTH  = 0.32 * ATLAS_RESOLUTION;
            const TRI_RADIUS = 0.05 * ATLAS_RESOLUTION;
            const TRI_ARC    = 0.5; /* radians */

            const CORNER_RADIUS = (size_y - TRI_HEIGHT)*0.5;

            {
                ctx.fillStyle = "white";

                const q = Math.PI*0.5;
                {
                    ctx.beginPath();
                    const x = size_x * 0.5;
                    const y = size_y * 0.5;

                    const cx = x - CORNER_RADIUS;
                    const cy = y - CORNER_RADIUS - TRI_HEIGHT;
                    /* four corners: 
                     * ctx.arc(x + cx, y + cy, CORNER_RADIUS, 0, q);
                     * ctx.arc(x - cx, y + cy, CORNER_RADIUS, q, q*2);
                     * ctx.arc(x - cx, y - cy - TRI_HEIGHT, CORNER_RADIUS, q*2, q*3);
                     * ctx.arc(x + cx, y - cy - TRI_HEIGHT, CORNER_RADIUS, q*3, q*4);
                     */
                    ctx.arc(x - cx, y - TRI_HEIGHT*0.5, CORNER_RADIUS, q*1, q*3);
                    ctx.arc(x + cx, y - TRI_HEIGHT*0.5, CORNER_RADIUS, q*3, q*1);
                    ctx.fill();
                }

                ctx.beginPath();
                ctx.moveTo(size_x*0.5 + TRI_WIDTH*0.5, size_y - TRI_HEIGHT);
                ctx.   arc(size_x*0.5                , size_y - TRI_RADIUS, TRI_RADIUS,
                                                                                       -TRI_ARC+q,
                                                                                        TRI_ARC+q);
                ctx.lineTo(size_x*0.5 - TRI_WIDTH*0.5, size_y - TRI_HEIGHT);
                ctx.fill();
            }

            /* silly thing */
            {
                ctx.beginPath();
                ctx.arc(180, 200, 110, 0, Math.PI*2);
                ctx.fillStyle = "pink";
                ctx.fill();
                ctx.font = '130px sans-serif';
                ctx.fillText('ðŸŒ¡ï¸', 115, 260);
            }

            gl.bindTexture(gl.TEXTURE_2D, this.image_atlas);
            gl.texImage2D(
                /* target         */ gl.TEXTURE_2D,
                /* level          */ 0,
                /* internalformat */ gl.RGBA,
                /* width          */ canvas.width,
                /* height         */ canvas.height,
                /* border,        */ 0,
                /* format,        */ gl.RGBA,
                /* type,          */ gl.UNSIGNED_BYTE,
                /* data           */ canvas
            );
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }

        if (ATLAS_SHADOW_PAD > 0) {
            const shadowed = shadowForTexture(
                this.image_atlas,
                ATLAS_RESOLUTION * ATLAS_ASPECT_RATIO,
                ATLAS_RESOLUTION,
                ATLAS_SHADOW_PAD
            )
            gl.deleteTexture(this.image_atlas);
            this.image_atlas = shadowed;

        }

        /* generated by shadowForTexture or not, we want to generate mips now */
        {
            gl.bindTexture(gl.TEXTURE_2D, this.image_atlas);
            /* using mips here is lowkey dumb and we could just keep it fixed size,
             * but i forgot how bad antialiasing is for stuff you render with canvas ...
             * might go back to the SDF i had to generate the speech bubble ...*/
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        }

        /* mapbox's TinySDF - https://github.com/mapbox/tiny-sdf */
        let TinySDF;
        {
            const INF = 1e20;

            class _TinySDF {
                constructor({
                    fontSize = 24,
                    buffer = 3,
                    radius = 8,
                    cutoff = 0.25,
                    fontFamily = 'sans-serif',
                    fontWeight = 'normal',
                    fontStyle = 'normal'
                } = {}) {
                    this.buffer = buffer;
                    this.cutoff = cutoff;
                    this.radius = radius;

                    // make the canvas size big enough to both have the specified buffer around the glyph
                    // for "halo", and account for some glyphs possibly being larger than their font size
                    const size = this.size = fontSize + buffer * 4;

                    const canvas = this._createCanvas(size);
                    const ctx = this.ctx = canvas.getContext('2d', {willReadFrequently: true});
                    ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;

                    ctx.textBaseline = 'alphabetic';
                    ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment
                    ctx.fillStyle = 'black';

                    // temporary arrays for the distance transform
                    this.gridOuter = new Float64Array(size * size);
                    this.gridInner = new Float64Array(size * size);
                    this.f = new Float64Array(size);
                    this.z = new Float64Array(size + 1);
                    this.v = new Uint16Array(size);
                }

                _createCanvas(size) {
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = size;
                    return canvas;
                }

                draw(char) {
                    const {
                        width: glyphAdvance,
                        actualBoundingBoxAscent,
                        actualBoundingBoxDescent,
                        actualBoundingBoxLeft,
                        actualBoundingBoxRight
                    } = this.ctx.measureText(char);

                    // The integer/pixel part of the top alignment is encoded in metrics.glyphTop
                    // The remainder is implicitly encoded in the rasterization
                    const glyphTop = Math.ceil(actualBoundingBoxAscent);
                    const glyphLeft = 0;

                    // If the glyph overflows the canvas size, it will be clipped at the bottom/right
                    const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
                    const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));

                    const width = glyphWidth + 2 * this.buffer;
                    const height = glyphHeight + 2 * this.buffer;

                    const len = Math.max(width * height, 0);
                    const data = new Uint8ClampedArray(len);
                    const glyph = {data, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance};
                    if (glyphWidth === 0 || glyphHeight === 0) return glyph;

                    const {ctx, buffer, gridInner, gridOuter} = this;
                    ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);
                    ctx.fillText(char, buffer, buffer + glyphTop);
                    const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);

                    // Initialize grids outside the glyph range to alpha 0
                    gridOuter.fill(INF, 0, len);
                    gridInner.fill(0, 0, len);

                    for (let y = 0; y < glyphHeight; y++) {
                        for (let x = 0; x < glyphWidth; x++) {
                            const a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value
                            if (a === 0) continue; // empty pixels

                            const j = (y + buffer) * width + x + buffer;

                            if (a === 1) { // fully drawn pixels
                                gridOuter[j] = 0;
                                gridInner[j] = INF;

                            } else { // aliased pixels
                                const d = 0.5 - a;
                                gridOuter[j] = d > 0 ? d * d : 0;
                                gridInner[j] = d < 0 ? d * d : 0;
                            }
                        }
                    }

                    edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
                    edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);

                    for (let i = 0; i < len; i++) {
                        const d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
                        data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));
                    }

                    return glyph;
                }
            }

            // 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf
            function edt(data, x0, y0, width, height, gridSize, f, v, z) {
                for (let x = x0; x < x0 + width; x++) edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);
                for (let y = y0; y < y0 + height; y++) edt1d(data, y * gridSize + x0, 1, width, f, v, z);
            }

            // 1D squared distance transform
            function edt1d(grid, offset, stride, length, f, v, z) {
                v[0] = 0;
                z[0] = -INF;
                z[1] = INF;
                f[0] = grid[offset];

                for (let q = 1, k = 0, s = 0; q < length; q++) {
                    f[q] = grid[offset + q * stride];
                    const q2 = q * q;
                    do {
                        const r = v[k];
                        s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;
                    } while (s <= z[k] && --k > -1);

                    k++;
                    v[k] = q;
                    z[k] = s;
                    z[k + 1] = INF;
                }

                for (let q = 0, k = 0; q < length; q++) {
                    while (z[k + 1] < q) k++;
                    const r = v[k];
                    const qr = q - r;
                    grid[offset + q * stride] = f[r] + qr * qr;
                }
            }

            TinySDF = _TinySDF;
        }

        const FONT_SIZE = 40;
        const FONT_NAME = "GraphLabelFont";
        const font = new FontFace(
            FONT_NAME,
            "url(AvenirNext_Variable.ttf)",
            { weight: "bold" }
        );

        /* invoke now-established TinySDF in a for loop to make the font atlas */
        return font.load().then(() => {
            document.fonts.add(font);

            /* use tiny sdf + a for loop to get a texture atlas canvas */
            let sdfImage;
            {
                const chars = ' abcdefghijklmnopqrstuvwxyzZABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()1234567890<,>./?;:\'"\\|{}[]Â°';
                const fontCanvas = document.createElement('canvas');
                fontCanvas.width = fontCanvas.height = 1024
                const ctx = fontCanvas.getContext('2d');

                // Convert alpha-only to RGBA so we can use `putImageData` for building the composite bitmap
                function makeRGBAImageData(alphaChannel, width, height) {
                    const imageData = ctx.createImageData(width, height);
                    for (let i = 0; i < alphaChannel.length; i++) {
                        imageData.data[4 * i + 0] = alphaChannel[i];
                        imageData.data[4 * i + 1] = alphaChannel[i];
                        imageData.data[4 * i + 2] = alphaChannel[i];
                        imageData.data[4 * i + 3] = 255;
                    }
                    return imageData;
                }

                const charWidths = Array.from({ length: chars.length }, _ => 0);

                ctx.clearRect(0, 0, fontCanvas.width, fontCanvas.height);
                const fontSize = +SDF_FONT_SIZE;
                const buffer = Math.ceil(fontSize / 8);
                const radius = Math.ceil(fontSize / 3);
                const sdf = new TinySDF({fontSize, buffer, radius, fontFamily: FONT_NAME });
                const size = fontSize + buffer * 2;

                const now = performance.now();
                let i = 0;
                for (let y = 0; y + size <= fontCanvas.height && i < chars.length; y += size) {
                    for (let x = 0; x + size <= fontCanvas.width && i < chars.length; x += size) {
                        const glyph = sdf.draw(chars[i]);
                        const {data, width, height} = glyph;
                        delete glyph.data;
                        this.sdfs[chars[i]] = { x, y, glyph };
                        ctx.putImageData(makeRGBAImageData(data, width, height), x, y);
                        i++;
                    }
                }
                console.log(`${i} characters (${fontSize}px, with ${buffer}px buffer) rendered in ${Math.round(performance.now() - now)}ms.`)

                sdfImage = ctx.getImageData(0, 0, fontCanvas.width, fontCanvas.height);
            }

            /* upload that canvas to a texture */
            {
                gl.useProgram(this.shaders.sensor.program);
                gl.enableVertexAttribArray(this.shaders.sensor.a_pos);
                gl.enableVertexAttribArray(this.shaders.sensor.a_texcoord);

                const sdfBytes = new Uint8Array(sdfImage.data)

                gl.bindTexture(gl.TEXTURE_2D, this.font_atlas);
                gl.texImage2D(
                    /* target         */ gl.TEXTURE_2D,
                    /* level          */ 0,
                    /* internalformat */ gl.RGBA,
                    /* width          */ sdfImage.width,
                    /* height         */ sdfImage.height,
                    /* border,        */ 0,
                    /* format,        */ gl.RGBA,
                    /* type,          */ gl.UNSIGNED_BYTE,
                    /* data           */ sdfBytes
                );
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                gl.uniform2f(this.shaders.sensor.u_texsize, sdfImage.width, sdfImage.height);
            }

            return this;
        })
    }

    drawText(str, x, y, align) {
        const { sdfs } = this;

        const fontsize = SDF_FONT_SIZE;
        const buf = fontsize / 8;
        const width = fontsize + buf * 2; // glyph width
        const height = fontsize + buf * 2; // glyph height
        const bx = 0; // bearing x

        const scale = this.dynamic_scale / fontsize;
        const lineWidth = str.length * fontsize * scale;

        const pen = { x, y };
        if (align == ALIGN_CENTER) {
            pen.x -= (str.split('').reduce((a, c) => a + sdfs[c].glyph.glyphAdvance, 0) / 2) * scale;
        }
        for (let i = 0; i < str.length; i++) {
            const posX = sdfs[str[i]].x; // pos in sprite x
            const posY = sdfs[str[i]].y; // pos in sprite y
            const advance = sdfs[str[i]].glyph.glyphAdvance;
            const by = sdfs[str[i]].glyph.glyphTop - (fontsize / 2 + buf); // bearing y

            const vbuf_i = this.text_vbuf_pos.length / 3;
            this.text_vbuf_pos.push(
                pen.x + ((bx - buf) * scale)        , pen.y - by * scale           , SUBSHADER_TEXT,
                pen.x + ((bx - buf + width) * scale), pen.y - by * scale           , SUBSHADER_TEXT,
                pen.x + ((bx - buf) * scale)        , pen.y + (height - by) * scale, SUBSHADER_TEXT,
                pen.x + ((bx - buf + width) * scale), pen.y + (height - by) * scale, SUBSHADER_TEXT 
            );

            this.text_vbuf_uv.push(
                posX        , posY,
                posX + width, posY,
                posX        , posY + height,
                posX + width, posY + height
            );

            this.text_ibuf.push(vbuf_i+0, vbuf_i+1, vbuf_i+2,
                                vbuf_i+1, vbuf_i+2, vbuf_i+3);

            pen.x = pen.x + advance * scale;
        }

    }

    clear() {
        this.text_vbuf_pos = [];
        this.text_vbuf_uv  = [];
        this.text_ibuf     = [];
    }

    frame(gl, eye, mvp) {

        /* bubble width, height */
        const size_y = ATLAS_SCREEN_SIZE_Y;
        const size_x = size_y * ATLAS_ASPECT_RATIO;

        const p = [0, 0, 0, 1];
        sensor_positions.sort((a, b) => {
            const dist = p => Math.sqrt((p[0] - eye[0])*(p[0] - eye[0]) +
                                        (p[1] - eye[1])*(p[1] - eye[1]) +
                                        (p[2] - eye[2])*(p[2] - eye[2]));
            return dist(b) - dist(a);
        });
        for (const sensor_pos of sensor_positions) {
            /* position on screen */
            mat4_transform_vec4(p, sensor_pos, mvp);
            const w = p[3];
            p[0] = (0 + (p[0]/w*0.5 + 0.5))*gl.canvas.width;
            p[1] = (1 - (p[1]/w*0.5 + 0.5))*gl.canvas.height;

            {
                const pad = (ATLAS_SHADOW_PAD / ATLAS_RESOLUTION) * ATLAS_SCREEN_SIZE_Y;
                const min_x = p[0] + -size_x*0.5 - pad;
                const min_y = p[1] -  size_y     - pad;
                const max_x = p[0] +  size_x*0.5 + pad;
                const max_y = p[1]               + pad;

                const vbuf_i = this.text_vbuf_pos.length / 3;
                this.text_vbuf_pos.push(max_x, min_y, SUBSHADER_IMAGE);
                this.text_vbuf_pos.push(min_x, min_y, SUBSHADER_IMAGE);
                this.text_vbuf_pos.push(min_x, max_y, SUBSHADER_IMAGE);
                this.text_vbuf_pos.push(max_x, max_y, SUBSHADER_IMAGE);

                this.text_vbuf_uv.push(1, 0, 0, 0, 0, 1, 1, 1);

                this.text_ibuf.push(
                    vbuf_i + 0, vbuf_i + 1,
                    vbuf_i + 2, vbuf_i + 2,
                    vbuf_i + 3, vbuf_i + 0
                );
            }

            /* put it in pMatrix space */
            {
                p[0] -= size_x * 0.125;
                p[1] -= size_y * 0.4 + this.dynamic_scale;
                this.drawText('74.2Â°F', p[0], p[1], 0);
            }
        }

        const pMatrix = mat4_ortho(this.pMatrix, 0, gl.canvas.width, gl.canvas.height, 0, 1, -1);
        gl.viewport(
            0,
            0,
            gl.canvas.width,
            gl.canvas.height
        );

        gl.useProgram(this.shaders.sensor.program);

        /* set up premultiplied alpha */
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);

        {
            const gamma = 2;
            gl.uniformMatrix4fv(this.shaders.sensor.u_matrix, false, pMatrix);
            gl.uniform4fv(this.shaders.sensor.u_color, this.color);
            gl.uniform1f(this.shaders.sensor.u_buffer, 0.75);
            gl.uniform1f(this.shaders.sensor.u_gamma, gamma * 1.4142 / this.dynamic_scale);

            /* upload/bind geometry */
            const vbuf_count = this.text_vbuf_pos.length / 3;
            {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buf.text_vbuf_pos);
                gl.vertexAttribPointer(this.shaders.sensor.a_pos, 3, gl.FLOAT, false, 0, 0);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.text_vbuf_pos), gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.buf.text_vbuf_uv);
                gl.vertexAttribPointer(this.shaders.sensor.a_texcoord, 2, gl.FLOAT, false, 0, 0);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.text_vbuf_uv), gl.STATIC_DRAW);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buf.text_ibuf);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.text_ibuf), gl.STATIC_DRAW);
            }

            /* bind texture */
            {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.font_atlas);
                gl.uniform1i(this.shaders.sensor.u_tex_font , 0);

                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, this.image_atlas);
                gl.uniform1i(this.shaders.sensor.u_tex_atlas, 1);
            }

            gl.drawElements(gl.TRIANGLES, this.text_ibuf.length, gl.UNSIGNED_SHORT, 0);
        }

        this.clear();
    }
}


let building_rooms, sensor_positions;
{
    const e = 0.01;
    building_rooms = [
        mat4_mul(
            mat4_create(),
            mat4_from_translation(mat4_create(), [0.0, 0.5, 0.0]),
            mat4_from_scaling(    mat4_create(), 1.0-e, 0.5-e, 0.4)
        ),
        mat4_mul(
            mat4_create(),
            mat4_from_translation(mat4_create(), [-2.5, 3.25, 0.0]),
            mat4_from_scaling(    mat4_create(), 0.5-e, 2.0-e, 0.4)
        ),
        mat4_mul(
            mat4_create(),
            mat4_from_translation(mat4_create(), [-3.2, 2.25, 0.0]),
            mat4_from_scaling(    mat4_create(), 0.2-e, 0.5-e, 0.4)
        ),
        mat4_mul(
            mat4_create(),
            mat4_from_translation(mat4_create(), [0.0, 3.5, 0.0]),
            mat4_from_scaling(    mat4_create(), 2.0-e, 2.5-e, 0.4)
        ),
        mat4_mul(
            mat4_create(),
            mat4_from_translation(mat4_create(), [0.0, 6.5, 0.0]),
            mat4_from_scaling(    mat4_create(), 1.0-e, 0.5-e, 0.4)
        )
    ];

    sensor_positions = [
        [ 0.00, 0.00, 0.25, 1],
        [ 0.00, 5.00, 0.25, 1],
        [-2.00, 3.00, 0.25, 1],
        [-3.00, 2.00, 0.25, 1],
        [ 0.00, 7.00, 0.25, 1],
    ]

    const size = 0.05;
    for (const p of sensor_positions) {
        building_rooms.push(
            mat4_mul(
                mat4_create(),
                mat4_from_translation(mat4_create(), [p[0], p[1], p[2] - size]),
                mat4_from_scaling(    mat4_create(), size)
            ),
        );
    }
}

/* stupidly verbose way to do this but i do not care right now */
let sensor_renderer = { clear: () => {}, drawText: () => {}, frame: () => {} };
new SensorRenderer(gl).then(x => sensor_renderer = x);

requestAnimationFrame(function frame(timestamp) {
    requestAnimationFrame(frame);

    /* we could apply these changes directly in the event handlers, but the result feels "low fps"
     * because we don't get input events at 60fps. so instead, we apply the changes every frame
     * and simply "damp them" so that they get weaker every frame.
     *
     * (this should probably use delta time rather than simply *= 0.8) */
    {
        const ev = input.dampedEvent;

        /* based on the assumption that if you're zoomed in more,
         * you're doing finer-detailed work and want more precise movements. */
        const zoom_fudge = Math.sqrt(input.zoom/10.0)*2.0;

        if (input.lmb_down) {
            input.pitch -= ev.movementX * 0.0035 * zoom_fudge;
            input.yaw   -= ev.movementY * 0.0035 * zoom_fudge;
            input.yaw = Math.max(-Math.PI*0.5 + 0.01, Math.min(Math.PI*0.5 - 0.01, input.yaw));
        }
        if (input.rmb_down) {
            const unit = [0, -ev.movementX*0.0075*zoom_fudge, ev.movementY*0.0075*zoom_fudge, 1];
            {
                const view    = mat4_create();
                const scratch = mat4_create();

                mat4_from_z_rotation(scratch, input.pitch);
                mat4_mul(view, view, scratch);

                mat4_from_y_rotation(scratch, input.yaw);
                mat4_mul(view, view, scratch);

                mat4_transform_vec4(unit, unit, view);
            }

            input.cam_pivot_x += unit[0];
            input.cam_pivot_y += unit[1];
            input.cam_pivot_z += unit[2];
        }

        ev.button    *= 0.8;
        ev.movementX *= 0.8;
        ev.movementY *= 0.8;
    }

    input.zoom += 0.025*input.scroll*input.zoom;

    const ORTHO = false;
    const mvp = mat4_create();
    const scratch = mat4_create();
    {
        const model = mat4_create();
        {
            // mat4_from_z_rotation(model, input.pitch);

            // mat4_from_y_rotation(scratch, input.yaw);
            // mat4_mul(model, scratch, model);

            mat4_from_scaling(scratch, 0.5)
            mat4_mul(model, scratch, model);
        }

        if (ORTHO) {
            const ar = window.innerWidth / window.innerHeight;
            const projection = mat4_ortho(mat4_create(), -ar, ar, -1, 1, -2, 2);

            mat4_mul(mvp, projection, model);
        } else {
            const FIELD_OF_VIEW = 70 / 180 * Math.PI;
            const ar = window.innerWidth / window.innerHeight;
            const projection = mat4_perspective(mat4_create(), FIELD_OF_VIEW, ar, 0.01, 100.0);

            const view = mat4_create();
            {
                const eye = input.eye = [input.zoom, 0, 0, 1];
                {
                    mat4_from_z_rotation(scratch, input.pitch);
                    mat4_mul(view, view, scratch);

                    mat4_from_y_rotation(scratch, input.yaw);
                    mat4_mul(view, view, scratch);

                    mat4_transform_vec4(eye, eye, view);
                }

                eye[0] += input.cam_pivot_x;
                eye[1] += input.cam_pivot_y;
                eye[2] += input.cam_pivot_z;
                mat4_target_to(
                    view,
                    eye,
                    [input.cam_pivot_x, input.cam_pivot_y, input.cam_pivot_z],
                    [                0,                 0,                 1]
                );
                mat4_invert(view, view);
            }

            mat4_mul(mvp, projection, view);
            mat4_mul(mvp, mvp, model);
        }
    }

    const geo_idx   = [];
    const geo_pos   = [];
    const geo_color = [];
    {
        const e = 0.8;
        const corners = [
            // -1, -1,  1,   1, -1,  1,   1,  1,  1,  -1,  1,  1, /* Top face    */
            -1, -1, -e,  -1,  1, -e,   1,  1, -1,   1, -1, -e, /* Bottom face */

            -1,  1, -1,  -1,  1,  1,   1,  1,  1,   1,  1, -1, /* Front face  */
            -1, -1, -1,   1, -1, -1,   1, -1,  1,  -1, -1,  1, /* Back face   */

             1, -1, -1,   1,  1, -1,   1,  1,  1,   1, -1,  1, /* Right face  */
            -1, -1, -1,  -1, -1,  1,  -1,  1,  1,  -1,  1, -1, /* Left face   */
        ];

        for (let corner_i = 0; corner_i < corners.length; corner_i += 3)
            corners[corner_i+2] += 1.0;

        for (let corner_i = 0; corner_i < corners.length; corner_i += 12) {
            geo_color.push(
                255,   0,   0, 255,
                  0, 255,   0, 255,
                  0,   0, 255, 255,
                255,   0, 255, 255
            )

            const vbuf_i = geo_pos.length / 3;
            geo_pos.push(corners[corner_i +  0], corners[corner_i +  1], corners[corner_i +  2]);
            geo_pos.push(corners[corner_i +  3], corners[corner_i +  4], corners[corner_i +  5]);
            geo_pos.push(corners[corner_i +  6], corners[corner_i +  7], corners[corner_i +  8]);
            geo_pos.push(corners[corner_i +  9], corners[corner_i + 10], corners[corner_i + 11]);

            geo_idx.push(
              vbuf_i + 0,
              vbuf_i + 1,
              vbuf_i + 2,
              vbuf_i + 2,
              vbuf_i + 3,
              vbuf_i + 0
            );
        }
    }

    const grid_idx = [];
    const grid_pos = [];
    const grid_uv  = [];
    {
        const corners = [
            -999, -999, -0,  -999,  999, -0,   999,  999, -0,   999, -999, -0, /* Bottom face */
        ];

        for (let corner_i = 0; corner_i < corners.length; corner_i += 3)
            corners[corner_i+2] -= 0.025;

        for (let corner_i = 0; corner_i < corners.length; corner_i += 12) {
            grid_uv.push(
                255,   0,
                  0,   0,
                  0, 255,
                255, 255,
            );

            const vbuf_i = grid_pos.length / 3;
            grid_pos.push(corners[corner_i +  0], corners[corner_i +  1], corners[corner_i +  2]);
            grid_pos.push(corners[corner_i +  3], corners[corner_i +  4], corners[corner_i +  5]);
            grid_pos.push(corners[corner_i +  6], corners[corner_i +  7], corners[corner_i +  8]);
            grid_pos.push(corners[corner_i +  9], corners[corner_i + 10], corners[corner_i + 11]);

            grid_idx.push(
                vbuf_i + 0,
                vbuf_i + 1,
                vbuf_i + 2,
                vbuf_i + 2,
                vbuf_i + 3,
                vbuf_i + 0
            );
        }
    }

    {
        /* set up premultiplied alpha */
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);

        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        /* clear all */
        gl.clearColor(1, 1, 1, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        /* geo pass */
        for (const m of building_rooms) {
            gl.useProgram(shaders.geo.program);
            gl.enableVertexAttribArray(shaders.geo.a_pos);
            gl.enableVertexAttribArray(shaders.geo.a_color);

            gl.uniformMatrix4fv(
                shaders.geo.u_matrix,
                false,
                mat4_mul(scratch, mvp, m)
            );

            /* upload/bind geometry */
            {
                gl.bindBuffer(gl.ARRAY_BUFFER, buf.geo_v_pos);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo_pos), gl.STATIC_DRAW);
                gl.vertexAttribPointer(shaders.geo.a_pos, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, buf.geo_v_color);
                gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(geo_color), gl.STATIC_DRAW);
                gl.vertexAttribPointer(shaders.geo.a_color, 4, gl.UNSIGNED_BYTE, true, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.geo_i);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geo_idx), gl.STATIC_DRAW);
            }

            gl.drawElements(gl.TRIANGLES, geo_idx.length, gl.UNSIGNED_SHORT, 0);
        }

        /* geo pass */
        {
            gl.useProgram(shaders.grid.program);
            gl.enableVertexAttribArray(shaders.grid.a_pos);
            gl.enableVertexAttribArray(shaders.grid.a_color);

            gl.uniformMatrix4fv(shaders.grid.u_matrix, false, mvp);

            /* upload/bind geometry */
            {
                gl.bindBuffer(gl.ARRAY_BUFFER, buf.grid_v_pos);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(grid_pos), gl.STATIC_DRAW);
                gl.vertexAttribPointer(shaders.grid.a_pos, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, buf.grid_v_uv);
                gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(grid_uv), gl.STATIC_DRAW);
                gl.vertexAttribPointer(shaders.grid.a_uv, 2, gl.UNSIGNED_BYTE, true, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.grid_i);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(grid_idx), gl.STATIC_DRAW);
            }

            gl.drawElements(gl.TRIANGLES, grid_idx.length, gl.UNSIGNED_SHORT, 0);
        }

        sensor_renderer.frame(gl, input.eye, mvp);
    }
})

function mat4_create() {
    let out = new Float32Array(16);
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
}

function mat4_ortho(out, left, right, bottom, top, near, far) {
    let lr = 1 / (left - right);
    let bt = 1 / (bottom - top);
    let nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
}

function mat4_invert(out, a) {
    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    let b00 = a00 * a11 - a01 * a10;
    let b01 = a00 * a12 - a02 * a10;
    let b02 = a00 * a13 - a03 * a10;
    let b03 = a01 * a12 - a02 * a11;
    let b04 = a01 * a13 - a03 * a11;
    let b05 = a02 * a13 - a03 * a12;
    let b06 = a20 * a31 - a21 * a30;
    let b07 = a20 * a32 - a22 * a30;
    let b08 = a20 * a33 - a23 * a30;
    let b09 = a21 * a32 - a22 * a31;
    let b10 = a21 * a33 - a23 * a31;
    let b11 = a22 * a33 - a23 * a32;
    /* Calculate the determinant */
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
        return null;
    }
    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
}

function mat4_perspective(out, fovy, aspect, near, far) {
    let f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
    } else {
        out[10] = -1;
        out[14] = -2 * near;
    }
    return out;
}

function mat4_from_x_rotation(out, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    /* Perform axis-specific matrix multiplication */
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

function mat4_from_y_rotation(out, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    /* Perform axis-specific matrix multiplication */
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

function mat4_from_z_rotation(out, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    /* Perform axis-specific matrix multiplication */
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

function mat4_from_scaling(out, x, y=x, z=x) {
    out[0] = x;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = y;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = z;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

function mat4_from_translation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

function mat4_transform_vec4(out, a, m) {
    let x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
}

function mat4_mul(out, a, b) {
    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    /* Cache only the current line of the second matrix */
    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}

function mat4_target_to(out, eye, target, up=VEC3_UP) {
    let eyex = eye[0], eyey = eye[1], eyez = eye[2],
         upx =  up[0],  upy =  up[1],  upz =  up[2];
    let z0 = eyex - target[0],
        z1 = eyey - target[1],
        z2 = eyez - target[2];
    let len = z0 * z0 + z1 * z1 + z2 * z2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        z0 *= len;
        z1 *= len;
        z2 *= len;
    }
    let x0 = upy * z2 - upz * z1,
        x1 = upz * z0 - upx * z2,
        x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
}

    </script>
  </body>
</html>
