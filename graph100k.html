<!-- vim: sw=4 ts=4 expandtab smartindent ft=javascript
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WebGL Demo</title>
    <style> document, body { margin: 0px; padding: 0px; overflow: hidden; } </style>
  </head>

  <body>
    <canvas id="inspectorGraphCanvas"></canvas>
    <script>
/*
 * [ ] reuse gpu buffers 'cross frames
 * [ ] don't invert mat4 in drawText
 * [ ] have frame ring buffer for scratch mats
 */

const SECOND = 1000;
const MINUTE = 60 * SECOND;
const HOUR   = 60 * MINUTE;
const DAY    = 24 * HOUR;
            
/* maps character to location in spritesheet */
const sdfs = {};
/* higher number = prettier text using more VRAM */
const SDF_FONT_SIZE = 32;

/* how big text on screen */
const FONT_WORLD_SPACE_SIZE = 32;

const RIGHT_PAD = 2.5 * FONT_WORLD_SPACE_SIZE; /* right side of graph with units */
const SOURCE_DATA_INTERVAL = MINUTE*5;         /* how spaced out are the entries in your source data? */

const MAX_DATA = (2 * 1000 * 1000);
const ts_data_min = Date.parse("2024-04-01T22:15:00Z");
const ts_data_max = Date.parse("2024-04-08T19:30:00Z");
const INTERVAL = (ts_data_max - ts_data_min) / MAX_DATA;

const graphs = [
    {
        name: 'temp',
        unit_suffix: 'Â°F',
        units_per_stripe: 5,
        lines: new Map()
    },
];

for (const g of graphs) {
    g.bounds = {
        data_range_min: 0,
        data_range_max: 0
    };
}

const graphCanvas = document.getElementById('inspectorGraphCanvas');
const gl = graphCanvas.getContext('webgl2', {antialias: true});
gl.getExtension("OES_element_index_uint");
if (!gl) { alert('Failed to initialize WebGL'); }

/* [temp, rad temp, humidity, pressure, light] */
{
    const lines = graphs[0].lines;

    const GOLDEN_RATIO = 1.618033988749894;
    const red = [1.0, 0.6, 0.6, 1.0];
    const blu = [0.6, 0.6, 1.0, 1.0];
    for (const [clr, key] of [[red, '100k'], [blu, '1 mil']])
        lines.set(key, {
            data: [],
            color: clr, // hsl_to_rgb([(GOLDEN_RATIO * lines.size)%1.0, 0.6, 0.75, 1.0]),
            bounds: {
                interval: 0,
                x_min : 0,
                x_max : 0,
                ts_min: 0,
                ts_max: 0,
                y_min : 0,
                y_max : 0,
            }
        });

    for (let i = 0; i < 100 * 1000; i++)
        lines.get('100k').data.push(
            70 + Math.sin(i * 0.000001)       +
                 Math.sin(i * 0.00001 ) * 0.5 +
                 0.1*Math.random() - 0.1 * Math.random() - 0.1
             );

    for (let i = 0; i < MAX_DATA; i++)
        lines.get('1 mil').data.push(
            70 + Math.sin(i * 0.000001)       +
                 Math.sin(i * 0.00001 ) * 0.5 +
                 0.1*Math.random() - 0.1 * Math.random()
             );

    for (const graph of graphs) {

        /* find min/max */
        let data_range_min = Infinity, data_range_max = -Infinity;
        {
            for (const { data, color } of graph.lines.values()) {
                for (const datum of data) {
                    data_range_min = Math.min(data_range_min, Math.min(datum));
                    data_range_max = Math.max(data_range_max, Math.max(datum));
                }
            }
        }
        graph.bounds.data_range_min = data_range_min;
        graph.bounds.data_range_max = data_range_max;

        /* upload data to GPU */
        for (const line of graph.lines.values()) {
            line.data_count = line.data.length - 1;

            const buf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(line.data), gl.STATIC_DRAW);
            line.data = buf;
        }

    }
}

let pMatrix = mat4_create();
(window.onresize = () => {
    graphCanvas.width = window.innerWidth;
    graphCanvas.height = window.innerHeight;

    /* account for e.g. high-retina macbook screens */
    if (window.devicePixelRatio > 1) {
        graphCanvas.style.width = `${graphCanvas.width}px`;
        graphCanvas.style.height = `${graphCanvas.height}px`;
        graphCanvas.width *= window.devicePixelRatio;
        graphCanvas.height *= window.devicePixelRatio;
    }

    gl.viewport(
        0,
        0,
        graphCanvas.width,
        graphCanvas.height
    );
})();

const input = {
    scroll:  0, /* one frame of "zoom" */
    zoom:    1.0,
    camera_x: 1, /* offset from left * zoom */

    /* touch controls */
    touch_last_positions: [{ x: 0, y: 0 },
                           { x: 0, y: 0 },
                           { x: 0, y: 0 }], /* do we care about more than 3 touches? seems excessive */
    touch_start_gap : 0,  /* used for pinch */
    touch_start_zoom: 1.0,
    touch_zooming   : false,

    mouse_goal_x:  0,
    mouse_goal_y:  0,
    mouse_x:  0,
    mouse_y:  0,
    mouse_down_x: 0, /* position of mouse when it went down */
    mouse_down_y: 0,

    mouse_down:     false,
    mouse_released: false,
}

/* mouse controls */
{
    window.onwheel = e => {
        input.scroll = Math.sign(e.deltaY);
    }
    let pointer_id;
    window.onmousedown = e => {
        input.mouse_down = true;
        input.mouse_down_x = input.mouse_x = input.mouse_goal_x = e.clientX*window.devicePixelRatio;
        input.mouse_down_y = input.mouse_y = input.mouse_goal_y = e.clientY*window.devicePixelRatio;
    }
    window.onmousemove = e => {
        input.mouse_goal_x = e.clientX*window.devicePixelRatio;
        input.mouse_goal_y = e.clientY*window.devicePixelRatio;
    }
    window.onmouseup = e => {
        input.mouse_released = true;
        input.mouse_goal_x = e.clientX*window.devicePixelRatio;
        input.mouse_goal_y = e.clientY*window.devicePixelRatio;
    }
}

/* touch controls */
{
    const opts = { passive: false };

    const ZOOM = 1;

    window.addEventListener("touchstart", ev => {
        ev.preventDefault();

        let center_x = 0;
        const touch_count = ev.touches.length;
        {
            for (let i = 0; i < touch_count; i++) {
                const x = ev.touches[i].clientX*window.devicePixelRatio;
                input.touch_last_positions[i].x = x;
                center_x += x;
            }
            center_x /= touch_count;
        }

        /* drag */
        {
            input.mouse_down = true;
            input.mouse_x = input.mouse_goal_x = input.mouse_down_x = center_x;
        }

        /* zoom */
        if (ZOOM && ev.touches.length > 1) {
            input.touch_zooming = true;
            input.touch_start_gap = Math.abs(ev.touches[0].clientX - ev.touches[1].clientX)*window.devicePixelRatio;
            input.touch_start_zoom = input.zoom;
        }
    }, opts);

    window.addEventListener("touchmove", ev => {
        ev.preventDefault();

        const touch_count = ev.touches.length;
        let center_x = 0;
        {
            for (let i = 0; i < touch_count; i++) {
                const x = ev.touches[i].clientX*window.devicePixelRatio;
                input.touch_last_positions[i].x = x;
                center_x += x;
            }
            center_x /= touch_count;
        }

        input.mouse_goal_x = center_x;
    }, opts);

    window.addEventListener("touchend", ev => {
        ev.preventDefault();

        input.touch_zooming = false;

        input.mouse_released = true;
    }, opts);
}


const texture = gl.createTexture();

const buf = {
    text_v_pos: gl.createBuffer(),
    text_v_uv: gl.createBuffer(),

    geo_v_pos: gl.createBuffer(),
    geo_v_color: gl.createBuffer(),
    geo_idx: gl.createBuffer(),

    graph_idx: gl.createBuffer(),
}

gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.graph_idx);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 2, 1, 3]), gl.STATIC_DRAW);


let shaders;
/* compile shaders */
{
    const text_vs = `
        attribute vec2 a_pos;
        attribute vec2 a_texcoord;

        uniform mat4 u_matrix;
        uniform vec2 u_texsize;

        varying vec2 v_texcoord;

        void main() {
            gl_Position = u_matrix * vec4(a_pos.xy, -0.2, 1);
            v_texcoord = a_texcoord / u_texsize;
        }`;

    const text_fs = `
        precision mediump float;

        uniform sampler2D u_texture;
        uniform vec4 u_color;
        uniform float u_buffer;
        uniform float u_gamma;

        varying vec2 v_texcoord;

        void main() {
            float dist = texture2D(u_texture, v_texcoord).r;
            float alpha = smoothstep(u_buffer - u_gamma, u_buffer + u_gamma, dist);
            gl_FragColor = vec4(u_color.rgb, alpha * u_color.a);
        }`;


    const geo_vs = `
        attribute vec3 a_pos;
        attribute vec4 a_color;

        uniform mat4 u_matrix;

        varying vec4 v_color;

        void main() {
            gl_Position = u_matrix * vec4(a_pos.xyz, 1);
            v_color = a_color;
        }`;

    const geo_fs = `
        precision mediump float;

        varying vec4 v_color;

        void main() {
            gl_FragColor = v_color;
        }`;


    const graph_vs = `#version 300 es

        in vec2 a_instance_y;

        /* book keeping */
        uniform mat4  u_matrix;
        uniform float u_point_count;
        uniform float u_interval; /* in ms */

        /* input/output domains */
        uniform vec2 u_canvas_size;
        uniform float u_x_min;
        uniform float u_x_max;
        uniform float u_y_min;
        uniform float u_y_max;
        uniform float u_ts_min;
        uniform float u_ts_max;
        uniform float u_data_range_min;
        uniform float u_data_range_max;

        /* aesthetics */
        uniform float u_aspect_ratio;
        uniform float u_thickness;

        float remap(
            float to_min,
            float to_max,
            float val,
            float from_min,
            float from_max
        ) {
            return to_min + (val - from_min) * (to_max - to_min) / (from_max - from_min);
        }

        void main() {

            vec2 a, b;
            {
                float idx = float(gl_InstanceID);
                float data = a_instance_y[0];
                float ts = u_ts_min + idx * u_interval;
                a.x = remap(u_x_min, u_x_max,   ts, u_ts_min,         u_ts_max        );
                a.y = remap(u_y_min, u_y_max, data, u_data_range_max, u_data_range_min);
            }
            {
                float idx = float(gl_InstanceID + 1);
                float data = a_instance_y[1];
                float ts = u_ts_min + idx * u_interval;
                b.x = remap(u_x_min, u_x_max,   ts, u_ts_min,         u_ts_max        );
                b.y = remap(u_y_min, u_y_max, data, u_data_range_max, u_data_range_min);
            }

            a = (u_matrix * vec4(a, 0, 1)).xy;
            b = (u_matrix * vec4(b, 0, 1)).xy;

            vec2 delta  = b - a;
            vec2 normal = vec2(-delta.y, delta.x);
            normal.y *= u_aspect_ratio;
            normal = normalize(normal) * u_thickness * 0.5;
            normal.x /= u_aspect_ratio;
            if ((gl_VertexID % 2) == 1) normal *= -1.0;
            
            float line_z = float(gl_InstanceID) / u_point_count - 1.0;
            gl_Position = vec4(0.0, 0.0, line_z, 1.0);            
            gl_Position.xy = ((gl_VertexID < 2) ? a : b) + normal;
        }`;

    const graph_fs = `#version 300 es
        precision mediump float;

        uniform vec4 u_color;

        out vec4 color;

        void main() {
            color = u_color;
        }`;


// for (let datapoint_i = 0; datapoint_i < (data.length - 1); datapoint_i++) {
//     let a_x, a_y;
//     {
//         const idx = datapoint_i;
//         const ts = ts_min + idx * INTERVAL;
//         a_x = remap(x_min, x_max, ts, ts_min, ts_max, ts);
//         a_y = remap(y_min, y_max, data[idx], data_range_max, data_range_min);
//     }

//     let b_x, b_y;
//     {
//         const idx = datapoint_i + 1;
//         const ts = ts_min + idx * INTERVAL;
//         b_x = remap(x_min, x_max, ts, ts_min, ts_max, ts);
//         b_y = remap(y_min, y_max, data[idx], data_range_max, data_range_min);
//     }

//     drawLine(
//         a_x, a_y,
//         b_x, b_y,
//         5,
//         color
//     );
// }

    function createProgram(gl, vertexSource, fragmentSource) {
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        const program = gl.createProgram();

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);

        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error(gl.getProgramInfoLog(program));
        }

        const wrapper = {program};

        const numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (let i = 0; i < numAttributes; i++) {
            const attribute = gl.getActiveAttrib(program, i);
            wrapper[attribute.name] = gl.getAttribLocation(program, attribute.name);
        }
        const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < numUniforms; i++) {
            const uniform = gl.getActiveUniform(program, i);
            wrapper[uniform.name] = gl.getUniformLocation(program, uniform.name);
        }

        return wrapper;
    }


    shaders = {
        text  : createProgram(gl,  text_vs,  text_fs),
        geo   : createProgram(gl,   geo_vs,   geo_fs),
        graph : createProgram(gl, graph_vs, graph_fs)
    }
}

{
    gl.useProgram(shaders.text.program);
    gl.enableVertexAttribArray(shaders.text.a_pos);
    gl.enableVertexAttribArray(shaders.text.a_texcoord);

    /* upload new SDF to texture */
    {
        const sdfImage = updateSDF();
        // sdfs[' '].width = sdfs['w'].width;
        const sdfBytes = new Uint8Array(sdfImage.data)

        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfImage.width, sdfImage.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, sdfBytes);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.uniform2f(shaders.text.u_texsize, sdfImage.width, sdfImage.height);
    }
}

let last;
requestAnimationFrame(function frame(elapsed) {
    requestAnimationFrame(frame);

    let dt = 0;
    elapsed /= 1000;
    if (last != undefined) dt = elapsed - last;
    last = elapsed;

    /* camera transform */
    const units_view = mat4_create();
    let fontscale = 32;
    let view = mat4_create();
    {
        const full_width = window.innerWidth*window.devicePixelRatio;

        const t = 1 - Math.pow(1 - 0.15, 60*dt)
        input.mouse_x = lerp(input.mouse_x, input.mouse_goal_x, t);
        input.mouse_y = lerp(input.mouse_y, input.mouse_goal_y, t);

        let zoom_delta;
        {
            const zoom_b4 = input.zoom;

            /* mouse zooming */
            input.zoom *= 1.0 - input.scroll*dt*2.5;

            /* touch zooming */
            if (input.touch_zooming) {
                const gap = Math.abs(input.touch_last_positions[0].x - input.touch_last_positions[1].x);
                const ratio = input.touch_start_gap / gap;

                input.zoom = input.touch_start_zoom * ratio;
            }

            input.zoom = Math.min(input.zoom, 1.0);
            /* hack; look at interval to determine proper value */
            input.zoom = Math.max(input.zoom, 0.0001);
            zoom_delta = input.zoom - zoom_b4;
        }


        let cx = input.camera_x;

        /* offset the camera to keep us centered on what we're scrolling toward */
        if (Math.abs(zoom_delta) > 0) {
            let bias = (0.5 - input.mouse_x / (full_width - RIGHT_PAD));
            bias = Math.max(-0.5, bias);
            const delta = full_width * zoom_delta*bias;
            cx += delta;
        }

        /* move camera with drags */
        {
            cx += input.mouse_down ? (input.mouse_down_x - input.mouse_x) * input.zoom : 0;
            cx = Math.max(cx, -full_width*(1.0 - input.zoom)*0.5);
            cx = Math.min(cx,  full_width*(1.0 - input.zoom)*0.5);

            if (input.mouse_released) {
                input.mouse_released = input.mouse_down = false;
                input.camera_x = cx;
            }
        }

        /* this just makes it so w/o bias you don't zoom back in and out to the same place,
         * may not be necessary. try deleting it!  */
        if (Math.abs(zoom_delta) > 0) input.camera_x = cx;

        mat4_ortho(
            view,
            cx - input.zoom,
            cx + input.zoom,
            -1, 1,
            -1, 1
        );

        input.scroll = 0; /* tried exponential decay; needs more tweaking though */
    }

    pMatrix = mat4_ortho(
        pMatrix,
        gl.canvas.width *-0.5, gl.canvas.width * 0.5 + RIGHT_PAD,
        gl.canvas.height* 0.5, gl.canvas.height*-0.5,
        1, -1
    );

    const text_pos = [];
    const text_uv = [];

    const geo_pos   = [];
    const geo_color = [];
    const geo_idx   = [];

    const ALIGN_LEFT = 0;
    const ALIGN_CENTER = 1;
    function drawTextWithView(view, str, worldX, worldY, align = ALIGN_LEFT) {
        const size = fontscale;

        const pos = [worldX, worldY, 0, 1]
        mat4_transform_vec4(pos, pos, view);
        const x = Math.round(pos[0]);
        const y = Math.round(pos[1]);

        const fontsize = SDF_FONT_SIZE;
        const buf = fontsize / 8;
        const width = fontsize + buf * 2; // glyph width
        const height = fontsize + buf * 2; // glyph height
        const bx = 0; // bearing x

        const scale = size / fontsize;
        const lineWidth = str.length * fontsize * scale;

        const pen = { x, y };
        if (align == ALIGN_CENTER) {
            pen.x -= (str.split('').reduce((a, c) => a + sdfs[c].glyph.glyphAdvance, 0) / 2) * scale;
        }
        for (let i = 0; i < str.length; i++) {
            const posX = sdfs[str[i]].x; // pos in sprite x
            const posY = sdfs[str[i]].y; // pos in sprite y
            const advance = sdfs[str[i]].glyph.glyphAdvance;
            const by = sdfs[str[i]].glyph.glyphTop - (fontsize / 2 + buf); // bearing y

            text_pos.push(
                pen.x + ((bx - buf) * scale), pen.y - by * scale,
                pen.x + ((bx - buf + width) * scale), pen.y - by * scale,
                pen.x + ((bx - buf) * scale), pen.y + (height - by) * scale,

                pen.x + ((bx - buf + width) * scale), pen.y - by * scale,
                pen.x + ((bx - buf) * scale), pen.y + (height - by) * scale,
                pen.x + ((bx - buf + width) * scale), pen.y + (height - by) * scale
            );

            text_uv.push(
                posX, posY,
                posX + width, posY,
                posX, posY + height,
                posX + width, posY,
                posX, posY + height,
                posX + width, posY + height
            );

            pen.x = pen.x + advance * scale;
        }
    }

    function drawText(str, worldX, worldY, align = ALIGN_LEFT) {
        drawTextWithView(view, str, worldX, worldY, align = ALIGN_LEFT);
    }

    function drawBoxWithView(view,  min_x, min_y,   max_x, max_y,   color, z = 0.0 ) {
        geo_color.push(
            color[0], color[1], color[2], color[3],
            color[0], color[1], color[2], color[3],
            color[0], color[1], color[2], color[3],
            color[0], color[1], color[2], color[3]
        );

        const vbuf_i = geo_pos.length / 3;

        const pos = [0, 0, 0, 1]
        pos[0] = max_x, pos[1] = min_y, mat4_transform_vec4(pos, pos, view), geo_pos.push(pos[0], pos[1], z)
        pos[0] = min_x, pos[1] = min_y, mat4_transform_vec4(pos, pos, view), geo_pos.push(pos[0], pos[1], z)
        pos[0] = min_x, pos[1] = max_y, mat4_transform_vec4(pos, pos, view), geo_pos.push(pos[0], pos[1], z)
        pos[0] = max_x, pos[1] = max_y, mat4_transform_vec4(pos, pos, view), geo_pos.push(pos[0], pos[1], z)

        geo_idx.push(vbuf_i + 0, vbuf_i + 1, vbuf_i + 2, vbuf_i + 2, vbuf_i + 3, vbuf_i + 0);
    }

    function drawBox( min_x, min_y,   max_x, max_y,   color, z = 0.0 ) {
        drawBoxWithView(view,  min_x, min_y,   max_x, max_y,   color);
    }

    /* use "draw*" to fill buffers with interesting data */
    {
        /* abuse the view and pixel matrix to stop us from rendering stuff that's offscreen */
        let screen_min_x, screen_max_x;
        {
            let p = [0, 0, 0, 1]

            p = [-0.500 * window.innerWidth  * window.devicePixelRatio, 0, 0, 1];
            mat4_transform_vec4(p, p, view);
            mat4_transform_vec4(p, p, pMatrix);
            screen_min_x = p[0];

            p = [ 0.500 * window.innerWidth  * window.devicePixelRatio, 0, 0, 1];
            mat4_transform_vec4(p, p, view);
            mat4_transform_vec4(p, p, pMatrix);
            screen_max_x = p[0];
        }

        let interval = DAY;
        {
            const ts_delta_ms = ts_data_max - ts_data_min;

            const intervals_ms = [
                MINUTE*3,
                MINUTE*15,
                HOUR*2,
                HOUR*8,
                DAY*2
            ];

            let closest_interval_delta = Infinity;
            for (let i = 0; i < intervals_ms.length; i++) {
                const delta = Math.abs(input.zoom*ts_delta_ms - intervals_ms[i]);

                if (delta < closest_interval_delta) {
                    closest_interval_delta = delta;
                    interval = intervals_ms[i] * 0.25;
                }
            }
        }

        /* now that we know the interval, you could adjust the start time to align nicely with it */
        const ts_min = ts_data_min; // Math.floor(ts_data_min / DAY) * DAY;
        const ts_max = ts_data_max;

        for (let graph_idx = 0; graph_idx < graphs.length; graph_idx++) {
            const { unit_suffix, bounds, units_per_stripe, lines } = graphs[graph_idx];

            const full_width  = window.innerWidth  * window.devicePixelRatio;
            const full_height = window.innerHeight * window.devicePixelRatio;

            const TOP_PAD    = 40;
            const BOTTOM_PAD = 15;

            const GRAPH_HEIGHT = 0.16;

            const top = -0.492 + TOP_PAD/full_height;
            const x_min = -0.500 * full_width;
            const x_max =  0.500 * full_width;
            const y_min = (top + (1.25*graph_idx + 0)*GRAPH_HEIGHT)*full_height;
            const y_max = (top + (1.25*graph_idx + 1)*GRAPH_HEIGHT)*full_height;

            drawBox(x_min, y_min-TOP_PAD, x_max, y_max+BOTTOM_PAD, [255, 255, 255, 255]);

            /* data */
            const { data_range_min, data_range_max } = bounds;

            /* vertical detail */
            {
                const stripe_first = Math.floor(data_range_min/units_per_stripe)*units_per_stripe;
                const stripe_last  = Math. ceil(data_range_max/units_per_stripe)*units_per_stripe;
                const stripe_count = (data_range_max - data_range_min)/units_per_stripe;
                const stripe_thickness = (y_min - y_max)/stripe_count*0.25;

                for (let i = stripe_first; i <= stripe_last; i += units_per_stripe) {
                    const units = i;

                    const t = inv_lerp(data_range_max, data_range_min, units);
                    if (Math.abs(t - 0.5) > 0.5) continue;

                    const y = lerp(y_min, y_max, t);
                    drawBox(
                        x_min, Math.max(y_min, Math.min(y_max, y - stripe_thickness)),
                        x_max, Math.min(y_max, Math.max(y_min, y + stripe_thickness)),
                        [245, 250, 255, 255]
                    );

                    drawTextWithView(
                        units_view,
                        i + unit_suffix,
                        x_max + RIGHT_PAD - FONT_WORLD_SPACE_SIZE - 5,
                        Math.max(y_min, Math.min(y_max, y + FONT_WORLD_SPACE_SIZE * 0.3)),
                        ALIGN_CENTER
                    );
                }

                // const stripe_count = Math.ceil(data_range_max - data_range_min);
                // const y_delta = y_max - y_min;
                // for (let i = 0; i < stripe_count; i++) {
                //     const y = lerp(y_min, y_max, inv_lerp(0, stripe_count, 0.5 + i));
                //     drawBox(
                //         x_min, y - (y_delta/stripe_count*0.25),
                //         x_max, y + (y_delta/stripe_count*0.25),
                //         [245, 250, 255, 255]
                //     );
                // }
            }

            /* horizontal detail */
            {
                const interval_count = 1 + Math.ceil((ts_max - ts_min) / interval);

                /* text labels */
                for (let interval_i = 0; interval_i < interval_count; interval_i++) {
                    const ts = Math.min(ts_max, ts_min + interval_i*interval);
                    const t = inv_lerp(ts_min, ts_max, ts);

                    const x = lerp(x_min, x_max, t);
                    if (Math.abs(lerp(screen_min_x, screen_max_x, t)) > 1.05) continue;

                    const pad = input.zoom*30;
                    const text_x = Math.max(x_min + pad, Math.min(x_max - pad, x));

                    const date = new Date(ts);
                    drawText(
                        ((ts % DAY) == 0)
                            ? `${date.getUTCDate()}/${date.getUTCMonth()}`
                            : `${date.getUTCHours()}:${(date.getUTCMinutes()+'').padEnd(2, '0')}`,
                        text_x,
                        y_min - FONT_WORLD_SPACE_SIZE,
                        ALIGN_CENTER
                    );
                }

                /* lines */
                for (let interval_i = 0; interval_i < interval_count; interval_i += (1/3)) {
                    const ts = Math.min(ts_max, ts_min + interval_i*interval);
                    const t = inv_lerp(ts_min, ts_max, ts);

                    const x = lerp(x_min, x_max, t);
                    if (Math.abs(lerp(screen_min_x, screen_max_x, t)) > 1.05) continue;

                    drawBox( 
                        x - input.zoom, y_min,
                        x + input.zoom, y_max,
                        [0, 0, 0, 20]
                    );
                }
            }

            /* data lines */
            {
                /* TODO: revisit */
                for (const line of lines.values()) {
                    line.bounds.interval = INTERVAL;
                    line.bounds.x_min    = x_min;
                    line.bounds.x_max    = x_max;
                    line.bounds.ts_min   = ts_min;
                    line.bounds.ts_max   = ts_max;
                    line.bounds.y_min    = y_min;
                    line.bounds.y_max    = y_max;
                }
            }

            drawBoxWithView(
                units_view,
                x_max +         0, y_min - 40,
                x_max + RIGHT_PAD, y_max + 15,
                [255, 255, 255, 255],
                -0.1
            );

            /* ending line */
            drawBoxWithView( 
                units_view,
                (x_max + 0) - 1, y_min,
                (x_max + 0) + 1, y_max,
                [0, 0, 0, 20]
            );
        }
    }

    /* clear all */
    gl.clearColor(0.95, 0.95, 1.00, 1);
    gl.clearDepth(1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    /* enable depth */
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);

    /* geo pass */
    {
        gl.useProgram(shaders.geo.program);
        gl.enableVertexAttribArray(shaders.geo.a_pos);
        gl.enableVertexAttribArray(shaders.geo.a_color);

        gl.uniformMatrix4fv(shaders.geo.u_matrix, false, pMatrix);

        /* upload/bind geometry */

        {
            gl.bindBuffer(gl.ARRAY_BUFFER, buf.geo_v_pos);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo_pos), gl.STATIC_DRAW);
            gl.vertexAttribPointer(shaders.geo.a_pos, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, buf.geo_v_color);
            gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(geo_color), gl.STATIC_DRAW);
            gl.vertexAttribPointer(shaders.geo.a_color, 4, gl.UNSIGNED_BYTE, true, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.geo_idx);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(geo_idx), gl.STATIC_DRAW);
        }

        gl.drawElements(gl.TRIANGLES, geo_idx.length, gl.UNSIGNED_INT, 0);
    }

    /* lines pass */
    {
        for (const graph of graphs) {

            gl.useProgram(shaders.graph.program);
            gl.enableVertexAttribArray(shaders.geo.a_instance_y);

            /* find min/max */
            const { data_range_min, data_range_max } = graph.bounds;
            gl.uniform1f(shaders.graph.u_data_range_min, data_range_min);
            gl.uniform1f(shaders.graph.u_data_range_max, data_range_max);
            gl.uniformMatrix4fv(
                shaders.graph.u_matrix,
                false,
                mat4_mul(mat4_create(), pMatrix, view)
            );

            /* bind ibuf */
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.graph_idx);

            /* upload data to GPU */
            for (const line of graph.lines.values()) {

                gl.bindBuffer(gl.ARRAY_BUFFER, line.data);
                /* note that stride is half of size */
                gl.vertexAttribPointer(
                    /* loc           */ shaders.graph.a_instance_y,
                    /* size          */ 2,
                    /* datatype      */ gl.FLOAT,
                    /* normalize     */ false,
                    /* size in bytes */ 4,
                    /* offset        */ 0
                );
                gl.vertexAttribDivisor(shaders.graph.a_instance_y, 1);

                const instance_count = line.data_count;
                const sg = shaders.graph;
                const aspect_ratio = gl.canvas.clientWidth / gl.canvas.clientHeight;
                gl. uniform2f(sg.u_canvas_size,  gl.canvas.clientWidth, gl.canvas.clientHeight);
                gl. uniform1f(sg.u_interval,     line.bounds.interval);
                gl. uniform1f(sg.u_x_min,        line.bounds.x_min   );
                gl. uniform1f(sg.u_x_max,        line.bounds.x_max   );
                gl. uniform1f(sg.u_y_min,        line.bounds.y_min   );
                gl. uniform1f(sg.u_y_max,        line.bounds.y_max   );
                gl. uniform1f(sg.u_ts_min,       line.bounds.ts_min  );
                gl. uniform1f(sg.u_ts_max,       line.bounds.ts_max  );
                gl. uniform1f(sg.u_point_count,  instance_count      );
                gl. uniform1f(sg.u_aspect_ratio, aspect_ratio        );
                gl. uniform1f(sg.u_thickness,    0.005               );
                gl.uniform4fv(sg.u_color,        line.color          );

                gl.drawElementsInstanced(
                    gl.TRIANGLES,
                    6,
                    gl.UNSIGNED_SHORT,
                    0,
                    instance_count
                );
            }
        }
    }
    /* kind of scary and weird that this is necessary */
    gl.vertexAttribDivisor(shaders.graph.a_instance_y, 0);

    /* text pass */
    {
        gl.useProgram(shaders.text.program);

        /* set up premultiplied alpha */
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
        gl.enable(gl.BLEND);

        /* bind uniforms */
        {
            gl.uniformMatrix4fv(shaders.text.u_matrix, false, pMatrix);

            gl.uniform4fv(shaders.text.u_color, [0, 0, 0, 1]);
            gl.uniform1f(shaders.text.u_buffer, 0.75);
            const gamma = 2;
            gl.uniform1f(shaders.text.u_gamma, gamma * 1.4142 / fontscale);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(shaders.text.u_texture, 0);
        }

        /* bind text geometry */
        {
            gl.bindBuffer(gl.ARRAY_BUFFER, buf.text_v_pos);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(text_pos), gl.STATIC_DRAW);
            gl.vertexAttribPointer(shaders.text.a_pos, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, buf.text_v_uv);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(text_uv), gl.STATIC_DRAW);
            gl.vertexAttribPointer(shaders.text.a_texcoord, 2, gl.FLOAT, false, 0, 0);
        }

        gl.drawArrays(gl.TRIANGLES, 0, text_pos.length / 2);
    }
})

function lerp(v0, v1, t) { return (1 - t) * v0 + t * v1; }
function inv_lerp(min, max, p) { return (p - min) / (max - min); }
function remap(to_min, to_max, val, from_min, from_max) { return to_min + (val - from_min) * (to_max - to_min) / (from_max - from_min); }
function mat4_create() {
    let out = new Float32Array(16);
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
}
function mat4_ortho(out, left, right, bottom, top, near, far) {
    let lr = 1 / (left - right);
    let bt = 1 / (bottom - top);
    let nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
}
function mat4_mul(out, a, b) {
    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    /* Cache only the current line of the second matrix */
    let b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}
function mat4_transform_vec4(out, a, m) {
    let x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
}

function updateSDF() {
    const chars = ' abcdefghijklmnopqrstuvwxyzZABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()1234567890<,>./?;:\'"\\|{}[]Â°';
    const fontCanvas = document.createElement('canvas');
    fontCanvas.width = fontCanvas.height = 512
    const ctx = fontCanvas.getContext('2d');

    const TinySDF = (() => {
        const INF = 1e20;

        class TinySDF {
            constructor({
                fontSize = 24,
                buffer = 3,
                radius = 8,
                cutoff = 0.25,
                fontFamily = 'sans-serif',
                fontWeight = 'normal',
                fontStyle = 'normal'
            } = {}) {
                this.buffer = buffer;
                this.cutoff = cutoff;
                this.radius = radius;

                // make the canvas size big enough to both have the specified buffer around the glyph
                // for "halo", and account for some glyphs possibly being larger than their font size
                const size = this.size = fontSize + buffer * 4;

                const canvas = this._createCanvas(size);
                const ctx = this.ctx = canvas.getContext('2d', {willReadFrequently: true});
                ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;

                ctx.textBaseline = 'alphabetic';
                ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment
                ctx.fillStyle = 'black';

                // temporary arrays for the distance transform
                this.gridOuter = new Float64Array(size * size);
                this.gridInner = new Float64Array(size * size);
                this.f = new Float64Array(size);
                this.z = new Float64Array(size + 1);
                this.v = new Uint16Array(size);
            }

            _createCanvas(size) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = size;
                return canvas;
            }

            draw(char) {
                const {
                    width: glyphAdvance,
                    actualBoundingBoxAscent,
                    actualBoundingBoxDescent,
                    actualBoundingBoxLeft,
                    actualBoundingBoxRight
                } = this.ctx.measureText(char);

                // The integer/pixel part of the top alignment is encoded in metrics.glyphTop
                // The remainder is implicitly encoded in the rasterization
                const glyphTop = Math.ceil(actualBoundingBoxAscent);
                const glyphLeft = 0;

                // If the glyph overflows the canvas size, it will be clipped at the bottom/right
                const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
                const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));

                const width = glyphWidth + 2 * this.buffer;
                const height = glyphHeight + 2 * this.buffer;

                const len = Math.max(width * height, 0);
                const data = new Uint8ClampedArray(len);
                const glyph = {data, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance};
                if (glyphWidth === 0 || glyphHeight === 0) return glyph;

                const {ctx, buffer, gridInner, gridOuter} = this;
                ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);
                ctx.fillText(char, buffer, buffer + glyphTop);
                const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);

                // Initialize grids outside the glyph range to alpha 0
                gridOuter.fill(INF, 0, len);
                gridInner.fill(0, 0, len);

                for (let y = 0; y < glyphHeight; y++) {
                    for (let x = 0; x < glyphWidth; x++) {
                        const a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value
                        if (a === 0) continue; // empty pixels

                        const j = (y + buffer) * width + x + buffer;

                        if (a === 1) { // fully drawn pixels
                            gridOuter[j] = 0;
                            gridInner[j] = INF;

                        } else { // aliased pixels
                            const d = 0.5 - a;
                            gridOuter[j] = d > 0 ? d * d : 0;
                            gridInner[j] = d < 0 ? d * d : 0;
                        }
                    }
                }

                edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
                edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);

                for (let i = 0; i < len; i++) {
                    const d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
                    data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));
                }

                return glyph;
            }
        }

        // 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf
        function edt(data, x0, y0, width, height, gridSize, f, v, z) {
            for (let x = x0; x < x0 + width; x++) edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);
            for (let y = y0; y < y0 + height; y++) edt1d(data, y * gridSize + x0, 1, width, f, v, z);
        }

        // 1D squared distance transform
        function edt1d(grid, offset, stride, length, f, v, z) {
            v[0] = 0;
            z[0] = -INF;
            z[1] = INF;
            f[0] = grid[offset];

            for (let q = 1, k = 0, s = 0; q < length; q++) {
                f[q] = grid[offset + q * stride];
                const q2 = q * q;
                do {
                    const r = v[k];
                    s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;
                } while (s <= z[k] && --k > -1);

                k++;
                v[k] = q;
                z[k] = s;
                z[k + 1] = INF;
            }

            for (let q = 0, k = 0; q < length; q++) {
                while (z[k + 1] < q) k++;
                const r = v[k];
                const qr = q - r;
                grid[offset + q * stride] = f[r] + qr * qr;
            }
        }

        return TinySDF
    })()

    {
        // Convert alpha-only to RGBA so we can use `putImageData` for building the composite bitmap
        function makeRGBAImageData(alphaChannel, width, height) {
            const imageData = ctx.createImageData(width, height);
            for (let i = 0; i < alphaChannel.length; i++) {
                imageData.data[4 * i + 0] = alphaChannel[i];
                imageData.data[4 * i + 1] = alphaChannel[i];
                imageData.data[4 * i + 2] = alphaChannel[i];
                imageData.data[4 * i + 3] = 255;
            }
            return imageData;
        }

        const charWidths = Array.from({ length: chars.length }, _ => 0);

        ctx.clearRect(0, 0, fontCanvas.width, fontCanvas.height);
        const fontSize = +SDF_FONT_SIZE;
        const fontWeight = +SDF_FONT_SIZE;
        const fontStyle = 'normal';
        const buffer = Math.ceil(fontSize / 8);
        const radius = Math.ceil(fontSize / 3);
        const sdf = new TinySDF({fontSize, buffer, radius, fontWeight, fontStyle});
        const size = fontSize + buffer * 2;

        const now = performance.now();
        let i = 0;
        for (let y = 0; y + size <= fontCanvas.height && i < chars.length; y += size) {
            for (let x = 0; x + size <= fontCanvas.width && i < chars.length; x += size) {
                const glyph = sdf.draw(chars[i]);
                const {data, width, height} = glyph;
                delete glyph.data;
                sdfs[chars[i]] = { x, y, glyph };
                ctx.putImageData(makeRGBAImageData(data, width, height), x, y);
                i++;
            }
        }
        console.log(`${i} characters (${fontSize}px, font-weight: ${fontWeight} with ${buffer}px buffer) rendered in ${Math.round(performance.now() - now)}ms.`)

        return ctx.getImageData(0, 0, fontCanvas.width, fontCanvas.height)
    }
}

function hsl_to_rgb(arr) {
    function hue_to_rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    const h = arr[0];
    const s = arr[1];
    const l = arr[2];

    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue_to_rgb(p, q, h + 1/3);
        g = hue_to_rgb(p, q, h);
        b = hue_to_rgb(p, q, h - 1/3);
    }

    arr[0] = r;
    arr[1] = g;
    arr[2] = b;
    return arr;
}
    </script>
  </body>
</html>
