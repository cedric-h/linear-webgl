<!-- vim: sw=4 ts=4 expandtab smartindent ft=javascript
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ü•∑</text></svg>">
    <title>postmodern gamedev shitpost</title>
    <style> document, body { margin: 0px; padding: 0px; overflow: hidden; } </style>
  </head>

  <body>
    <canvas id="glcanvas"></canvas>
    <script>
"use strict";

const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl2', {antialias: true});
const gl_anisotropy =
  gl.getExtension("EXT_texture_filter_anisotropic") ||
  gl.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
  gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
if (!gl) { alert('Failed to initialize WebGL'); }

(window.onresize = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    /* account for e.g. high-retina macbook screens */
    if (window.devicePixelRatio > 1) {
        canvas.style.width = `${canvas.width}px`;
        canvas.style.height = `${canvas.height}px`;
        canvas.width *= window.devicePixelRatio;
        canvas.height *= window.devicePixelRatio;
    }

    gl.viewport(
        0,
        0,
        canvas.width,
        canvas.height
    );
})();

const SHADER_FLAG_NONE     = 0;
const SHADER_FLAG_GREENIFY = 1;
const SHADER_FLAG_GREYIFY  = 2;
const SHADER_FLAG_BROWNIFY = 3;

const DEBUG = 0;

const LAYER_PLAYER  = 1;
const LAYER_ENEMIES = 2;


/* used especially in the rendering functions */
const AXIS_FLAT   = 0;
const AXIS_SPRITE = 1; /* up, but tilted back slightly to face camera */


const ATLAS_CHARS = [];
const ATLAS_NINJA    = (ATLAS_CHARS.push('ü•∑'), ATLAS_CHARS.length - 1);
const ATLAS_ROCK     = (ATLAS_CHARS.push('ü™®'), ATLAS_CHARS.length - 1);
const ATLAS_BLOOD    = (ATLAS_CHARS.push('ü©∏'), ATLAS_CHARS.length - 1);
const ATLAS_MOON     = (ATLAS_CHARS.push('üåï'), ATLAS_CHARS.length - 1);
const ATLAS_HOLE     = (ATLAS_CHARS.push('üï≥Ô∏è'), ATLAS_CHARS.length - 1);
const ATLAS_ARW_DOWN = (ATLAS_CHARS.push('‚¨áÔ∏è'), ATLAS_CHARS.length - 1);
const ATLAS_BAMBOO   = (ATLAS_CHARS.push('üéã'), ATLAS_CHARS.length - 1);
const ATLAS_TREE     = (ATLAS_CHARS.push('üå≥'), ATLAS_CHARS.length - 1);
const ATLAS_MOAI     = (ATLAS_CHARS.push('üóø'), ATLAS_CHARS.length - 1);
const ATLAS_BONE     = (ATLAS_CHARS.push('ü¶¥'), ATLAS_CHARS.length - 1);
const ATLAS_KNIFE    = (ATLAS_CHARS.push('üî™'), ATLAS_CHARS.length - 1);
const ATLAS_CARROT   = (ATLAS_CHARS.push('ü•ï'), ATLAS_CHARS.length - 1);
const ATLAS_THREAD   = (ATLAS_CHARS.push('üßµ'), ATLAS_CHARS.length - 1);
const ATLAS_DOOR     = (ATLAS_CHARS.push('üö™'), ATLAS_CHARS.length - 1);
const ATLAS_CANE     = (ATLAS_CHARS.push('ü¶Ø'), ATLAS_CHARS.length - 1);


const ATLAS_SIZE = Math.ceil(Math.sqrt(ATLAS_CHARS.length)); /* in emoji */
const EMOJI_SIZE = 1 << 8;

const CAMERA_CONTROLS_ACTIVE = false && (!DEBUG);
const LAST_ACTION_KEY   = 0;
const LAST_ACTION_MOUSE = 1;

const DEFAULT_PITCH =  Math.PI*0.50;
const DEFAULT_YAW   = -Math.PI*0.25;
const DEFAULT_DAMPED_CAM_FACTOR = 0.95;
const DEFAULT_ZOOM  = 25;
let input = {
    /* mousewheel input is damped here before ending up in "zoom" */ 
    scroll: 0,
    /* drags are damped here before ending up in pitch/yaw (lmb) or cam_pivot (rmb) */
    dampedEvent: { button: 0, movementX: 0, movementY: 0 },
    keysdown:    new Map(),
    last_action: LAST_ACTION_MOUSE,

    zoom: DEFAULT_ZOOM,

    pitch: DEFAULT_PITCH,
    yaw:   DEFAULT_YAW,
    eye: [0, 0, 0, 1],

    /* protip:
     * if you want to keep animations fluid and retain the ability to
     * switch between cutscenes, avoid reading from cam_pivot, only write into it.
     * treat it as an output which will be the position of the camera for this frame. */
    cam_pivot_x: 0,
    cam_pivot_y: 0,
    cam_pivot_z: 0,

    lmb_down: false, /* lmb =  left mouse button */
    rmb_down: false, /* rmb = right mouse button */
    mouse_x:  0,
    mouse_y:  0,

    vp        : mat4_create(),
    vp_inv    : mat4_create(),
    vp_skydome: mat4_create(),

    /* writes to the vp matrices  */
    camera_construct() {
        const FIELD_OF_VIEW = 50 / 180 * Math.PI;
        const ar = window.innerWidth / window.innerHeight;
        const projection = mat4_perspective(mat4_create(), FIELD_OF_VIEW, ar, 0.01, 1000.0);

        const view_skydome = mat4_create();
        {
            const view = view_skydome;

            const eye = [70, 0, 0, 1];
            {
                mat4_from_z_rotation(mat4_scratch, input.pitch + Math.PI*0.5);
                mat4_mul(view, view, mat4_scratch);

                // mat4_from_y_rotation(scratch, input.yaw + Math.PI*0.12);
                mat4_from_y_rotation(mat4_scratch, input.yaw);
                mat4_mul(view, view, mat4_scratch);

                mat4_transform_vec4(eye, eye, view);
            }

            mat4_target_to(view, eye, [0, 0, 1], [0, 0, 1]);
            mat4_invert(view, view);
        }


        const view = mat4_create();
        {
            const eye = input.eye = [input.zoom, 0, 0, 1];
            {
                mat4_from_z_rotation(mat4_scratch, input.pitch);
                mat4_mul(view, view, mat4_scratch);

                mat4_from_y_rotation(mat4_scratch, input.yaw);
                mat4_mul(view, view, mat4_scratch);

                mat4_transform_vec4(eye, eye, view);
            }

            eye[0] += input.cam_pivot_x;
            eye[1] += input.cam_pivot_y;
            eye[2] += input.cam_pivot_z;
            mat4_target_to(
                view,
                eye,
                [input.cam_pivot_x, input.cam_pivot_y, input.cam_pivot_z],
                [                0,                 0,                 1]
            );
            mat4_invert(view, view);
        }

        mat4_mul(
            input.vp_skydome,
            mat4_perspective(mat4_create(), FIELD_OF_VIEW, ar, 0.01, 10000.0),
            view_skydome
        );
        mat4_mul(input.vp, projection, view);
        mat4_invert(input.vp_inv, input.vp);
    },

    camera_controls() {
        const ev = input.dampedEvent;

        /* based on the assumption that if you're zoomed in more,
         * you're doing finer-detailed work and want more precise movements. */
        const zoom_fudge = 2;// Math.sqrt(input.zoom/10.0)*2.0;

        if (ev.button == 0) {
            input.pitch -= ev.movementX * 0.0005 * zoom_fudge;
            input.yaw   -= ev.movementY * 0.0005 * zoom_fudge;
            input.yaw = Math.max(-Math.PI*0.5 + 0.01, Math.min(Math.PI*0.5 - 0.01, input.yaw));
        }
        if (ev.button == 2) {
            const unit = [0, -ev.movementX*0.00075*zoom_fudge, ev.movementY*0.00075*zoom_fudge, 1];
            {
                const view    = mat4_create();
                const mat4_scratch = mat4_create();

                mat4_from_z_rotation(mat4_scratch, input.pitch);
                mat4_mul(view, view, mat4_scratch);

                mat4_from_y_rotation(mat4_scratch, input.yaw);
                mat4_mul(view, view, mat4_scratch);

                mat4_transform_vec4(unit, unit, view);
            }

            input.cam_pivot_x += unit[0] * input.zoom/20;
            input.cam_pivot_y += unit[1] * input.zoom/20;
            input.cam_pivot_z += unit[2] * input.zoom/20;
        }

        ev.movementX *= Math.pow(1 - 0.17, Math.round(target_fps)*delta_time);
        ev.movementY *= Math.pow(1 - 0.17, Math.round(target_fps)*delta_time);

        {
            const t = Math.cbrt(Math.abs(input.scroll)) * Math.sign(input.scroll);

            input.zoom += 0.005*t*input.zoom;
            input.scroll *= Math.pow(1 - 0.5, Math.round(target_fps)*delta_time);
            input.zoom = Math.min(200, input.zoom);
        }
    },

    mouse_to_ground(height = 0, vec=[0, 0, 0, 1]) {
        const eye = input.eye;
        vec[0] = -1 + (input.mouse_x / canvas.width )*2;
        vec[1] = +1 - (input.mouse_y / canvas.height)*2;
        vec[2] = 1;
        vec[3] = 1;

        mat4_transform_vec4(vec, vec, input.vp_inv);
        vec[0] /= vec[3];
        vec[1] /= vec[3];
        vec[2] /= vec[3];

        ray_hit_plane(
            vec,
                     eye[0],          eye[1],          eye[2], /* ray origin */
            vec[0] - eye[0], vec[1] - eye[1], vec[2] - eye[2], /* ray vector */

            0, 0, height, /* plane origin */
            0, 0,      1  /* plane vector */
        );

        return vec;
    }
};

/* key handling */
{
    function set_key(key, down) {
        input.last_action = LAST_ACTION_KEY;
        input.keysdown.set(key, down);
    }
    window.addEventListener('keydown', e => set_key(e.key, true ));
    window.addEventListener('keyup',   e => set_key(e.key, false));
}

/* mouse controls */
{
    const opts = { passive: false };

    window.addEventListener('wheel', e => {
        e.preventDefault();

        if (input.mouse_down) return;
        input.scroll += e.deltaY;
    }, opts);
    window.addEventListener('mousedown', ev => {
        ev.preventDefault();

        if (CAMERA_CONTROLS_ACTIVE) input.last_action = LAST_ACTION_MOUSE;
        input.dampedEvent.button = ev.button ? 2 : 0;

        if (ev.button == 0) input.lmb_down = true;
        if (ev.button == 2) input.rmb_down = true;
    }, opts);
    window.addEventListener('mousemove', ev => {
        ev.preventDefault();

        if (input.lmb_down || input.rmb_down) {
            input.dampedEvent.movementX += ev.movementX;
            input.dampedEvent.movementY += ev.movementY;
        }

        input.mouse_x = ev.offsetX*window.devicePixelRatio;
        input.mouse_y = ev.offsetY*window.devicePixelRatio;
    }, opts);
    window.addEventListener("contextmenu", ev => {
        ev.preventDefault();
    }, opts);
    window.addEventListener('mouseup', ev => {
        ev.preventDefault();

        if (ev.button == 0) input.lmb_down = false;
        if (ev.button == 2) input.rmb_down = false;
    }, opts);
}

/* touch controls */
{
    const opts = { passive: false };

    let touch_x = 0;
    let touch_y = 0;
    window.addEventListener("touchstart", ev => {
        ev.preventDefault();

        touch_x = ev.changedTouches[0].clientX;
        touch_y = ev.changedTouches[0].clientY;

        input.lmb_down = true;
    }, opts);

    window.addEventListener("touchmove", ev => {
        ev.preventDefault();
        input.dampedEvent.button = 0;

        input.dampedEvent.movementX += ev.changedTouches[0].clientX - touch_x;
        input.dampedEvent.movementY += ev.changedTouches[0].clientY - touch_y;

        touch_x = ev.changedTouches[0].clientX;
        touch_y = ev.changedTouches[0].clientY;
    }, opts);

    window.addEventListener("touchend", ev => {
        ev.preventDefault();

        input.lmb_down = false;
    }, opts);
}

/* GPU geometry buffers */
const buf = {
    geo_v_pos: gl.createBuffer(),
    geo_v_uv:  gl.createBuffer(),
    geo_i:     gl.createBuffer(),

    skydome_v_pos: gl.createBuffer(),
    skydome_v_uv:  gl.createBuffer(),
    skydome_i:     gl.createBuffer(),
};

let shaders;
/* compile shaders */
{
    const vs_skydome = 
        'attribute vec3 a_pos;' +
        'attribute vec2 a_uv;' +

        'uniform mat4 u_matrix;' +

        'varying vec2 v_uv;' +

        'void main() {' +
            'gl_Position = u_matrix * vec4(a_pos.xyz, 1);' +
            'v_uv = a_uv;' +
        '}';

    const fs_skydome = 
        'precision mediump float;' +

        'uniform sampler2D u_texture;' +

        'varying vec2 v_uv;' +

        'void main() {' +
            'gl_FragColor = 0.4 * texture2D(u_texture, v_uv);' +
        '}';

    const vs_geo = `
        uniform mat4 u_matrix;

        attribute vec3 a_pos;
        attribute vec4 a_uv;

        varying vec4 v_uv;

        void main() {
            gl_Position = u_matrix * vec4(a_pos.xyz, 1);
            v_uv = a_uv;
        }`;

    const fs_geo = `
        precision mediump float;

        uniform sampler2D u_texture;

        varying vec4 v_uv;

        void main() {
            vec4 color = vec4(0);
            if (v_uv.x < 0.0) {
                color = texture2D(u_texture, abs(v_uv.xy));
                color *= v_uv.w;
                
                if (abs(v_uv.z - ${SHADER_FLAG_GREENIFY.toFixed(2)}) < 0.2) {
                    color.xyz /= color.w;
                    float grey = 0.21 * color.r + 0.71 * color.g + 0.07 * color.b;
                    color.xyz = 0.8*grey*vec3(0.58, 0.75, 0.35);
                    color.xyz *= color.w;
                }

                if (abs(v_uv.z - ${SHADER_FLAG_GREYIFY.toFixed(2)}) < 0.2) {
                    color.xyz /= color.w;
                    float grey = 0.21 * color.r + 0.71 * color.g + 0.07 * color.b;
                    color.xyz = 0.4*vec3(grey);
                    color.xyz *= color.w;
                }
                if (abs(v_uv.z - ${SHADER_FLAG_BROWNIFY.toFixed(2)}) < 0.2) {
                    color.xyz /= color.w;
                    float grey = 0.21 * color.r + 0.71 * color.g + 0.07 * color.b;
                    color.xyz = (0.5 + 0.5*grey)*vec3(0.51, 0.41, 0.32)*1.2;
                    color.xyz *= color.w;
                }
                
                if (color.w == 0.0) discard;
            } else {
                color = v_uv;
            }
            // gl_FragColor = vec4(vec3(0.4), 1.0)*color;
            gl_FragColor = color;
        }`;

    function createProgram(gl, vertexSource, fragmentSource) {
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        const program = gl.createProgram();

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);

        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error(gl.getProgramInfoLog(program));
        }

        const wrapper = {program};

        const numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (let i = 0; i < numAttributes; i++) {
            const attribute = gl.getActiveAttrib(program, i);
            wrapper[attribute.name] = gl.getAttribLocation(program, attribute.name);
        }
        const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < numUniforms; i++) {
            const uniform = gl.getActiveUniform(program, i);
            wrapper[uniform.name] = gl.getUniformLocation(program, uniform.name);
        }

        return wrapper;
    }


    shaders = {
        geo:     createProgram(gl, vs_geo    , fs_geo    ),
        skydome: createProgram(gl, vs_skydome, fs_skydome),
    }
}

/* creating spritesheet, uploading to GPU */
const MOON_NUDGE_X = navigator.platform != "MacIntel" ? -0.085 : 0;
const MOON_NUDGE_Y = navigator.platform != "MacIntel" ? -0.005 : 0;
let atlas = gl.createTexture();
{
    const canvas = document.createElement("canvas");

    canvas.width = canvas.height = ATLAS_SIZE * EMOJI_SIZE;

    const ctx = canvas.getContext("2d");

    let X_FUDGE = -0.1*EMOJI_SIZE;
    if (navigator.platform.indexOf("Mac") === 0 || navigator.platform === "iPhone") X_FUDGE = 0;

    {
        const PAD = EMOJI_SIZE*0.1;
        ctx.font = (EMOJI_SIZE - PAD*2) + 'px sans-serif';

        let i = 0;
        for (const char of ATLAS_CHARS) {
            const x = (           i % ATLAS_SIZE ) * EMOJI_SIZE;
            const y = (Math.floor(i / ATLAS_SIZE)) * EMOJI_SIZE;

            ctx.fillText(
                char,
                x + PAD + X_FUDGE,
                y + EMOJI_SIZE - PAD*2
            );

            i++;
        }
    }

    gl.bindTexture(gl.TEXTURE_2D, atlas);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
    gl.texImage2D(
        /* target         */ gl.TEXTURE_2D,
        /* level          */ 0,
        /* internalformat */ gl.RGBA,
        /* width          */ canvas.width,
        /* height         */ canvas.height,
        /* border,        */ 0,
        /* format,        */ gl.RGBA,
        /* type,          */ gl.UNSIGNED_BYTE,
        /* data           */ canvas
    );
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    if (gl_anisotropy) {
        const max = gl.getParameter(gl_anisotropy.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        gl.texParameterf(gl.TEXTURE_2D, gl_anisotropy.TEXTURE_MAX_ANISOTROPY_EXT, max);
    }
}

/* uploading skydome texture to GPU
 * TODO: blur it */
let tex_skydome = gl.createTexture();
(async () => {
    const img = new Image();
    img.src = 'garden_hdri.jpg';
    await new Promise(res => img.onload = res);

    const canvas = document.createElement("canvas");
    canvas.width  = img.width;
    canvas.height = img.height;
    canvas.getContext("2d").drawImage(img, 0, 0);

    gl.bindTexture(gl.TEXTURE_2D, tex_skydome);
    gl.texImage2D(
        /* target         */ gl.TEXTURE_2D,
        /* level          */ 0,
        /* internalformat */ gl.RGBA,
        /* width          */ canvas.width,
        /* height         */ canvas.height,
        /* border,        */ 0,
        /* format,        */ gl.RGBA,
        /* type,          */ gl.UNSIGNED_BYTE,
        /* data           */ canvas
    );
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
})();

/* generate skydome geometry */
{
    const geo_idx = [];
    const geo_pos = [];
    const geo_uv  = [];
    {
        const WIDTH_SEGMENTS  = 1 << 6;
        const HEIGHT_SEGMENTS = 1 << 5;
        const RADIUS          = 100;

        const grid = [];
        let index = 0;
        for (let iy = 0; iy <= HEIGHT_SEGMENTS; iy++) {
            const v = iy / HEIGHT_SEGMENTS;

            /* poles */
            let u_offset = 0;
            if (iy == 0              ) u_offset =   0.5 / WIDTH_SEGMENTS;
            if (iy == HEIGHT_SEGMENTS) u_offset = - 0.5 / WIDTH_SEGMENTS;

            for (let ix = 0; ix <= WIDTH_SEGMENTS; ix++) {
                const u = ix / WIDTH_SEGMENTS;

                geo_uv.push(u + u_offset, 1 - v);

                geo_pos.push(
                    RADIUS * -Math.cos(u * Math.PI*2) * Math.sin(v * Math.PI),
                    RADIUS *  Math.sin(u * Math.PI*2) * Math.sin(v * Math.PI),
                    RADIUS * -Math.cos(v * Math.PI)
                );

                grid.push(index++);
            }
        }

        for (let iy = 0; iy < HEIGHT_SEGMENTS; iy++) {
            for (let ix = 0; ix < WIDTH_SEGMENTS; ix++) {
                const a = grid[(iy    )*(WIDTH_SEGMENTS + 1) + ix + 1];
                const b = grid[(iy    )*(WIDTH_SEGMENTS + 1) + ix    ];
                const c = grid[(iy + 1)*(WIDTH_SEGMENTS + 1) + ix    ];
                const d = grid[(iy + 1)*(WIDTH_SEGMENTS + 1) + ix + 1];

                if (iy !== 0                  ) geo_idx.push(a, b, d);
                if (iy !== HEIGHT_SEGMENTS - 1) geo_idx.push(b, c, d);
            }
        }
    }

    {
        gl.bindBuffer(gl.ARRAY_BUFFER, buf.skydome_v_pos);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo_pos), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, buf.skydome_v_uv);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo_uv), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.skydome_i);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geo_idx), gl.STATIC_DRAW);
    }

    buf.skydome_i_count = geo_idx.length;
}

let target_fps = 60;
let delta_time;
let last_timestamp;

const map_util = {
    bridge: {
        PLANK_SPACING: 3.6,
        BENDYNESS    : 0.4,

        plank_points(bridge) {
            let planks_min = Math.min(bridge.path_from, bridge.path_to)-3.5;
            let planks_max = Math.max(bridge.path_from, bridge.path_to)+2.5;
            let player_t = inv_lerp(planks_min+1, planks_max-1, save.player.pos.x);
            player_t = unit_clamp(player_t);
            if (this.distance(bridge, save.player.pos) > 0.2) player_t = 0;
            let middle_t = 1 - 2*Math.abs(player_t - 0.5);

            const control0 = [planks_min - 5, 25 + 40*(0 + player_t)*middle_t];
            const control1 = [planks_max + 5, 25 + 40*(1 - player_t)*middle_t];
            const start = [planks_min, 0];
            const end   = [planks_max, 0];
            const arg = { p0: control0, p1: start, p2: end, p3: control1, alpha: this.BENDYNESS };

            return catmull_uniformly_spaced(arg, this.PLANK_SPACING);
        },

        height_at(bridge, p) {
            let planks_min = Math.min(bridge.path_from, bridge.path_to)-3.5;
            let planks_max = Math.max(bridge.path_from, bridge.path_to)+2.5;
            let player_t = inv_lerp(planks_min+1, planks_max-1, p.x);
            if (this.distance(bridge, save.player.pos) > 0.2) return 0;
            player_t = Math.min(1, Math.max(0, player_t));

            const control0 = [planks_min - 5, 5 + 30*(0 + player_t)];
            const control1 = [planks_max + 5, 5 + 30*(1 - player_t)];
            const start = [planks_min, 0];
            const end   = [planks_max, 0];
            return catmull(control0, start, end, control1, player_t, this.BENDYNESS)[1];
        },

        /* distance from point to bridge */
        distance(bridge, p) {
            let planks_min = Math.min(bridge.path_from, bridge.path_to)-3;
            let planks_max = Math.max(bridge.path_from, bridge.path_to)+3;
            return sd_segment(
                p,
                planks_min, bridge.y,
                planks_max, bridge.y
            ) - 1.5;
        },

        draw(bridge, ctx) {
            const { geo, pushImgUV, drawImg } = ctx;

            let path_min = Math.min(bridge.path_from, bridge.path_to);
            let path_max = Math.max(bridge.path_from, bridge.path_to);


            /* add poles to each end of the bridge */
            for (let x = 0; x < 2; x += 1)
                for (let y = -1; y <= 2; y += 2)
                    drawImg(
                        /* axis */ AXIS_SPRITE,
                        /* x, y */ lerp(path_min-1.5, path_max+0.5, x), 1.8*y + bridge.y,
                        /* size */ 1,
                        /* img  */ ATLAS_THREAD
                    );

            /* draw the planks */
            {
                let last;
                for (const p of this.plank_points(bridge)) {
                    if (!last) {
                        last = p;
                        continue;
                    }
                    pushImgUV(ATLAS_DOOR);

                    const size = 2.5;

                    let x0 = last[0];
                    let z0 = last[1];
                    let x1 = p   [0];
                    let z1 = p   [1];

                    /* we need to "expand" the vector that goes from x0,z0 to z1,x1 because
                     * the image doesn't fill 100% of the square. (the UVs aren't "tight") */
                    {
                        let dx = x1 - x0;
                        let dz = z1 - z0;
                        const d_len = Math.sqrt(dx*dx + dz*dz);
                        dx /= d_len;
                        dz /= d_len;

                        x0 -= dx;
                        z0 -= dz;
                        x1 += dx;
                        z1 += dz;
                    }

                    const vbuf_i = geo.pos.length / 3;
                    geo.pos.push(x0, bridge.y-size, z0 + 1.0);
                    geo.pos.push(x1, bridge.y-size, z1 + 1.0);
                    geo.pos.push(x1, bridge.y+size, z1 + 1.0);
                    geo.pos.push(x0, bridge.y+size, z0 + 1.0);
                    geo.layer.push(-1e6 - (z0 + z1));
                    geo.layer.push(-1e6 - (z0 + z1));

                    geo.idx.push(vbuf_i + 0, vbuf_i + 1, vbuf_i + 2,
                                 vbuf_i + 2, vbuf_i + 3, vbuf_i + 0);

                    last[0] = p[0];
                    last[1] = p[1];
                }
            }
        }
    },

    enemies: {
        SLIME_JUMP_SPEEDUP: 1.2,
        SLIME_JUMP_FREQ: 3,

        ENEMY: {
            TUTORIAL_NINJA: 0,
            NINJA:          1,
            ROCK:           2,
            SLIME:          3,
            MINI_MOAI:      4,
        },

        init() {
            return []
        },

        ensure_allocated(enemies, idx, spawn_x, spawn_y) {
            
            enemies[idx] ??= {
                died_timestamp: null,
                died_direction: { x: 0, y: 0 },
                next_shot_timestamp: null,
                pos: { x: spawn_x, y: spawn_y },
                vel: { x:       0, y:       0 },
                og_pos: { x: spawn_x, y: spawn_y }
            };

            /* I will later get rid of the "og_pos" concept when I abstract
             * out "circles" and have them simply move everything above them.
             *
             * However, such an improvement will only be necessary if a level requires
             * moving platforms underneath moving enemies that can leave their platforms. */
            enemies[idx].pos.x -= (enemies[idx].og_pos.x - spawn_x);
            enemies[idx].pos.y -= (enemies[idx].og_pos.y - spawn_y);
            enemies[idx].og_pos.x = spawn_x;
            enemies[idx].og_pos.y = spawn_y;

            return enemies[idx];
        },

        draw(enemies, for_enemies, { pushImgUV, pushSpriteXYZ }) {
            for_enemies((idx, kind, spawn_x, spawn_y) => {
                if (kind == this.ENEMY.MINI_MOAI) return;

                const enemy = this.ensure_allocated(enemies, idx, spawn_x, spawn_y);
                const enemy_x = enemy.pos.x;
                const enemy_y = enemy.pos.y;

                let opacity = 1;
                let push = 0;
                if (enemy.died_timestamp != null) {
                    const elapsed = last_timestamp - enemy.died_timestamp;
                    opacity = 1 - ease_out_circ(unit_clamp((elapsed - 0.1) / 0.25));
                    push = 0.5 * ease_out_circ(unit_clamp((elapsed - 0.0) / 0.2));
                }
                const push_x = push*enemy.died_direction.x;
                const push_y = push*enemy.died_direction.y;

                let sprite;
                switch (kind) {
                    case (this.ENEMY.SLIME): {
                        const SPEEDUP = this.SLIME_JUMP_SPEEDUP;
                        const FREQ    = this.SLIME_JUMP_FREQ;

                        let size_x = 1;
                        let size_y = 1;
                        size_x += 0.05*Math.sin(SPEEDUP*last_timestamp);
                        size_y += 0.05*Math.sin(SPEEDUP*last_timestamp);

                        let z = 0;

                        let jump_t = (last_timestamp * SPEEDUP) % FREQ;
                        jump_t -= 1;
                        if (jump_t > 0) {
                            const JUMP_HEIGHT = 3;

                            const CROUCH_SECS = 0.4;
                            const crouch_t = unit_clamp(jump_t / CROUCH_SECS);
                            jump_t -= CROUCH_SECS;

                            const UNCROUCH_SECS = 0.3;
                            const UNOVERCROUCH_SECS = 0.2;
                            const uncrouch_t = unit_clamp(jump_t / UNCROUCH_SECS);
                            const unovercrouch_t = unit_clamp((jump_t - UNCROUCH_SECS) / UNOVERCROUCH_SECS);

                            const UP_SECS = 0.2;
                            const up_t = unit_clamp(jump_t / UP_SECS);
                            jump_t -= UP_SECS;

                            const PAUSE_SECS = 0.15;
                            const pause_t = unit_clamp(jump_t / PAUSE_SECS);
                            jump_t -= PAUSE_SECS;

                            const DOWN_SECS = 0.3;
                            const down_t = unit_clamp(jump_t / DOWN_SECS);
                            jump_t -= DOWN_SECS;

                            const END_CROUCH_SECS = 0.2;
                            const end_crouch_t = unit_clamp((jump_t + END_CROUCH_SECS*0.1) / END_CROUCH_SECS);
                            jump_t -= END_CROUCH_SECS;

                            z += JUMP_HEIGHT * (up_t   + 0.1*pause_t);
                            z -= JUMP_HEIGHT * (down_t + 0.1*pause_t);

                            let crouch = 1 - crouch_t;
                            crouch += uncrouch_t     * (1.7 + 0);
                            crouch -= unovercrouch_t * (1.7 - 1);
                            crouch -= 1 - 2*Math.abs(0.5 - end_crouch_t);
                            size_y *= 0.6 + 0.4*crouch;
                            size_x *= 1.0 + 0.4*(1 - crouch);
                        }

                        sprite = ATLAS_ROCK;
                        pushImgUV(sprite, 0, opacity);
                        pushSpriteXYZ(enemy_x + push_x, enemy_y + push_y, z, size_x, size_y);

                        return; /* <-- this says "return" not "break" */
                    }; break;

                    case (this.ENEMY.SLIME):
                    case (this.ENEMY.ROCK): {
                        sprite = ATLAS_ROCK;
                    } break;

                    case (this.ENEMY.NINJA):
                    case (this.ENEMY.TUTORIAL_NINJA): {
                        sprite = ATLAS_NINJA;
                    } break;
                }

                pushImgUV(sprite, 0, opacity);
                pushSpriteXYZ(enemy_x + push_x, enemy_y + push_y, 0, 1);
            });
        },

        for_collisions(enemies, for_enemies, pos, radius, callback) {
            for_enemies((idx, kind, x, y) => {
                if (kind != this.ENEMY.SLIME) return;
                if (this.is_dead(enemies, idx, x, y)) return;

                const enemy = this.ensure_allocated(enemies, idx, x, y);

                const dx = enemy.pos.x - pos.x;
                const dy = enemy.pos.y - pos.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const hit = (dist < radius);

                if (hit && callback(enemy, idx, kind, x, y)) {
                    enemy.vel.x += (dx / dist) * 8;
                    enemy.vel.y += (dy / dist) * 8;
                }
            });
        },

        update(enemies, for_enemies) {
            /* note: for moving enemies, x & y here are just "spawn pos" */
            for_enemies((idx, kind, x, y) => {
                const enemy = this.ensure_allocated(enemies, idx, x, y);

                /* dead guys don't get updates (sorry sir) */
                if (enemy.died_timestamp != null) return;

                /* shoots */
                do {
                    if (kind == this.ENEMY.ROCK) continue;
                    if (kind == this.ENEMY.SLIME) continue;

                    if (last_timestamp < enemy.next_shot_timestamp) continue;
                    enemy.next_shot_timestamp = last_timestamp + 1;

                    const dx = save.player.pos.x - enemy.pos.x;
                    const dy = save.player.pos.y - enemy.pos.y;
                    const angle = Math.atan2(dy, dx);
                    const dir = { x: 0, y: 0 };

                    if (kind == this.ENEMY.TUTORIAL_NINJA)
                        /* using "sign" instead of "sin" here makes them slightly bad
                         * at aiming -- good for tutorial */
                        dir.x = Math.cos(angle), dir.y = Math.sign(angle);
                    else
                        dir.x = Math.cos(angle), dir.y = Math.sin(angle);

                    save.bullets.push({
                        layer: LAYER_PLAYER,
                        z: 1,
                        pos: { x: enemy.pos.x, y: enemy.pos.y },
                        dir: dir,
                        range: 25,
                        speed: 7,
                        sprite: ATLAS_KNIFE
                    });
                } while (false);

                /* getting hit by bullets */
                {
                    /* hitcircle radius */
                    let size;
                    switch (kind) {
                        case (this.ENEMY.SLIME):
                        case (this.ENEMY.ROCK): {
                            size = 1.2;
                        } break;

                        case (this.ENEMY.NINJA):
                        case (this.ENEMY.TUTORIAL_NINJA): {
                            size = 0.95;
                        } break;
                    }

                    const pos = { x: enemy.pos.x, y: enemy.pos.y };
                    save.bullet.for_collisions(
                        save.bullets,
                        LAYER_ENEMIES,
                        pos,
                        size,
                        bullet => {
                            const direction = Math.atan2(bullet.dir.y, bullet.dir.x);
                            
                            switch (kind) {
                                case (this.ENEMY.SLIME):
                                case (this.ENEMY.ROCK): {
                                    save.particle.spurt(ATLAS_ROCK, save.particles, direction, pos, 1);
                                } break;

                                case (this.ENEMY.NINJA):
                                case (this.ENEMY.TUTORIAL_NINJA): {
                                    save.particle.blood(save.particles, direction, pos, 1);
                                } break;
                            }

                            enemy.died_timestamp   = last_timestamp;
                            enemy.died_direction.x = bullet.dir.x;
                            enemy.died_direction.y = bullet.dir.y;
                            return true;
                        }
                    );
                }

                /* movement */
                do {
                    if (kind != this.ENEMY.SLIME) continue;

                    /* tentative next position; will be constrained by terrain before application */
                    let p_x = enemy.pos.x;
                    let p_y = enemy.pos.y;

                    /* collision with other slimes */
                    this.for_collisions(enemies, for_enemies, enemy.pos, 1.15, (other, other_idx) => {
                        if (other_idx == idx) return;

                        let sum_vel = Math.sqrt(other.vel.x*other.vel.x + other.vel.y*other.vel.y) +
                                      Math.sqrt(enemy.vel.x*enemy.vel.x + enemy.vel.y*enemy.vel.y) ;
                        sum_vel = 0.7 + 0.3*unit_clamp(sum_vel * 3);

                        const dx = other.pos.x - enemy.pos.x;
                        const dy = other.pos.y - enemy.pos.y;
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        enemy.vel.x -= (dx / dist) * 8 * sum_vel;
                        enemy.vel.y -= (dy / dist) * 8 * sum_vel;
                    });

                    /* velocity */
                    {
                        /* add velocity */
                        p_x += enemy.vel.x*delta_time;
                        p_y += enemy.vel.y*delta_time;

                        /* multiplicative drag to velocity */
                        {
                            const fraction_remaining_after_one_second = 0.01;
                            const new_vel_x = enemy.vel.x * Math.pow(fraction_remaining_after_one_second, delta_time);
                            const new_vel_y = enemy.vel.y * Math.pow(fraction_remaining_after_one_second, delta_time);

                            p_x += (new_vel_x - enemy.vel.x) / Math.log(fraction_remaining_after_one_second);
                            p_y += (new_vel_y - enemy.vel.y) / Math.log(fraction_remaining_after_one_second);

                            enemy.vel.x = new_vel_x;
                            enemy.vel.y = new_vel_y;
                        }
                    }

                    /* slime movement */
                    do {
                        const SPEEDUP = this.SLIME_JUMP_SPEEDUP;
                        const FREQ    = this.SLIME_JUMP_FREQ;
                        let jump_t = (last_timestamp * SPEEDUP) % FREQ;
                        const move = (jump_t < 2.05) && (jump_t > 1.4);
                        if (!move) continue;

                        /* how to synchronize this with the jumping? */
                        let dx = save.player.pos.x - enemy.pos.x;
                        let dy = save.player.pos.y - enemy.pos.y;
                        const dist_to_player = Math.sqrt(dx*dx + dy*dy);
                        if (dist_to_player > 0) dx /= dist_to_player;
                        if (dist_to_player > 0) dy /= dist_to_player;

                        const speed = 6;
                        p_x += dx * Math.min(dist_to_player, speed * delta_time);
                        p_y += dy * Math.min(dist_to_player, speed * delta_time);
                    } while (false);

                    /* modified version of this code in the character controller */
                    {
                        let next_p_x = enemy.pos.x;
                        let next_p_y = enemy.pos.y;
                        const axes = [{ x: enemy.pos.x, y: p_y }, { x: p_x, y: enemy.pos.y }];
                        for (let i = 0; i < axes.length; i++) {
                            const o = axes[i];

                            /* how far you're trying to go */
                            let moved_dist = Math.sqrt((enemy.pos.x - o.x)*(enemy.pos.x - o.x) +
                                                       (enemy.pos.y - o.y)*(enemy.pos.y - o.y));

                            /* how far you can go w/o hitting something */
                            let max_dist = save.map().distance_at(o);

                            const min = Math.min(-max_dist, moved_dist);

                            const cut_dist = Math.abs(min - moved_dist);

                            let dx = o.x - enemy.pos.x;
                            let dy = o.y - enemy.pos.y;

                            if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
                                const d_len = Math.sqrt(dx*dx + dy*dy);
                                dx /= d_len;
                                dy /= d_len;

                                next_p_x += dx*min;
                                next_p_y += dy*min;
                            }
                        }
                        enemy.pos.x = next_p_x;
                        enemy.pos.y = next_p_y;
                    }

                } while (false);
            });
        },

        is_dead(enemies, idx, x, y) {
            const enemy = this.ensure_allocated(enemies, idx, x, y);

            return enemy.died_timestamp != null;
        },

        all_dead(enemies, for_enemies) {
            let ret = true; 

            for_enemies((idx, _, x, y) => ret &&= this.is_dead(enemies, idx, x, y));

            return ret;
        }
    },

    hole: {
        /* used to prevent infinite loops; you come out of the hole with some velocity,
         * so it should be impossible to get sucked right back in. */
        last_transition_timestamp: null,
        TRANSITION_DEBOUNCE_SECS: 1,

        /* transitions to the next map at the end; don't call this fn to block that if needed.
         * 
         * returns true if it's doing anything; observe this to prevent simultaneous cutscenes */
        leaving_cutscene(hole_transition, for_holes) {
            if (hole_transition.step_timestamp == null) return false;

            for_holes((idx, hole_x, hole_y, hole_key) => {
                if (idx != hole_transition.stepped_idx) return;

                /* incorporate the player's previous velocity a little bit */
                {
                    const fraction_remaining_after_one_second = 0.01;
                    const new_vel_x = save.player.vel.x * Math.pow(fraction_remaining_after_one_second, delta_time);
                    const new_vel_y = save.player.vel.y * Math.pow(fraction_remaining_after_one_second, delta_time);

                    save.player.pos.x += (new_vel_x - save.player.vel.x) / Math.log(fraction_remaining_after_one_second);
                    save.player.pos.y += (new_vel_y - save.player.vel.y) / Math.log(fraction_remaining_after_one_second);

                    save.player.vel.x = new_vel_x;
                    save.player.vel.y = new_vel_y;
                }

                /* we bite off bits of t and assign them to our animations */
                let t = last_timestamp - hole_transition.step_timestamp;
                let up_t, suck_t = 0;
                {
                    if (t > 0) save.cutscene_active = true;

                    t -= 0.1; /* pause before */
                    if (t < 0) save.player.damp_camera();

                    const UP_DURATION = 0.45;
                    up_t = unit_clamp(t / UP_DURATION); t -= UP_DURATION;

                    // t -= 0.05; /* pause between up and suck */

                    const SUCK_DURATION = 0.35;
                    suck_t = unit_clamp(t / SUCK_DURATION); t -= SUCK_DURATION;

                    t -= 0.75; /* pause after */
                }

                /* the animation is done, time has run over */
                if (t > 0) {
                    this.last_transition_timestamp = last_timestamp;

                    /* transition to next map */

                    input.zoom = DEFAULT_ZOOM;
                    input.cam_pivot_x = save.player.damped_cam_pivot_x;
                    input.cam_pivot_y = save.player.damped_cam_pivot_y;

                    const to_map = save.map().PLAYER_SPAWN[hole_key].map;
                    const spawn_info = save.maps[to_map].PLAYER_SPAWN[hole_key];
                    save.player.pos.x   = spawn_info.pos?.x ?? 0;
                    save.player.pos.y   = spawn_info.pos?.y ?? 0;
                    save.player.vel.x   = 3.5 * (spawn_info.dir?.x ?? 1); /* he slides into the next level */
                    save.player.vel.y   = 3.5 * (spawn_info.dir?.y ?? 1); /* he slides into the next level */
                    save.player.damped_cam_pivot_x = input.cam_pivot_x = save.player.pos.x + 5*(spawn_info.dir?.x ?? 1);
                    save.player.damped_cam_pivot_y = input.cam_pivot_y = save.player.pos.y + 5*(spawn_info.dir?.y ?? 1);
                    save.player.scale   = 1;
                    save.player.z_boost = 0;
                    save.player.opacity = 1;

                    save.bullets = [];

                    save.cutscene_active = false;
                    save.map_key = to_map;
                    hole_transition.step_timestamp = null;
                    return;
                }

                save.player.z_boost = 0;
                save.player.scale   = 1;
                input.zoom = DEFAULT_ZOOM;

                if (up_t > 0) {
                    input.zoom = lerp(input.zoom, input.zoom-2, up_t);

                    /* player -> hole */
                    /* have to damp here or store position when animation starts */
                    const damp_t = Math.pow(1 - 0.85, Math.round(target_fps)*delta_time);
                    save.player.pos.x = lerp(save.player.pos.x, hole_x, damp_t);
                    save.player.pos.y = lerp(save.player.pos.y, hole_y, damp_t);

                    /* camera -> hole */
                    const p = save.player;
                    input.cam_pivot_x   = lerp(p.damped_cam_pivot_x, hole_x, up_t);
                    input.cam_pivot_y   = lerp(p.damped_cam_pivot_y, hole_y, up_t);

                    save.player.z_boost = lerp(save.player.z_boost, 2.8, ease_out_circ(up_t));
                    save.player.scale   = lerp(  save.player.scale, 0.7, ease_out_circ(up_t));
                }

                if (suck_t > 0) {
                    input.zoom = lerp(input.zoom, input.zoom-2, suck_t);

                    save.player.scale   = lerp(   save.player.scale,    0.2, suck_t);
                    save.player.z_boost = lerp( save.player.z_boost,    0.0, suck_t);
                    save.player.opacity = lerp(                 1.0,    0.0, 1 - ease_out_circ(1 - suck_t));
                }
            });

            return true;
        },

        detect_step(hole_transition, for_holes) {
            if (this.last_transition_timestamp != null) {
                const elapsed = last_timestamp - this.last_transition_timestamp;
                if (elapsed < this.TRANSITION_DEBOUNCE_SECS) return;
            }
            for_holes((idx, hole_x, hole_y, _map) => {
                const dx = save.player.pos.x - hole_x;
                const dy = save.player.pos.y - hole_y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 1.0) {
                    hole_transition.step_timestamp = last_timestamp;
                    hole_transition.stepped_idx = idx;
                }
            });
        },

        draw(hole_transition, for_holes, { drawImg, pushImgUV, pushSpriteXYZ }) {
            for_holes((_idx, hole_x, hole_y, _map) => {

                const bob = Math.sin(5*last_timestamp);
                pushImgUV(ATLAS_ARW_DOWN, 0, 0.5 + 0.05*(1.0 - bob));
                pushSpriteXYZ(hole_x, hole_y - 0.5, 0.8 + 0.1*bob, 0.6);

                drawImg(AXIS_FLAT, hole_x, hole_y, 1, ATLAS_HOLE);
            });
        },

        for_spawn(hole, spawn_table, key, idx) {
            const pos = spawn_table[key].pos;
            hole(idx, pos.x, pos.y, key);
        }
    },

};

const MAP_ENEMY_TEST = -2;
const MAP_BASIC      = -1;
const MAP_TUTORIAL   =  0;
const MAP_CAVE       =  1;
const MAP_DRAWBRIDGE =  2;

const HOLE_TUTORIAL_TO_DRAWBRIDGE   = 1;
const HOLE_UPPER_DRAWBRIDGE_TO_CAVE = 2;
const HOLE_CAVE_TO_LOWER_DRAWBRIDGE = 3;

const save = {

    cutscene_active: false,

    player: {
        pos: { x: 0, y: 0 },
        vel: { x: 0, y: 0 },
        scale  : 1,
        z_boost: 0, /* jump! */
        opacity: 1,

        wep: DEBUG,
        last_shot_timestamp: 0,

        /* player has its own copy of this data (also found in input) so that cutscene
         * taking over doesn't have to interfere with the player controller. */
        damped_cam_pivot_x: 0,
        damped_cam_pivot_y: 0,
        damped_cam_factor: DEFAULT_DAMPED_CAM_FACTOR,

        pos_z() {
            return this.z_boost + save.map().height_at(save.player.pos);
        },

        hit(direction_x, direction_y) {
            const angle = Math.atan2(direction_y, direction_x);
            save.flinch.trigger(angle);

            save.player.vel.x += 0.18*direction_x;
            save.player.vel.y += 0.18*direction_y;
        },

        update() {
            /* radius of hitcircle */
            const size = 0.95;
            const pos = this.pos;

            const bullet_hit = (bullet) => {
                this.hit(bullet.dir.x, bullet.dir.y);
                return true;
            };
            save.bullet.for_collisions(save.bullets, LAYER_PLAYER, pos, size, bullet_hit);

            const enemies = save.map().enemies;
            const for_enemies = save.map().for_enemies?.bind(this);
            if (!enemies || !for_enemies) return;

            const enemy_hit = (enemy) => {
                const dx = pos.x - enemy.pos.x;
                const dy = pos.y - enemy.pos.y;
                const dist = Math.sqrt(dx*dx + dy*dy) || 1;

                const knockback = 15;
                this.hit(dx / dist * knockback, dy / dist * knockback);

                return true;
            }
            map_util.enemies.for_collisions(enemies, for_enemies, pos, size, enemy_hit);
        },

        draw({ pushImgUV, pushSpriteXYZ }) {
            const z = this.pos_z();
            pushImgUV(ATLAS_NINJA, 0, this.opacity);
            pushSpriteXYZ(
                save.player.pos.x,
                save.player.pos.y,
                z,
                this.scale,
            );

            if (save.player.wep) {
                /* speed is the length of velocity */
                const vl = Math.sqrt(save.player.vel.x*save.player.vel.x +
                                     save.player.vel.y*save.player.vel.y) * (!save.cutscene_active) * 0.1;
                const drag = Math.min(0.07, vl);
                const breathe = Math.sin(last_timestamp * 80 / 35.0) / 30;
                const jog = Math.sin(last_timestamp * 80 / 6.85) * Math.min(vl, 0.175);

                const wep_x = 0.55 * + breathe / 3.2 + jog * 1.5 * + drag;
                const wep_y = (breathe + jog) / 2.8 + drag * 0.5;

                //pushImgUV(ATLAS_KNIFE, 0, 1, 1, 1);
                pushImgUV(ATLAS_CARROT, 0, this.opacity, 0, 1);

                pushSpriteXYZ(
                     save.player.pos.x - (0.5 + wep_x)*this.scale,
                     save.player.pos.y + (0.1 + wep_y)*this.scale,
                     z + 0.2*this.scale,
                     0.4*this.scale,
                );
            }
        },

        controls_aiming() {
            if (!save.player.wep) return;
            if (!input.lmb_down) return;
            if ((last_timestamp - this.last_shot_timestamp) < 0.5) return;

            const mouse = input.mouse_to_ground(1);

            this.last_shot_timestamp = last_timestamp;
            const dx = mouse[0] - save.player.pos.x;
            const dy = mouse[1] - save.player.pos.y;
            const angle = Math.atan2(dy, dx);
            save.bullets.push({
                layer: LAYER_ENEMIES,
                z: 1 + this.pos_z(),
                pos: { x: this.pos.x, y: this.pos.y },
                dir: { x: Math.cos(angle), y: Math.sin(angle) },
                range: 10,
                speed: 20,
                sprite: ATLAS_CARROT
            });
        },

        controls_movement() {
            let movement_x = (input.keysdown.get("a") ?? 0) - (input.keysdown.get("d") ?? 0);
            let movement_y = (input.keysdown.get("s") ?? 0) - (input.keysdown.get("w") ?? 0);
            if (Math.abs(movement_x) > 0 || Math.abs(movement_y) > 0) {
                const movement_len = Math.sqrt(movement_x*movement_x + movement_y*movement_y);
                movement_x /= movement_len;
                movement_y /= movement_len;
            }

            const p = { x: save.player.pos.x, y: save.player.pos.y };

            const accel_x = 24*movement_x;
            const accel_y = 24*movement_y;
            p.x += save.player.vel.x*delta_time + 0.5*accel_x*delta_time*delta_time;
            p.y += save.player.vel.y*delta_time + 0.5*accel_y*delta_time*delta_time;
            save.player.vel.x += accel_x * delta_time;
            save.player.vel.y += accel_y * delta_time;

            {
                const fraction_remaining_after_one_second = 0.01;
                const new_vel_x = save.player.vel.x * Math.pow(fraction_remaining_after_one_second, delta_time);
                const new_vel_y = save.player.vel.y * Math.pow(fraction_remaining_after_one_second, delta_time);

                p.x += (new_vel_x - save.player.vel.x) / Math.log(fraction_remaining_after_one_second);
                p.y += (new_vel_y - save.player.vel.y) / Math.log(fraction_remaining_after_one_second);

                save.player.vel.x = new_vel_x;
                save.player.vel.y = new_vel_y;
            }

            const SPEED = 2;
            p.x += movement_x*SPEED*delta_time;
            p.y += movement_y*SPEED*delta_time;

            /* map collision
             * - weird combination of SAT and SDFs */
            {
                let next_p_x = save.player.pos.x;
                let next_p_y = save.player.pos.y;
                const axes = [{ x: save.player.pos.x, y: p.y }, { x: p.x, y: save.player.pos.y }];
                for (let i = 0; i < axes.length; i++) {
                    const o = axes[i];

                    /* how far you're trying to go */
                    let moved_dist = Math.sqrt((save.player.pos.x - o.x)*(save.player.pos.x - o.x) +
                                               (save.player.pos.y - o.y)*(save.player.pos.y - o.y));

                    /* how far you can go w/o hitting something */
                    let max_dist = save.map().distance_at(o);

                    const min = Math.min(-max_dist, moved_dist);

                    const cut_dist = Math.abs(min - moved_dist);

                    /* here we address an edge case where the user gets stuck in a wall
                     * we get the normal of the surface and push them out. */
                    if (cut_dist > SPEED*0.9) {
                        let best_vec, best_vec_dist = Infinity;
                        for (let j = 0; j < 2; j++) {
                            const perp = axes[j];
                            const perp_backwards = {
                                x: save.player.pos.x - (perp.x - save.player.pos.x),
                                y: save.player.pos.y - (perp.y - save.player.pos.y)
                            };
                            for (const p of [perp, perp_backwards]) {
                                const dist = save.map().distance_at(p);
                                if (dist < best_vec_dist) {
                                    best_vec_dist = dist;
                                    best_vec = p;
                                }
                            }
                        }

                        if (best_vec) {
                            const dx = save.player.pos.x - best_vec.x;
                            const dy = save.player.pos.y - best_vec.y;
                            save.player.vel.x += dx * 0.1;
                            save.player.vel.y += dy * 0.1;
                        }
                    }

                    let dx = o.x - save.player.pos.x;
                    let dy = o.y - save.player.pos.y;

                    if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
                        const d_len = Math.sqrt(dx*dx + dy*dy);
                        dx /= d_len;
                        dy /= d_len;

                        next_p_x += dx*min;
                        next_p_y += dy*min;
                    }
                }
                save.player.pos.x = next_p_x;
                save.player.pos.y = next_p_y;
            }

            if (!CAMERA_CONTROLS_ACTIVE || input.last_action == LAST_ACTION_KEY)
                this.damp_camera();
        },

        damp_camera(toward_x=save.player.pos.x, toward_y=save.player.pos.y) {
            const t = Math.pow(1 - this.damped_cam_factor, Math.round(target_fps)*delta_time);
            this.damped_cam_pivot_x = input.cam_pivot_x = lerp(this.damped_cam_pivot_x, toward_x, t);
            this.damped_cam_pivot_y = input.cam_pivot_y = lerp(this.damped_cam_pivot_y, toward_y, t);

            input.pitch = lerp(input.pitch, DEFAULT_PITCH, t);
            input.yaw   = lerp(input.yaw  , DEFAULT_YAW,   t);
        }
    },

    bullets: [],
    bullet: {
        update(bullets) {
            for (let i = 0; i < bullets.length; i++) {
                const bullet = bullets[i];

                bullet.pos.x += bullet.speed * bullet.dir.x * delta_time;
                bullet.pos.y += bullet.speed * bullet.dir.y * delta_time;
                bullet.range -= bullet.speed * delta_time;

                if (bullet.range < 0) bullets.splice(i--, 1);
            }
        },
        
        draw({ pushImgUV, pushFlatXYZ }, bullet) {
            pushImgUV(bullet.sprite, 0, unit_clamp(inv_lerp(0.0, 1.5, bullet.range)));
            pushFlatXYZ(
                bullet.pos.x,
                bullet.pos.y,
                bullet.z,
                1,
                /* spin x10/second */
                (-last_timestamp * 10) % (Math.PI*2)
            );
        },
        
        for_collisions(bullets, layer, pos, radius, callback) {
            for (let i = 0; i < bullets.length; i++) {
                const bullet = bullets[i];
                if (!(bullet.layer & layer)) continue;

                const dx = bullet.pos.x - pos.x;
                const dy = bullet.pos.y - pos.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const hit = (dist < radius);

                let collision = false;
                if (save.map().BULLETS_HIT_WALLS) {
                    collision = 0.3 < save.map().distance_at(bullet.pos);
                    if (collision) {
                        const direction = Math.atan2(bullet.dir.y, bullet.dir.x);
                        save.particle.spurt(bullet.sprite, save.particles, direction, bullet.pos, 1, 0.45);
                    }
                }

                if (collision || (hit && callback(bullet))) {
                    bullets.splice(i--, 1);
                }
            }
        }
    },

    particles: [],
    particle: {
        update(particles) {
            for (let i = 0; i < particles.length; i++) {
                const particle = particles[i];

                particle.pos.x += particle.speed * particle.dir.x * delta_time;
                particle.pos.y += particle.speed * particle.dir.y * delta_time;
                particle.range -= particle.speed * delta_time;

                particle.pos.z -= 2.0*delta_time;

                if (particle.range < 0) particles.splice(i--, 1);
            }
        },
        
        draw({ pushImgUV, pushSpriteXYZ }, particle) {
            pushImgUV(particle.sprite, 0, unit_clamp(inv_lerp(0.0, 1.5, particle.range)));
            pushSpriteXYZ(
                particle.pos.x,
                particle.pos.y,
                particle.z,
                particle.size,
            );
        },

        blood(particles, dir, pos, z = 0) {
            for (let i = 0; i < 15; i++) {
                const t = i / 15;
                const edge = 1 - 2 * Math.abs(t - 0.5);

                const randomness = 0.2 * edge;
                const base_range = Math.PI*0.8;
                const half = (randomness + base_range)*0.5;
                const angle = dir + (Math.random()*randomness + base_range*t) - half;
                particles.push({
                    z: 1 + z,
                    pos: {
                        x: pos.x - Math.cos(angle) * 0.2,
                        y: pos.y - Math.sin(angle) * 0.2
                    },
                    dir: {
                        x: Math.cos(angle),
                        y: Math.sin(angle)
                    },
                    range: (3 + 0.5*Math.random()) * lerp(1.0, 1.6, edge),
                    speed: (3 + 4.0*Math.random()) * lerp(1.0, 1.8, edge),
                    size: (0.1 + 0.1*Math.random()) * lerp(0.2, 1.0, edge),
                    sprite: ATLAS_BLOOD
                });
            }
        },

        spurt(sprite, particles, dir, pos, z = 0, spurt_size=1) {
            for (let i = 0; i < 15; i++) {
                const t = i / 15;
                const edge = 1 - 2 * Math.abs(t - 0.5);

                const randomness = 0.2 * edge;
                const base_range = Math.PI*0.8;
                const half = (randomness + base_range)*0.5;
                const angle = dir + (Math.random()*randomness + base_range*t) - half;
                particles.push({
                    z: 1 + z,
                    pos: {
                        x: pos.x - Math.cos(angle) * 0.2,
                        y: pos.y - Math.sin(angle) * 0.2
                    },
                    dir: {
                        x: Math.cos(angle),
                        y: Math.sin(angle)
                    },
                    range: (3 + 0.5*Math.random()) * lerp(1.0, 1.6, edge) * spurt_size,
                    speed: (3 + 4.0*Math.random()) * lerp(1.0, 1.8, edge),
                    size: (0.1 + 0.1*Math.random()) * lerp(0.2, 1.0, edge),
                    sprite
                });
            }
        }
    },

    flinch: {
        timestamp: null,
        dir_x: 0,
        dir_y: 0,

        trigger(direction) {
            this.timestamp = last_timestamp;
            const angle = Math.random() * Math.PI * 2;
            this.dir_x = Math.cos(angle);
            this.dir_y = Math.sin(angle);

            save.particle.blood(
                save.particles,
                direction,
                save.player.pos,
                save.player.pos_z()
            );
        },

        t() {
            if (this.timestamp == null) return 0;
            let t = (last_timestamp - this.timestamp) / 1;

            if (t > 1.0) t = 0;

            return t;
        },

        camera() {
            let t = this.t();
            t = ease_out_circ(unit_clamp(t / 0.6));
            if (t == 0) return;

            input.pitch = lerp(DEFAULT_PITCH + 0.09*this.dir_x, DEFAULT_PITCH, t);
            input.yaw   = lerp(DEFAULT_YAW   + 0.09*this.dir_y,   DEFAULT_YAW, t);
        },

        draw({ geo }) {
            const t = this.t();
            if (t == 0) return;

            const size = 10000;
            const x = 0;
            const y = 0;
            const z = 0;

            {
                const rot_x = 1 * size;
                const rot_z = 0 * size;

                const vbuf_i = geo.pos.length / 3;

                geo.pos.push(x+rot_x, y + rot_z, z);
                geo.pos.push(x+rot_z, y - rot_x, z);
                geo.pos.push(x-rot_x, y - rot_z, z);
                geo.pos.push(x-rot_z, y + rot_x, z);

                geo.layer.push(1e6);
                geo.layer.push(1e6);

                geo.idx.push(vbuf_i + 0, vbuf_i + 1, vbuf_i + 2,
                             vbuf_i + 2, vbuf_i + 3, vbuf_i + 0);
            }

            {
                const opacity = 0.4 * (1 - t);
                const r = 1.0;
                const g = 0.1;
                const b = 0.1;
                geo.uv.push(
                    r*opacity, g*opacity, b*opacity, opacity,
                    r*opacity, g*opacity, b*opacity, opacity,
                    r*opacity, g*opacity, b*opacity, opacity,
                    r*opacity, g*opacity, b*opacity, opacity
                );
            }
        },
    },

    map_key: DEBUG ? MAP_ENEMY_TEST : MAP_TUTORIAL,
    map() { return this.maps[this.map_key]; },

    maps: {

        [MAP_BASIC]: {
            PLAYER_SPAWN: {},
            BULLETS_HIT_WALLS: true,


            for_circles(circle) {
                circle(  0.0,  0.0,  8.0);
            },

            hole_transition: { step_timestamp: null, stepped_idx: null },
            for_holes(hole) {
                // map_util.hole.for_spawn(hole, this.PLAYER_SPAWN, MAP_TUTORIAL, 0);
            },

            camera_animate() {
                map_util.hole.leaving_cutscene(this.hole_transition, this.for_holes.bind(this));
            },

            update() {
                let i = 0;

                if (save.cutscene_active) return;

                map_util.hole.detect_step(this.hole_transition, this.for_holes.bind(this));
            },

            draw(ctx) {
                const { pushSpriteXYZ, pushImgUV, drawImg } = ctx;

                this.for_circles((x, y, size) => {
                    drawImg(
                        AXIS_FLAT,
                        x + size*MOON_NUDGE_X, y+size*MOON_NUDGE_Y,
                        size * 0.9,
                        ATLAS_MOON,
                        SHADER_FLAG_GREENIFY
                    );
                });

                drawImg(AXIS_SPRITE, 3, 1,  0.8, ATLAS_THREAD);
                
                map_util.hole.draw(this.hole_transition, this.for_holes.bind(this), ctx);
            },

            distance_at(pos) {
                let circ_min_dist = Infinity;

                this.for_circles((x, y, size) => {
                    const dx = pos.x - x;
                    const dy = pos.y - y;
                    const dist = Math.sqrt(dx*dx + dy*dy) - size*0.65;
                    circ_min_dist = Math.min(circ_min_dist, dist);
                });

                return circ_min_dist;
            },

            height_at(p) {
                let height = 0;

                return height;
            },
        },

        [MAP_ENEMY_TEST]: {
            PLAYER_SPAWN: {},
            BULLETS_HIT_WALLS: true,

            enemies: map_util.enemies.init(),

            for_enemies(enemy) {
                const slime = map_util.enemies.ENEMY.SLIME;
                // enemy(0, slime,  2,  2);
                // enemy(1, slime, -2,  2);
                // enemy(2, slime, -2, -2);
                // enemy(3, slime,  2, -2);

                if (1) {
                    const MOAI_MINION_COUNT = 6;

                    // const moai_x = 24;
                    const moai_x = 6;
                    const moai_y = 0;
                    if (0) {
                        const t = 0.1 * Math.sin(5*last_timestamp);
                        drawImg(AXIS_SPRITE, moai_x, moai_y, 3 + t, ATLAS_MOAI);
                    }

                    for (let i = 0; i < MOAI_MINION_COUNT; i++) {
                        const t = i / MOAI_MINION_COUNT;

                        const bob  = Math.sin(10*(i + last_timestamp));
                        const out = 3.2 + 0.2*(1 + Math.sin(15*(i + last_timestamp)));
                        let x = moai_x + 0.25 + out * Math.cos(last_timestamp + t * Math.PI * 2);
                        let y = moai_y + 0.00 + out * Math.sin(last_timestamp + t * Math.PI * 2);
                        let z = 2.5;
                        z += bob * 0.2;

                        enemy(i, map_util.enemies.ENEMY.MINI_MOAI, x, y);
                        // pushImgUV(ATLAS_MOAI);
                        // pushSpriteXYZ(x, y, z, 1);
                    }
                }
            },

            for_circles(circle) {
                circle( -3.0,  0.0,  12.0);
                circle(  6.0,  0.0,  12.0);
                circle( 15.0,  0.0,  12.0);
                circle( 24.0,  0.0,  18.0);
            },

            hole_transition: { step_timestamp: null, stepped_idx: null },
            for_holes(hole) {
                // map_util.hole.for_spawn(hole, this.PLAYER_SPAWN, MAP_TUTORIAL, 0);
            },

            camera_animate() {
                map_util.hole.leaving_cutscene(this.hole_transition, this.for_holes.bind(this));
            },

            update() {
                let i = 0;

                if (save.cutscene_active) return;

                map_util.hole.detect_step(this.hole_transition, this.for_holes.bind(this));

                map_util.enemies.update(this.enemies, this.for_enemies.bind(this));

            },

            draw(ctx) {
                const { pushSpriteXYZ, pushImgUV, drawImg } = ctx;

                {
                    const MOAI_MINION_COUNT = 6;

                    // const moai_x = 24;
                    const moai_x = 6;
                    const moai_y = 0;
                    {
                        const t = 0.1 * Math.sin(5*last_timestamp);
                        drawImg(AXIS_SPRITE, moai_x, moai_y, 3 + t, ATLAS_MOAI);
                    }

                    for (let i = 0; i < MOAI_MINION_COUNT; i++) {
                        const t = i / MOAI_MINION_COUNT;

                        const bob  = Math.sin(10*(i + last_timestamp));
                        const out = 3.2 + 0.2*(1 + Math.sin(15*(i + last_timestamp)));
                        let x = moai_x + 0.25 + out * Math.cos(last_timestamp + t * Math.PI * 2);
                        let y = moai_y + 0.00 + out * Math.sin(last_timestamp + t * Math.PI * 2);
                        let z = 2.5;
                        z += bob * 0.2;

                        pushImgUV(ATLAS_MOAI);
                        pushSpriteXYZ(x, y, z, 1);
                    }
                }

                this.for_circles((x, y, size) => {
                    drawImg(
                        AXIS_FLAT,
                        x + size*MOON_NUDGE_X, y+size*MOON_NUDGE_Y,
                        size * 0.9,
                        ATLAS_MOON,
                        SHADER_FLAG_GREENIFY
                    );
                });

                map_util.hole.draw(this.hole_transition, this.for_holes.bind(this), ctx);
                map_util.enemies.draw(this.enemies, this.for_enemies.bind(this), ctx);
            },

            distance_at(pos) {
                let circ_min_dist = Infinity;

                this.for_circles((x, y, size) => {
                    const dx = pos.x - x;
                    const dy = pos.y - y;
                    const dist = Math.sqrt(dx*dx + dy*dy) - size*0.65;
                    circ_min_dist = Math.min(circ_min_dist, dist);
                });

                return circ_min_dist;
            },

            height_at(p) {
                let height = 0;

                return height;
            },
        },

        [MAP_DRAWBRIDGE]: {
            PLAYER_SPAWN: {
                [HOLE_TUTORIAL_TO_DRAWBRIDGE]:   { pos: { x: -17.2, y: -15.0 }, map: MAP_TUTORIAL },
                [HOLE_UPPER_DRAWBRIDGE_TO_CAVE]: { pos: { x: -15.6, y:  -1.6 }, map: MAP_CAVE     },
                [HOLE_CAVE_TO_LOWER_DRAWBRIDGE]: { pos: { x:  -2.0, y:  -3.0 }, map: MAP_CAVE     },
            },
            BULLETS_HIT_WALLS: true,

            crank_progress: 0,
            crank_angle_vel: 0,
            crank_angle: 0,
            CRANK_X: 3,
            CRANK_Y: 3,
            CRANK_ANGLE_OFFSET: 0.525*Math.PI,

            LOOKOUT_X: -15.6,
            LOOKOUT_Y: - 5.6,

            for_circles(circle) {
                circle(   0.6,   5.4,  4.5);
                circle(   0.0,   0.0,  8.0);
                circle(   4.4,   3.7,  7.0);

                circle( -15.6, -14.8,  5.7);
                circle( -16.6, - 9.6,  4.2);
                circle( this.LOOKOUT_X, this.LOOKOUT_Y+1, 5.2);

                circle(  14.8, -14.8,  5.5);
            },

            camera_animate() {
                if (this.crank_progress < 0.99) {
                    const player = save.player;
                    let dist = Math.abs(player.pos.y - (this.LOOKOUT_Y - 3));
                    dist = unit_clamp(1 - Math.min(1, dist / 4));
                    input.zoom = lerp(DEFAULT_ZOOM, DEFAULT_ZOOM*1.5, dist);

                    player.damped_cam_factor = DEFAULT_DAMPED_CAM_FACTOR;
                    if (dist > 0) {
                        player.damp_camera(
                            this.LOOKOUT_X + dist*10.0,
                            this.LOOKOUT_Y + dist*0.8
                        );
                        player.damped_cam_factor = 1;
                    }
                }

                map_util.hole.leaving_cutscene(this.hole_transition, this.for_holes.bind(this));
            },

            for_bridges(bridge) {
                bridge({ y: -15, path_from: -10, path_to: lerp(-10, 11, unit_clamp(this.crank_progress)) });
            },

            hole_transition: { step_timestamp: null, stepped_idx: null },
            for_holes(hole) {
                map_util.hole.for_spawn(hole, this.PLAYER_SPAWN, HOLE_TUTORIAL_TO_DRAWBRIDGE  , 0);
                map_util.hole.for_spawn(hole, this.PLAYER_SPAWN, HOLE_CAVE_TO_LOWER_DRAWBRIDGE, 1);
                map_util.hole.for_spawn(hole, this.PLAYER_SPAWN, HOLE_UPPER_DRAWBRIDGE_TO_CAVE, 2);
            },

            update() {
                let i = 0;

                if (save.cutscene_active) return;

                /* crankin' */
                {
                    let dx = this.CRANK_X - save.player.pos.x;
                    let dy = this.CRANK_Y - save.player.pos.y;
                    const dlen = Math.sqrt(dx*dx + dy*dy);
                    if (dlen > 2) {
                        dx /= dlen;
                        dy /= dlen;

                        const px = Math.cos(this.crank_angle);
                        const py = Math.sin(this.crank_angle);
                        const ccw = ((-dy)*px + dx*py) < 0;
                        const close = (dx*px + dy*py) > 0.85;

                        if (!ccw && close) {
                            const goal_angle = Math.atan2(dy, dx);
                            const t = Math.pow(1 - 0.4, Math.round(target_fps)*delta_time);
                            this.crank_angle_vel += 0.7*(this.crank_angle - lerp_rads(this.crank_angle, goal_angle, t));
                        }
                    }

                    /* frame-independent multiplicative drag */
                    {
                        const fraction_remaining_after_one_second = 0.002;
                        const new_vel_angle = this.crank_angle_vel * Math.pow(fraction_remaining_after_one_second, delta_time);

                        let delta = (new_vel_angle - this.crank_angle_vel) / Math.log(fraction_remaining_after_one_second);

                        delta *= 0.1;
                        const new_crank_progress = Math.min(1, this.crank_progress + delta);
                        const progress_capped_delta = (new_crank_progress - this.crank_progress);
                        this.crank_angle += progress_capped_delta*10;
                        this.crank_progress += progress_capped_delta;

                        this.crank_angle_vel = new_vel_angle;
                    }
                }

                map_util.hole.detect_step(this.hole_transition, this.for_holes.bind(this));
            },

            draw(ctx) {
                const { pushSpriteXYZ, pushFlatXYZ, geo, pushImgUV, drawImg } = ctx;

                this.for_circles((x, y, size) => {
                    drawImg(
                        AXIS_FLAT,
                        x + size*MOON_NUDGE_X, y+size*MOON_NUDGE_Y,
                        size * 0.9,
                        ATLAS_MOON,
                        SHADER_FLAG_GREENIFY
                    );
                });

                this.for_bridges((bridge) => map_util.bridge.draw(bridge, ctx));

                const { CRANK_X, CRANK_Y } = this;
                const CRANK_HEIGHT = 0.8;
                drawImg(AXIS_SPRITE, CRANK_X, CRANK_Y, CRANK_HEIGHT, ATLAS_THREAD, SHADER_FLAG_BROWNIFY);

                pushImgUV(ATLAS_CANE, SHADER_FLAG_BROWNIFY);
                const rot = this.crank_angle - Math.PI*0.57;
                const end_x = 2.25*Math.cos(rot - this.CRANK_ANGLE_OFFSET);
                const end_y = 2.25*Math.sin(rot - this.CRANK_ANGLE_OFFSET);
                const stick_x = CRANK_X + -0.10 + end_x;
                const stick_y = CRANK_Y + -0.27 + end_y;
                const stick_z = CRANK_HEIGHT + 0.2;
                pushFlatXYZ(stick_x, stick_y, stick_z, 3, rot);
                geo.layer[geo.layer.length - 1] = stick_y + stick_z + 2;
                geo.layer[geo.layer.length - 2] = stick_y + stick_z + 2;

                // pushImgUV(ATLAS_THREAD);
                // pushSpriteXYZ(
                //     stick_x + 0.8*end_x,//+0.3,
                //     stick_y + 0.8*end_y,//+0.3,
                //     stick_z,
                //     0.8
                // );

                map_util.hole.draw(this.hole_transition, this.for_holes.bind(this), ctx);
            },

            distance_at(pos) {
                let min_dist = Infinity;

                this.for_circles((x, y, size) => {
                    const dx = pos.x - x;
                    const dy = pos.y - y;
                    const dist = Math.sqrt(dx*dx + dy*dy) - size*0.65;
                    min_dist = Math.min(min_dist, dist);
                });

                this.for_bridges((bridge) => {
                    const dist = map_util.bridge.distance(bridge, pos);
                    min_dist = Math.min(min_dist, dist);
                });

                let max_dist = -Infinity;
                {
                    /* hub */
                    {
                        const dx = pos.x - this.CRANK_X;
                        const dy = pos.y - this.CRANK_Y;
                        const size = 1.2;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        max_dist = Math.max(max_dist, size - dist);
                    }

                    /* shaft */
                    {
                        const angle = this.crank_angle - 3*(this.CRANK_ANGLE_OFFSET - Math.PI*0.5);
                        const b_x = this.CRANK_X - Math.cos(angle) * 4.5;
                        const b_y = this.CRANK_Y - Math.sin(angle) * 4.5;

                        const size = 0.6;
                        const dist = sd_segment(pos, this.CRANK_X, this.CRANK_Y, b_x, b_y);
                        max_dist = Math.max(max_dist, size - dist);
                    }
                }

                return Math.max(min_dist, max_dist);
            },

            height_at(p) {
                let height = Infinity;

                this.for_bridges((bridge) => {
                    let bridge_height = map_util.bridge.height_at(bridge, p);
                    bridge_height = Math.min(0, 0.5 + bridge_height);
                    height = Math.min(height, bridge_height);
                });

                return height;
            },
        },

        [MAP_CAVE]: {
            PLAYER_SPAWN: {
                [HOLE_UPPER_DRAWBRIDGE_TO_CAVE]: {
                    pos: { x:  3, y:  2 },
                    dir: { x: -1, y: -1 },
                    map: MAP_DRAWBRIDGE,
                },
                [HOLE_CAVE_TO_LOWER_DRAWBRIDGE]: {
                    pos: { x: -25.0, y: -2.0 },
                    dir: { x:  -1.0, y: -1.0 },
                    map: MAP_DRAWBRIDGE,
                }
            },
            BULLETS_HIT_WALLS: true,

            enemies: map_util.enemies.init(),

            for_circles(circle) {
                circle(  0.0,  0.0,  8.0);
                circle(-13.0,  6.0,  4.0); /* cluster */
                circle( -8.0,  0.0, 10.0);
                circle(-21.0,  6.0,  3.5); /* cluster */
                circle(-18.0, 11.0,  8.0);
                circle(-25.0,  2.0,  7.0);
            },
            for_enemies(enemy) {
                let idx = 0;

                function cluster(x, y) {
                    const rock = map_util.enemies.ENEMY.ROCK;
                    enemy(idx++, rock, x-0, y+0.0);
                    enemy(idx++, rock, x-0, y+2.0);
                    enemy(idx++, rock, x+2, y+0.5);
                    enemy(idx++, rock, x-2, y+1.0);
                }
                cluster(-13, 6);
                cluster(-21, 5);

                const ninja = map_util.enemies.ENEMY.NINJA;
                const FORMATION_3    = 0;
                const FORMATION_FULL = 1;
                function formation(formation_kind, x, y, dir_x, dir_y) {
                    if (formation_kind == FORMATION_FULL)
                        enemy(idx++, ninja, x-2.0*dir_x, y-2.0*dir_y);
                    enemy(idx++, ninja, x-1.0*dir_x, y-1.0*dir_y);
                    enemy(idx++, ninja, x-0.0*dir_x, y-0.0*dir_y);
                    enemy(idx++, ninja, x+1.0*dir_x, y+1.0*dir_y);
                    if (formation_kind == FORMATION_FULL)
                        enemy(idx++, ninja, x+2.0*dir_x, y+2.0*dir_y);
                }
                formation(FORMATION_3   , -18, 12,  1,  1);
                formation(FORMATION_FULL, -25,  2,  1, -1);
            },

            hole_transition: { step_timestamp: null, stepped_idx: null },
            for_holes(hole) {
                map_util.hole.for_spawn(hole, this.PLAYER_SPAWN, HOLE_UPPER_DRAWBRIDGE_TO_CAVE, 0);
                map_util.hole.for_spawn(hole, this.PLAYER_SPAWN, HOLE_CAVE_TO_LOWER_DRAWBRIDGE, 1);
            },

            camera_animate() {
                map_util.hole.leaving_cutscene(this.hole_transition, this.for_holes.bind(this));
            },

            update() {
                let i = 0;

                if (save.cutscene_active) return;

                map_util.hole.detect_step(this.hole_transition, this.for_holes.bind(this));
                map_util.enemies.update(this.enemies, this.for_enemies.bind(this));
            },

            draw(ctx) {
                const { pushSpriteXYZ, pushImgUV, drawImg } = ctx;

                this.for_circles((x, y, size) => {
                    drawImg(
                        AXIS_FLAT,
                        x + size*MOON_NUDGE_X, y+size*MOON_NUDGE_Y,
                        size * 0.9,
                        ATLAS_MOON,
                        SHADER_FLAG_GREYIFY
                    );
                });

                drawImg(AXIS_SPRITE, -12, -1,  2.0, ATLAS_MOAI);
                drawImg(AXIS_SPRITE,  -8, -3,  4.0, ATLAS_MOAI);
                drawImg(AXIS_FLAT,    -3, -3, -1.2, ATLAS_BONE);
                drawImg(AXIS_FLAT,    -3, -3,  1.2, ATLAS_BONE);
                drawImg(AXIS_SPRITE,   2, -2,  2.4, ATLAS_MOAI);
                
                this.for_enemies((idx, kind, x, y) => {
                    const rock = map_util.enemies.ENEMY.ROCK;
                    if (kind != rock) return;
                    if (!map_util.enemies.is_dead(this.enemies, idx, x, y)) return;

                    drawImg(AXIS_SPRITE, x+0.1, y+0.4, 0.2, ATLAS_ROCK);
                    drawImg(AXIS_SPRITE, x-0.2, y+0.0, 0.3, ATLAS_ROCK);
                });

                map_util.enemies.draw(this.enemies, this.for_enemies.bind(this), ctx);
                map_util.hole.draw(this.hole_transition, this.for_holes.bind(this), ctx);
            },

            distance_at(pos) {
                let circ_min_dist = Infinity;

                this.for_circles((x, y, size) => {
                    const dx = pos.x - x;
                    const dy = pos.y - y;
                    const dist = Math.sqrt(dx*dx + dy*dy) - size*0.65;
                    circ_min_dist = Math.min(circ_min_dist, dist);
                });

                let rock_max_dist = -Infinity;
                this.for_enemies((idx, kind, x, y) => {
                    const rock = map_util.enemies.ENEMY.ROCK;
                    if (kind != rock) return;
                    if (map_util.enemies.is_dead(this.enemies, idx, x, y)) return;

                    const dx = pos.x - x;
                    const dy = pos.y - y;
                    const size = 1.2;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    rock_max_dist = Math.max(rock_max_dist, size - dist);
                });

                return Math.max(circ_min_dist, rock_max_dist);
            },

            height_at(p) {
                let height = 0;

                return height;
            },
        },

        [MAP_TUTORIAL]: {
            PLAYER_SPAWN: { [HOLE_TUTORIAL_TO_DRAWBRIDGE]: { pos: { x: -35.8, y: 0.0 }, map: MAP_DRAWBRIDGE } },
            BULLETS_HIT_WALLS: false,

            PICKUP_X: -65.8,
            PICKUP_Y:   0.0,
            pickup_get: false,
            pickup_get_timestamp: null,

            CUTSCENE_CENTER_X: -31.5,
            CUTSCENE_CENTER_Y: 0,
            move_earth_t: 0,
            pickup_get_t: 0,

            enemies: map_util.enemies.init(),

            hole_transition: { step_timestamp: null, stepped_idx: null },
            for_holes(hole) {
                const all_dead = map_util.enemies.all_dead(this.enemies, this.for_enemies.bind(this));

                if (all_dead) map_util.hole.for_spawn(hole, this.PLAYER_SPAWN, HOLE_TUTORIAL_TO_DRAWBRIDGE, 0);

                if (DEBUG) hole(1, 0, -3, HOLE_TUTORIAL_TO_DRAWBRIDGE);
            },

            for_circles(circle) {
                /*      x,  y,  size */
                circle(  2.7,   3.0,     7.0);
                circle( -3.7,   0.0,     9.0);
                circle(  2.7,  -3.0,     9.5);

                circle(-35.3,   0.0,     6.3);
                circle(-66.3,   0.0,     6.5);

                /* enemy platforms */
                this.for_enemies((_idx, _kind, x, y) => circle(x, y, 6.5));
            },

            for_enemies(enemy) {
                const t = this.move_earth_t;

                const ninja = map_util.enemies.ENEMY.TUTORIAL_NINJA;
                enemy(0, ninja, lerp(-25.0, -34.5, t), lerp(-15.0, -6.5, t));
                enemy(1, ninja, lerp(-45.0, -37.5, t), lerp( 12.5,  6.5, t));
            },

            for_bridges(bridge) {
                bridge({ y: 0, path_from: -10, path_to: -29 });
                bridge({ y: 0, path_from: -40, path_to: -60 });
            },

            camera_animate() {
                const leaving = map_util.hole.leaving_cutscene(this.hole_transition, this.for_holes.bind(this));
                if (leaving) return;

                if (this.pickup_get_timestamp == null) return;

                /* we bite off bits of t and assign them to our animations */
                let t = last_timestamp - this.pickup_get_timestamp;
                let out_t = 0, back_t = 0;
                {
                    if (t > 0) save.cutscene_active = true;

                    /* one little pause right after they get the pickup */
                    const PICKUP_GET_DURATION = 2.0;
                    this.pickup_get_t = unit_clamp(t / PICKUP_GET_DURATION); t -= PICKUP_GET_DURATION;

                    t -= 1;

                    const OUT_DURATION = 1;
                    out_t = unit_clamp(t / OUT_DURATION); t -= OUT_DURATION;

                    /* small pauses before and after MOVE_EARTH */
                    {
                        t -= 0.75;

                        const MOVE_EARTH_DURATION = 2;
                        this.move_earth_t = unit_clamp(t / MOVE_EARTH_DURATION); t -= MOVE_EARTH_DURATION;

                        t -= 1.75;
                    }

                    const BACK_DURATION = 1;
                    back_t = unit_clamp(t / BACK_DURATION); t -= BACK_DURATION;

                    /* pause at the end */
                    t -= 0.75;
                }

                if (t > 0) {
                    save.cutscene_active = false;
                    return;
                }

                if (this.pickup_get_t >= 1) {
                    save.player.wep = true;
                    this.pickup_get = true;
                }

                if (out_t > 0) {
                    input.zoom = lerp(DEFAULT_ZOOM,           70,  out_t);
                    input.zoom = lerp(  input.zoom, DEFAULT_ZOOM, back_t);

                    const p = save.player;
                    input.cam_pivot_x = lerp(p.damped_cam_pivot_x, this.CUTSCENE_CENTER_X,  out_t);
                    input.cam_pivot_y = lerp(p.damped_cam_pivot_y, this.CUTSCENE_CENTER_Y,  out_t);
                    input.cam_pivot_x = lerp(   input.cam_pivot_x,   p.damped_cam_pivot_x, back_t);
                    input.cam_pivot_y = lerp(   input.cam_pivot_y,   p.damped_cam_pivot_y, back_t);
                }
            },

            draw(ctx) {
                const { pushSpriteXYZ, pushImgUV, drawImg } = ctx;

                this.for_circles((x, y, size) => {
                    drawImg(
                        AXIS_FLAT,
                        x + size*MOON_NUDGE_X, y+size*MOON_NUDGE_Y,
                        size * 0.9,
                        ATLAS_MOON,
                        SHADER_FLAG_GREENIFY
                    );
                });

                map_util.hole.draw(this.hole_transition, this.for_holes.bind(this), ctx);

                map_util.enemies.draw(this.enemies, this.for_enemies.bind(this), ctx);

                drawImg(AXIS_SPRITE, -5, -3,  2.0, ATLAS_TREE);
                drawImg(AXIS_SPRITE,  2, -5,  4.0, ATLAS_TREE);
                drawImg(AXIS_SPRITE,  2,  7,  1.0, ATLAS_BAMBOO);
                drawImg(AXIS_SPRITE,  4,  5,  1.2, ATLAS_BAMBOO);

                if (!this.pickup_get) {
                    let x = this.PICKUP_X;
                    let y = this.PICKUP_Y + 0.2 + 0.2*Math.sin(last_timestamp*3);
                    let z = 0;
                    let opacity = 1;
                    let scale = 1.0;

                    {
                        let t = this.pickup_get_t;

                        const UP_DURATION = 0.2;
                        const up_t = unit_clamp(t / UP_DURATION); t -= UP_DURATION;

                        t -= 0.1;

                        const JUMP_DURATION = 0.4;
                        const jump_t = unit_clamp(t / JUMP_DURATION); t -= JUMP_DURATION;

                        x = lerp(x, save.player.pos.x, up_t);
                        y = lerp(y, save.player.pos.y, up_t);

                        z = 1.6*up_t;

                        const jump_saw_t = 1 - Math.abs(jump_t - 0.5)*2;
                        z = lerp(z, z+0.25, jump_saw_t);
                        scale *= 1 + jump_saw_t*0.2;

                        t -= 0.2;

                        if (t > 0) opacity = 1 - t / 0.1;
                    }

                    pushImgUV(ATLAS_CARROT, 0, opacity);
                    pushSpriteXYZ(x, y, z, scale);
                }

                this.for_bridges((bridge) => map_util.bridge.draw(bridge, ctx));
            },

            distance_at(pos) {
                let min_dist = Infinity;

                this.for_circles((x, y, size) => {
                    const dx = pos.x - x;
                    const dy = pos.y - y;
                    min_dist = Math.min(min_dist, Math.sqrt(dx*dx + dy*dy) - size*0.65);
                });

                this.for_bridges((bridge) => {
                    const dist = map_util.bridge.distance(bridge, pos);
                    min_dist = Math.min(min_dist, dist);
                });

                return min_dist;
            },

            height_at(p) {
                let height = Infinity;

                this.for_bridges((bridge) => {
                    let bridge_height = map_util.bridge.height_at(bridge, p);
                    bridge_height = Math.min(0, 0.5 + bridge_height);
                    height = Math.min(height, bridge_height);
                });

                return height;
            },

            update() {
                let i = 0;

                if (save.cutscene_active) return;

                map_util.hole.detect_step(this.hole_transition, this.for_holes.bind(this));

                map_util.enemies.update(this.enemies, this.for_enemies.bind(this));

                if (this.pickup_get_timestamp == null) {
                    const dx = save.player.pos.x - this.PICKUP_X;
                    const dy = save.player.pos.y - this.PICKUP_Y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 0.7) {
                        this.pickup_get_timestamp = last_timestamp;
                    }
                }
            },
        },
    }
};

requestAnimationFrame(function frame(timestamp) {
    requestAnimationFrame(frame);

    timestamp *= 0.001;
    last_timestamp ??= timestamp;
    delta_time = timestamp - last_timestamp;
    last_timestamp = timestamp;

    if (delta_time > 0) target_fps = 0.95*target_fps + 0.05*(1 / delta_time);

    save.cutscene_active = false; /* if map sets this to true in camera_animate, no e.g. movement or enemy AI occurs */
    save.map().camera_animate();

    if (!save.cutscene_active) {
        save.player.controls_movement();
        save.player.controls_aiming();

        save.flinch.camera();
    }

    /* click and drag camera controls */
    if (CAMERA_CONTROLS_ACTIVE) input.camera_controls()

    input.camera_construct();

    /* rendering */
    const geo = {
        idx: [],
        pos: [],
        uv : [],

        /* this isn't uploaded to the GPU, but is used for sorting beforehand.
         *  per-triangle. */
        layer: []
    };

    /* filling the geo buffers */
    {
        /* don't use this without also pushing a pos; see drawImg */
        function pushImgUV(atlas_index, flag=0, opacity=1, flip_x=0, flip_y=0) {

            /* generate UVs from atlas_index */
            {
                const u = (           atlas_index % ATLAS_SIZE );
                const v = (Math.floor(atlas_index / ATLAS_SIZE));

                let min_x = (flip_x) ? 0.98 : 0.02;
                let max_x = (flip_x) ? 0.02 : 0.98;
                let min_y = (flip_y) ? 0.98 : 0.02;
                let max_y = (flip_y) ? 0.02 : 0.98;

                geo.uv.push(
                    -(u+max_x)/ATLAS_SIZE, -(v+max_y)/ATLAS_SIZE, flag, opacity,
                    -(u+min_x)/ATLAS_SIZE, -(v+max_y)/ATLAS_SIZE, flag, opacity,
                    -(u+min_x)/ATLAS_SIZE, -(v+min_y)/ATLAS_SIZE, flag, opacity,
                    -(u+max_x)/ATLAS_SIZE, -(v+min_y)/ATLAS_SIZE, flag, opacity
                );
            }
        }

        function pushFlatXYZ(x, y, z, size, rot=0) {
            const rot_x = Math.cos(rot) * size;
            const rot_z = Math.sin(rot) * size;

            const vbuf_i = geo.pos.length / 3;

            geo.pos.push(x+rot_x, y + rot_z, z);
            geo.pos.push(x+rot_z, y - rot_x, z);
            geo.pos.push(x-rot_x, y - rot_z, z);
            geo.pos.push(x-rot_z, y + rot_x, z);

            geo.layer.push(y);
            geo.layer.push(y);

            geo.idx.push(vbuf_i + 0, vbuf_i + 1, vbuf_i + 2,
                         vbuf_i + 2, vbuf_i + 3, vbuf_i + 0);
        }

        const back = Math.cos(Math.PI*0.25);
        function pushSpriteXYZ(x, y, z, size_x, size_y = size_x) {
            const center_x = x;
            const center_z = z + back*size_y;

            const vbuf_i = geo.pos.length / 3;

            geo.pos.push(center_x+size_x, y            , center_z - back*size_y);
            geo.pos.push(center_x-size_x, y            , center_z - back*size_y);
            geo.pos.push(center_x-size_x, y-back*size_y, center_z + back*size_y);
            geo.pos.push(center_x+size_x, y-back*size_y, center_z + back*size_y);

            geo.idx.push(vbuf_i + 0, vbuf_i + 1, vbuf_i + 2,
                         vbuf_i + 2, vbuf_i + 3, vbuf_i + 0);

            geo.layer.push(y);
            geo.layer.push(y);
        }

        function drawImg(axis, x, y, size, atlas_index, flag=0) {
            pushImgUV(atlas_index, flag, 1, Math.sign(size) == -1);

            switch (axis) {
                case (AXIS_FLAT): {
                    const vbuf_i = geo.pos.length / 3;

                    geo.pos.push(x+size, y-size, 0.0);
                    geo.pos.push(x-size, y-size, 0.0);
                    geo.pos.push(x-size, y+size, 0.0);
                    geo.pos.push(x+size, y+size, 0.0);

                    geo.idx.push(vbuf_i + 0, vbuf_i + 1, vbuf_i + 2,
                                 vbuf_i + 2, vbuf_i + 3, vbuf_i + 0);

                    geo.layer.push(-1e6);
                    geo.layer.push(-1e6);
                }; break;

                case (AXIS_SPRITE): {
                    pushSpriteXYZ(x, y, 0, size);
                }; break;
            }

        }

        save.map()   .update();
        save.player  .update();
        save.bullet  .update(save.bullets  );
        save.particle.update(save.particles);

        const ctx = { geo, pushFlatXYZ, pushSpriteXYZ, pushImgUV, drawImg };
        save.flinch.draw(ctx);
        save.bullets  .forEach(b => save.bullet  .draw(ctx, b));
        save.particles.forEach(b => save.particle.draw(ctx, b));
        save.map().draw(ctx);

        save.player.draw(ctx);
    }

    /* sorting triangles for order-dependent transparency
     * there are probably very trivial ways to optimize this */
    {
        const tris = [];

        for (let i = 0; i < geo.idx.length; i += 3) {
            tris.push([
                [
                    geo.idx[i + 0],
                    geo.idx[i + 1],
                    geo.idx[i + 2]
                ],
                geo.layer[i / 3]
            ]);
        }

        tris.sort((a, b) => a[1] - b[1]);

        geo.idx = tris.map(x => x[0]).flat();
    }

    /* submitting geometry to the GPU */
    {
        /* no point in enabling depth since things need to be sorted anyway :thinking: */
        // gl.enable(gl.DEPTH_TEST);
        // gl.depthFunc(gl.LEQUAL);

        /* set up premultiplied alpha */
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);

        /* clear all */
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

        /* skydome pass */
        {
            gl.useProgram(shaders.skydome.program);
            gl.enableVertexAttribArray(shaders.skydome.a_pos);
            gl.enableVertexAttribArray(shaders.skydome.a_uv);

            gl.uniformMatrix4fv(shaders.skydome.u_matrix, false, input.vp_skydome);

            /* bind tex_skydome */
            {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_skydome);
                gl.uniform1i(shaders.skydome.u_texture, 0);
            }

            /* bind geometry */
            {
                gl.bindBuffer(gl.ARRAY_BUFFER, buf.skydome_v_pos);
                gl.vertexAttribPointer(shaders.skydome.a_pos, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, buf.skydome_v_uv);
                gl.vertexAttribPointer(shaders.skydome.a_uv, 2, gl.FLOAT, true, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.skydome_i);
            }

            gl.drawElements(gl.TRIANGLES, buf.skydome_i_count, gl.UNSIGNED_SHORT, 0);
        }

        /* geo pass */
        {
            gl.useProgram(shaders.geo.program);
            gl.enableVertexAttribArray(shaders.geo.a_pos);
            gl.enableVertexAttribArray(shaders.geo.a_uv);

            gl.uniformMatrix4fv(shaders.geo.u_matrix, false, input.vp);

            /* upload/bind atlas */
            {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, atlas);
                gl.uniform1i(shaders.geo.u_texture, 0);
            }

            /* upload/bind geometry */
            {
                gl.bindBuffer(gl.ARRAY_BUFFER, buf.geo_v_pos);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo.pos), gl.STATIC_DRAW);
                gl.vertexAttribPointer(shaders.geo.a_pos, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, buf.geo_v_uv);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo.uv), gl.STATIC_DRAW);
                gl.vertexAttribPointer(shaders.geo.a_uv, 4, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.geo_i);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geo.idx), gl.STATIC_DRAW);
            }

            gl.drawElements(gl.TRIANGLES, geo.idx.length, gl.UNSIGNED_SHORT, 0);
        }
    }
})

/* math utils */

const mat4_scratch = mat4_create();

function mat4_create() {
    let out = new Float32Array(16);
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
}

function mat4_transform_vec4(out, a, m) {
    let x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
}

function mat4_mul(out, a, b) {
    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    /* Cache only the current line of the second matrix */
    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}

function mat4_target_to(out, eye, target, up=VEC3_UP) {
    let eyex = eye[0], eyey = eye[1], eyez = eye[2],
         upx =  up[0],  upy =  up[1],  upz =  up[2];
    let z0 = eyex - target[0],
        z1 = eyey - target[1],
        z2 = eyez - target[2];
    let len = z0 * z0 + z1 * z1 + z2 * z2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        z0 *= len;
        z1 *= len;
        z2 *= len;
    }
    let x0 = upy * z2 - upz * z1,
        x1 = upz * z0 - upx * z2,
        x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
}

function mat4_perspective(out, fovy, aspect, near, far) {
    let f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
    } else {
        out[10] = -1;
        out[14] = -2 * near;
    }
    return out;
}

function mat4_from_y_rotation(out, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    /* Perform axis-specific matrix multiplication */
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

function mat4_from_z_rotation(out, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    /* Perform axis-specific matrix multiplication */
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

function mat4_invert(out, a) {
    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    let b00 = a00 * a11 - a01 * a10;
    let b01 = a00 * a12 - a02 * a10;
    let b02 = a00 * a13 - a03 * a10;
    let b03 = a01 * a12 - a02 * a11;
    let b04 = a01 * a13 - a03 * a11;
    let b05 = a02 * a13 - a03 * a12;
    let b06 = a20 * a31 - a21 * a30;
    let b07 = a20 * a32 - a22 * a30;
    let b08 = a20 * a33 - a23 * a30;
    let b09 = a21 * a32 - a22 * a31;
    let b10 = a21 * a33 - a23 * a31;
    let b11 = a22 * a33 - a23 * a32;
    /* Calculate the determinant */
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
        return null;
    }
    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
}

function catmull(p0, p1, p2, p3, t, alpha=0.5) {
  function get_t(t, alpha, p0, p1) {
    const dx = p1[0] - p0[0];
    const dy = p1[1] - p0[1];
    const a = dx*dx + dy*dy; /* dot product */
    const b = Math.pow(a, alpha*0.5);
    return (b + t);
  }

  const t0 = 0.0;
  const t1 = get_t(t0, alpha, p0, p1);
  const t2 = get_t(t1, alpha, p1, p2);
  const t3 = get_t(t2, alpha, p2, p3);
  t = lerp(t1, t2, t);

  const A1_x = (t1 - t)/(t1 - t0)*p0[0] + (t - t0)/(t1 - t0)*p1[0];
  const A1_y = (t1 - t)/(t1 - t0)*p0[1] + (t - t0)/(t1 - t0)*p1[1];

  const A2_x = (t2 - t)/(t2 - t1)*p1[0] + (t - t1)/(t2 - t1)*p2[0];
  const A2_y = (t2 - t)/(t2 - t1)*p1[1] + (t - t1)/(t2 - t1)*p2[1];

  const A3_x = (t3 - t)/(t3 - t2)*p2[0] + (t - t2)/(t3 - t2)*p3[0];
  const A3_y = (t3 - t)/(t3 - t2)*p2[1] + (t - t2)/(t3 - t2)*p3[1];

  const B1_x = (t2 - t)/(t2 - t0)*A1_x + (t - t0)/(t2 - t0)*A2_x;
  const B1_y = (t2 - t)/(t2 - t0)*A1_y + (t - t0)/(t2 - t0)*A2_y;

  const B2_x = (t3 - t)/(t3 - t1)*A2_x + (t - t1)/(t3 - t1)*A3_x;
  const B2_y = (t3 - t)/(t3 - t1)*A2_y + (t - t1)/(t3 - t1)*A3_y;

  const C_x  = (t2 - t)/(t2 - t1)*B1_x + (t - t1)/(t2 - t1)*B2_x;
  const C_y  = (t2 - t)/(t2 - t1)*B1_y + (t - t1)/(t2 - t1)*B2_y;

  return [C_x, C_y];
}

function catmull_uniformly_spaced(catmull_args, desired_spacing) {
    catmull_args.alpha ??= 0.5;
    const { p0, p1, p2, p3, t, alpha } = catmull_args;

    const TABLE_SEGMENTS = 100;

    const arc_len_table = Array.from({ length: TABLE_SEGMENTS }, _ => 0);
    let last = catmull(p0, p1, p2, p3, 0, alpha);
    for (let last_len = 0, i = 0; i < (TABLE_SEGMENTS + 1); i++) {
        const t = i / TABLE_SEGMENTS;

        const p = catmull(p0, p1, p2, p3, t, alpha);
        const len = Math.sqrt((p[0] - last[0])*(p[0] - last[0]) +
                              (p[1] - last[1])*(p[1] - last[1]));
        arc_len_table[i] = last_len + len;
        last_len = len;
    }
    const arc_len_of_t = t => lerp(
        arc_len_table[Math.floor(t * TABLE_SEGMENTS)],
        arc_len_table[Math. ceil(t * TABLE_SEGMENTS)],
        (t * TABLE_SEGMENTS) - Math.floor(t * TABLE_SEGMENTS)
    );

    let spacing, can_fit;
    {
        const total_space = arc_len_table[arc_len_table.length - 1];
        can_fit = Math.floor(total_space / desired_spacing);
        spacing = total_space / can_fit;
    }
    const pad = desired_spacing - spacing;

    const evenly_spaced = [];

    let last_t = 0;
    for (let i = 1; i < can_fit; i++) {
        const desired_arc_len = i * spacing + pad/2;

        let min = last_t;
        let max = 1;
        let mid;
        for (let i = 0; i < 4096; i++) {
            mid = lerp(min, max, 0.5);
            const mid_arc_len = arc_len_of_t(mid);

            if (desired_arc_len < mid_arc_len) {
                max = mid;
            } else {
                min = mid;
            }

            if (Math.abs(mid_arc_len - desired_arc_len) < 0.01)
                break;
        }
        last_t = mid;

        evenly_spaced.push(catmull(p0, p1, p2, p3, mid, alpha));
    }

    return evenly_spaced;
}

/* sauce: https://iquilezles.org/articles/distfunctions2d/ */
function sd_segment(p, a_x, a_y, b_x, b_y) {
    const pa_x = p.x-a_x;
    const pa_y = p.y-a_y;
    const ba_x = b_x-a_x;
    const ba_y = b_y-a_y;

    let h = (pa_x*ba_x+pa_y*ba_y)/(ba_x*ba_x+ba_y*ba_y)
    h = Math.max(0, h);
    h = Math.min(1, h);

    const dx = pa_x - ba_x*h;
    const dy = pa_y - ba_y*h;
    return Math.sqrt(dx*dx + dy*dy);
}

/* 
 * I somehow translated this from GLSL to JS wrong.
 *
 * could debug it by using it in a nested for loop to rasterize an image,
 * comparing results to the shader.
 *
 * function sd_oriented_box(p, a_x, a_y, b_x, b_y, th) {
 *     const l = Math.sqrt((b_x - a_x)*(b_x - a_x) +
 *                         (b_y - a_y)*(b_y - a_y));
 *     const d_x = (b_x-a_x)/l;
 *     const d_y = (b_y-a_y)/l;

 *     let q_x = p.x - (a_x+b_x)*0.5;
 *     let q_y = p.y - (a_y+b_y)*0.5;

 *     {
 *         let x = q_x, y = a_y;
 *         q_x = d_x*x + -d_y*y;
 *         q_y = d_y*x +  d_x*y;
 *     }

 *     q_x = Math.abs(q_x)- l*0.5;
 *     q_y = Math.abs(q_y)-th*0.5;

 *     const _q_x = Math.max(q_x, 0);
 *     const _q_y = Math.max(q_y, 0);
 *     return Math.sqrt(_q_x*_q_x + _q_y*_q_y) + Math.min(Math.max(q_x,q_y), 0.0);
 * }
 */

function ray_hit_plane(
    out,

    ray_origin_x, ray_origin_y, ray_origin_z,
    ray_vector_x, ray_vector_y, ray_vector_z,

    plane_origin_x, plane_origin_y, plane_origin_z,
    plane_vector_x, plane_vector_y, plane_vector_z
) {
    const delta_x = plane_origin_x - ray_origin_x;
    const delta_y = plane_origin_y - ray_origin_y;
    const delta_z = plane_origin_z - ray_origin_z;

    const ldot = delta_x*plane_vector_x +
                 delta_y*plane_vector_y +
                 delta_z*plane_vector_z ;

    const rdot = ray_vector_x*plane_vector_x +
                 ray_vector_y*plane_vector_y +
                 ray_vector_z*plane_vector_z ;

    const d = ldot / rdot;
    out[0] = ray_origin_x + ray_vector_x * d;
    out[1] = ray_origin_y + ray_vector_y * d;
    out[2] = ray_origin_z + ray_vector_z * d;

    return out;
}

function ease_out_circ(x) { return Math.sqrt(1 - Math.pow(x - 1, 2)); }
function unit_clamp(p) { return Math.max(0, Math.min(1, p)); }
function inv_lerp(min, max, p) { return (p - min) / (max - min); }
function lerp(v0, v1, t) { return (1 - t) * v0 + t * v1; }
function lerp_rads(a, b, t) {
    const fmodf = (l, r) => l % r;
    let difference = fmodf(b - a, Math.PI*2.0),
          distance = fmodf(2.0 * difference, Math.PI*2.0) - difference;
    return a + distance * t;
}

    </script>
  </body>
</html>
