<!-- vim: sw=4 ts=4 expandtab smartindent ft=javascript
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WebGL Demo</title>
    <style> document, body { margin: 0px; padding: 0px; overflow: hidden; } </style>
  </head>

  <body>
    <canvas id="glcanvas"></canvas>
    <script>
"use strict";

const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl2', {antialias: true});
const gl_anisotropy =
  gl.getExtension("EXT_texture_filter_anisotropic") ||
  gl.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
  gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
if (!gl) { alert('Failed to initialize WebGL'); }

(window.onresize = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    /* account for e.g. high-retina macbook screens */
    if (window.devicePixelRatio > 1) {
        canvas.style.width = `${canvas.width}px`;
        canvas.style.height = `${canvas.height}px`;
        canvas.width *= window.devicePixelRatio;
        canvas.height *= window.devicePixelRatio;
    }

    gl.viewport(
        0,
        0,
        canvas.width,
        canvas.height
    );
})();

const SHADER_FLAG_NONE     = 0;
const SHADER_FLAG_GREENIFY = 1;

const LAYER_PLAYER  = 1;
const LAYER_ENEMIES = 2;


/* used especially in the rendering functions */
const AXIS_FLAT   = 0;
const AXIS_SPRITE = 1; /* up, but tilted back slightly to face camera */


const ATLAS_CHARS = [];
const ATLAS_NINJA   = (ATLAS_CHARS.push('ü•∑'), ATLAS_CHARS.length - 1);
const ATLAS_BLOOD   = (ATLAS_CHARS.push('ü©∏'), ATLAS_CHARS.length - 1);
const ATLAS_MOON    = (ATLAS_CHARS.push('üåï'), ATLAS_CHARS.length - 1);
const ATLAS_CLOVER  = (ATLAS_CHARS.push('‚òòÔ∏è'),  ATLAS_CHARS.length - 1);
const ATLAS_BAMBOO  = (ATLAS_CHARS.push('üéã'), ATLAS_CHARS.length - 1);
const ATLAS_TREE    = (ATLAS_CHARS.push('üå≥'), ATLAS_CHARS.length - 1);
const ATLAS_KNIFE   = (ATLAS_CHARS.push('üî™'), ATLAS_CHARS.length - 1);
const ATLAS_CARROT  = (ATLAS_CHARS.push('ü•ï'), ATLAS_CHARS.length - 1);
const ATLAS_THREAD  = (ATLAS_CHARS.push('üßµ'), ATLAS_CHARS.length - 1);
const ATLAS_DOOR    = (ATLAS_CHARS.push('üö™'), ATLAS_CHARS.length - 1);


const ATLAS_SIZE = Math.ceil(Math.sqrt(ATLAS_CHARS.length)); /* in emoji */
const EMOJI_SIZE = 1 << 8;

const CAMERA_CONTROLS_ACTIVE = false;
const LAST_ACTION_KEY   = 0;
const LAST_ACTION_MOUSE = 1;

const DEFAULT_PITCH =  Math.PI*0.50;
const DEFAULT_YAW   = -Math.PI*0.25;
const DEFAULT_ZOOM  = 25;
let input = {
    /* mousewheel input is damped here before ending up in "zoom" */ 
    scroll: 0,
    /* drags are damped here before ending up in pitch/yaw (lmb) or cam_pivot (rmb) */
    dampedEvent: { button: 0, movementX: 0, movementY: 0 },
    keysdown:    new Map(),
    last_action: LAST_ACTION_MOUSE,

    zoom: DEFAULT_ZOOM,

    pitch: DEFAULT_PITCH,
    yaw:   DEFAULT_YAW,
    eye: [0, 0, 0, 1],

    /* protip:
     * if you want to keep animations fluid and retain the ability to
     * switch between cutscenes, avoid reading from cam_pivot, only write into it.
     * treat it as an output which will be the position of the camera for this frame. */
    cam_pivot_x: 0,
    cam_pivot_y: 0,
    cam_pivot_z: 0,

    lmb_down: false, /* lmb =  left mouse button */
    rmb_down: false, /* rmb = right mouse button */
    mouse_x:  0,
    mouse_y:  0,

    vp        : mat4_create(),
    vp_inv    : mat4_create(),
    vp_skydome: mat4_create(),

    /* writes to the vp matrices  */
    camera_construct() {
        const FIELD_OF_VIEW = 50 / 180 * Math.PI;
        const ar = window.innerWidth / window.innerHeight;
        const projection = mat4_perspective(mat4_create(), FIELD_OF_VIEW, ar, 0.01, 1000.0);

        const view_skydome = mat4_create();
        {
            const view = view_skydome;

            const eye = [70, 0, 0, 1];
            {
                mat4_from_z_rotation(mat4_scratch, input.pitch + Math.PI*0.5);
                mat4_mul(view, view, mat4_scratch);

                // mat4_from_y_rotation(scratch, input.yaw + Math.PI*0.12);
                mat4_from_y_rotation(mat4_scratch, input.yaw);
                mat4_mul(view, view, mat4_scratch);

                mat4_transform_vec4(eye, eye, view);
            }

            mat4_target_to(view, eye, [0, 0, 1], [0, 0, 1]);
            mat4_invert(view, view);
        }


        const view = mat4_create();
        {
            const eye = input.eye = [input.zoom, 0, 0, 1];
            {
                mat4_from_z_rotation(mat4_scratch, input.pitch);
                mat4_mul(view, view, mat4_scratch);

                mat4_from_y_rotation(mat4_scratch, input.yaw);
                mat4_mul(view, view, mat4_scratch);

                mat4_transform_vec4(eye, eye, view);
            }

            eye[0] += input.cam_pivot_x;
            eye[1] += input.cam_pivot_y;
            eye[2] += input.cam_pivot_z;
            mat4_target_to(
                view,
                eye,
                [input.cam_pivot_x, input.cam_pivot_y, input.cam_pivot_z],
                [                0,                 0,                 1]
            );
            mat4_invert(view, view);
        }

        mat4_mul(
            input.vp_skydome,
            mat4_perspective(mat4_create(), FIELD_OF_VIEW, ar, 0.01, 10000.0),
            view_skydome
        );
        mat4_mul(input.vp, projection, view);
        mat4_invert(input.vp_inv, input.vp);
    },

    camera_controls() {
        const ev = input.dampedEvent;

        /* based on the assumption that if you're zoomed in more,
         * you're doing finer-detailed work and want more precise movements. */
        const zoom_fudge = 2;// Math.sqrt(input.zoom/10.0)*2.0;

        if (ev.button == 0) {
            input.pitch -= ev.movementX * 0.0005 * zoom_fudge;
            input.yaw   -= ev.movementY * 0.0005 * zoom_fudge;
            input.yaw = Math.max(-Math.PI*0.5 + 0.01, Math.min(Math.PI*0.5 - 0.01, input.yaw));
        }
        if (ev.button == 2) {
            const unit = [0, -ev.movementX*0.00075*zoom_fudge, ev.movementY*0.00075*zoom_fudge, 1];
            {
                const view    = mat4_create();
                const mat4_scratch = mat4_create();

                mat4_from_z_rotation(mat4_scratch, input.pitch);
                mat4_mul(view, view, mat4_scratch);

                mat4_from_y_rotation(mat4_scratch, input.yaw);
                mat4_mul(view, view, mat4_scratch);

                mat4_transform_vec4(unit, unit, view);
            }

            input.cam_pivot_x += unit[0] * input.zoom/20;
            input.cam_pivot_y += unit[1] * input.zoom/20;
            input.cam_pivot_z += unit[2] * input.zoom/20;
        }

        ev.movementX *= Math.pow(1 - 0.17, 60*delta_time);
        ev.movementY *= Math.pow(1 - 0.17, 60*delta_time);

        {
            const t = Math.cbrt(Math.abs(input.scroll)) * Math.sign(input.scroll);

            input.zoom += 0.005*t*input.zoom;
            input.scroll *= Math.pow(1 - 0.5, 60*delta_time);
            input.zoom = Math.min(200, input.zoom);
        }
    },

    mouse_to_ground(height = 0, vec=[0, 0, 0, 1]) {
        const eye = input.eye;
        vec[0] = -1 + (input.mouse_x / canvas.width )*2;
        vec[1] = +1 - (input.mouse_y / canvas.height)*2;
        vec[2] = 1;
        vec[3] = 1;

        mat4_transform_vec4(vec, vec, input.vp_inv);
        vec[0] /= vec[3];
        vec[1] /= vec[3];
        vec[2] /= vec[3];

        ray_hit_plane(
            vec,
                     eye[0],          eye[1],          eye[2], /* ray origin */
            vec[0] - eye[0], vec[1] - eye[1], vec[2] - eye[2], /* ray vector */

            0, 0, height, /* plane origin */
            0, 0,      1  /* plane vector */
        );

        return vec;
    }
};

/* key handling */
{
    function set_key(key, down) {
        input.last_action = LAST_ACTION_KEY;
        input.keysdown.set(key, down);
    }
    window.addEventListener('keydown', e => set_key(e.key, true ));
    window.addEventListener('keyup',   e => set_key(e.key, false));
}

/* mouse controls */
{
    const opts = { passive: false };

    window.addEventListener('wheel', e => {
        e.preventDefault();

        if (input.mouse_down) return;
        input.scroll += e.deltaY;
    }, opts);
    window.addEventListener('mousedown', ev => {
        ev.preventDefault();

        if (CAMERA_CONTROLS_ACTIVE) input.last_action = LAST_ACTION_MOUSE;
        input.dampedEvent.button = ev.button ? 2 : 0;

        if (ev.button == 0) input.lmb_down = true;
        if (ev.button == 2) input.rmb_down = true;
    }, opts);
    window.addEventListener('mousemove', ev => {
        ev.preventDefault();

        if (input.lmb_down || input.rmb_down) {
            input.dampedEvent.movementX += ev.movementX;
            input.dampedEvent.movementY += ev.movementY;
        }

        input.mouse_x = ev.offsetX*window.devicePixelRatio;
        input.mouse_y = ev.offsetY*window.devicePixelRatio;
    }, opts);
    window.addEventListener("contextmenu", ev => {
        ev.preventDefault();
    }, opts);
    window.addEventListener('mouseup', ev => {
        ev.preventDefault();

        if (ev.button == 0) input.lmb_down = false;
        if (ev.button == 2) input.rmb_down = false;
    }, opts);
}

/* touch controls */
{
    const opts = { passive: false };

    let touch_x = 0;
    let touch_y = 0;
    window.addEventListener("touchstart", ev => {
        ev.preventDefault();

        touch_x = ev.changedTouches[0].clientX;
        touch_y = ev.changedTouches[0].clientY;

        input.lmb_down = true;
    }, opts);

    window.addEventListener("touchmove", ev => {
        ev.preventDefault();
        input.dampedEvent.button = 0;

        input.dampedEvent.movementX += ev.changedTouches[0].clientX - touch_x;
        input.dampedEvent.movementY += ev.changedTouches[0].clientY - touch_y;

        touch_x = ev.changedTouches[0].clientX;
        touch_y = ev.changedTouches[0].clientY;
    }, opts);

    window.addEventListener("touchend", ev => {
        ev.preventDefault();

        input.lmb_down = false;
    }, opts);
}

/* GPU geometry buffers */
const buf = {
    geo_v_pos: gl.createBuffer(),
    geo_v_uv:  gl.createBuffer(),
    geo_i:     gl.createBuffer(),

    skydome_v_pos: gl.createBuffer(),
    skydome_v_uv:  gl.createBuffer(),
    skydome_i:     gl.createBuffer(),
};

let shaders;
/* compile shaders */
{
    const vs_blur = `#version 300 es
        precision mediump float;

        out vec2 v_texcoord;

        void main(void) {
            float x = float((gl_VertexID & 1) << 2);
            float y = float((gl_VertexID & 2) << 1);
            v_texcoord.x = x * 0.5;
            v_texcoord.y = y * 0.5;
            gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);
        }
    `;

    const fs_blur = `#version 300 es
        precision mediump float;

        uniform sampler2D u_texture;
        uniform vec2 u_direction;

        in vec2 v_texcoord;

        out vec4 frag_color;

        void main(void) {
            vec2 one_pixel = u_direction*(vec2(1) / vec2(textureSize(u_texture, 0)));

            frag_color = texture(u_texture, v_texcoord) * 0.2270270270;

            frag_color += texture(u_texture, v_texcoord + one_pixel    ) * 0.1945945946;
            frag_color += texture(u_texture, v_texcoord - one_pixel    ) * 0.1945945946;

            frag_color += texture(u_texture, v_texcoord + one_pixel*2.0) * 0.1216216216;
            frag_color += texture(u_texture, v_texcoord - one_pixel*2.0) * 0.1216216216;

            frag_color += texture(u_texture, v_texcoord + one_pixel*3.0) * 0.0540540541;
            frag_color += texture(u_texture, v_texcoord - one_pixel*3.0) * 0.0540540541;

            frag_color += texture(u_texture, v_texcoord + one_pixel*4.0) * 0.0162162162;
            frag_color += texture(u_texture, v_texcoord - one_pixel*4.0) * 0.0162162162;
        }
    `;

    const vs_skydome = 
        'attribute vec3 a_pos;' +
        'attribute vec2 a_uv;' +

        'uniform mat4 u_matrix;' +

        'varying vec2 v_uv;' +

        'void main() {' +
            'gl_Position = u_matrix * vec4(a_pos.xyz, 1);' +
            'v_uv = a_uv;' +
        '}';

    const fs_skydome = 
        'precision mediump float;' +

        'uniform sampler2D u_texture;' +

        'varying vec2 v_uv;' +

        'void main() {' +
            'gl_FragColor = 0.4 * texture2D(u_texture, v_uv);' +
        '}';

    const vs_geo = `
        uniform mat4 u_matrix;

        attribute vec3 a_pos;
        attribute vec4 a_uv;

        varying vec4 v_uv;

        void main() {
            gl_Position = u_matrix * vec4(a_pos.xyz, 1);
            v_uv = a_uv;
        }`;

    const fs_geo = `
        precision mediump float;

        uniform sampler2D u_texture;

        varying vec4 v_uv;

        void main() {
            vec4 color = vec4(0);
            if (v_uv.x < 0.0) {
                color = texture2D(u_texture, abs(v_uv.xy));
                color *= v_uv.w;
                
                if (v_uv.z == ${SHADER_FLAG_GREENIFY.toFixed(2)}) {
                    color.xyz /= color.w;
                    float gray = 0.21 * color.r + 0.71 * color.g + 0.07 * color.b;
                    color.xyz = 0.8*gray*vec3(0.58, 0.75, 0.35);
                    color.xyz *= color.w;
                }
                
                if (color.w == 0.0) discard;
            } else {
                color = v_uv;
            }
            // gl_FragColor = vec4(vec3(0.4), 1.0)*color;
            gl_FragColor = color;
        }`;

    function createProgram(gl, vertexSource, fragmentSource) {
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        const program = gl.createProgram();

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);

        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error(gl.getProgramInfoLog(program));
        }

        const wrapper = {program};

        const numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (let i = 0; i < numAttributes; i++) {
            const attribute = gl.getActiveAttrib(program, i);
            wrapper[attribute.name] = gl.getAttribLocation(program, attribute.name);
        }
        const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < numUniforms; i++) {
            const uniform = gl.getActiveUniform(program, i);
            wrapper[uniform.name] = gl.getUniformLocation(program, uniform.name);
        }

        return wrapper;
    }


    shaders = {
        geo:     createProgram(gl, vs_geo    , fs_geo    ),
        skydome: createProgram(gl, vs_skydome, fs_skydome),
        blur:    createProgram(gl, vs_blur   , fs_blur   )
    }
}

/* creating spritesheet, uploading to GPU */
let atlas = gl.createTexture();
{
    const canvas = document.createElement("canvas");

    canvas.width = canvas.height = ATLAS_SIZE * EMOJI_SIZE;

    const ctx = canvas.getContext("2d");

    let X_FUDGE = -0.1*EMOJI_SIZE;
    if (navigator.platform.indexOf("Mac") === 0 || navigator.platform === "iPhone") X_FUDGE = 0;

    {
        const PAD = EMOJI_SIZE*0.1;
        ctx.font = (EMOJI_SIZE - PAD*2) + 'px sans-serif';

        let i = 0;
        for (const char of ATLAS_CHARS) {
            const x = (           i % ATLAS_SIZE ) * EMOJI_SIZE;
            const y = (Math.floor(i / ATLAS_SIZE)) * EMOJI_SIZE;

            ctx.fillText(
                char,
                x + PAD + X_FUDGE,
                y + EMOJI_SIZE - PAD*2
            );

            i++;
        }
    }

    gl.bindTexture(gl.TEXTURE_2D, atlas);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
    gl.texImage2D(
        /* target         */ gl.TEXTURE_2D,
        /* level          */ 0,
        /* internalformat */ gl.RGBA,
        /* width          */ canvas.width,
        /* height         */ canvas.height,
        /* border,        */ 0,
        /* format,        */ gl.RGBA,
        /* type,          */ gl.UNSIGNED_BYTE,
        /* data           */ canvas
    );
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    if (gl_anisotropy) {
        const max = gl.getParameter(gl_anisotropy.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        gl.texParameterf(gl.TEXTURE_2D, gl_anisotropy.TEXTURE_MAX_ANISOTROPY_EXT, max);
    }
}

/* uploading skydome texture to GPU
 * TODO: blur it */
let tex_skydome = gl.createTexture();
let tex_skydome_loaded  = false;
let tex_skydome_blurred = false;
(async () => {
    const img = new Image();
    img.src = 'garden_hdri.jpg';
    await new Promise(res => img.onload = res);

    const canvas = document.createElement("canvas");
    canvas.width  = img.width;
    canvas.height = img.height;
    canvas.getContext("2d").drawImage(img, 0, 0);

    gl.bindTexture(gl.TEXTURE_2D, tex_skydome);
    gl.texImage2D(
        /* target         */ gl.TEXTURE_2D,
        /* level          */ 0,
        /* internalformat */ gl.RGBA,
        /* width          */ canvas.width,
        /* height         */ canvas.height,
        /* border,        */ 0,
        /* format,        */ gl.RGBA,
        /* type,          */ gl.UNSIGNED_BYTE,
        /* data           */ canvas
    );
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    return;
    {
        let render_targets = [
            { tex: null, fb: null },
            { tex: null, fb: null },
        ];

        /* create scene-sized render-target for post-processing fx (like shadows) */
        for (const target of render_targets) {
            target.tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, target.tex);

            // define size and format of level 0
            gl.texImage2D(
                gl.TEXTURE_2D,
                /* level,          */ 0,
                /* internalFormat, */ gl.RGBA,
                /* width,          */ canvas.width,
                /* height,         */ canvas.height,
                /* border,         */ 0,
                /* format,         */ gl.RGBA,
                /* type,           */ gl.UNSIGNED_BYTE,
                /* data            */ null
            );

            // set the filtering so we don't need mips
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            target.fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.tex, 0);
        }

        gl.deleteTexture(    target.tex);
        gl.deleteFramebuffer(target.fb );
    }

    tex_skydome_loaded = true;
})();

/* generate skydome geometry */
{
    const geo_idx = [];
    const geo_pos = [];
    const geo_uv  = [];
    {
        const WIDTH_SEGMENTS  = 1 << 6;
        const HEIGHT_SEGMENTS = 1 << 5;
        const RADIUS          = 100;

        const grid = [];
        let index = 0;
        for (let iy = 0; iy <= HEIGHT_SEGMENTS; iy++) {
            const v = iy / HEIGHT_SEGMENTS;

            /* poles */
            let u_offset = 0;
            if (iy == 0              ) u_offset =   0.5 / WIDTH_SEGMENTS;
            if (iy == HEIGHT_SEGMENTS) u_offset = - 0.5 / WIDTH_SEGMENTS;

            for (let ix = 0; ix <= WIDTH_SEGMENTS; ix++) {
                const u = ix / WIDTH_SEGMENTS;

                geo_uv.push(u + u_offset, 1 - v);

                geo_pos.push(
                    RADIUS * -Math.cos(u * Math.PI*2) * Math.sin(v * Math.PI),
                    RADIUS *  Math.sin(u * Math.PI*2) * Math.sin(v * Math.PI),
                    RADIUS * -Math.cos(v * Math.PI)
                );

                grid.push(index++);
            }
        }

        for (let iy = 0; iy < HEIGHT_SEGMENTS; iy++) {
            for (let ix = 0; ix < WIDTH_SEGMENTS; ix++) {
                const a = grid[(iy    )*(WIDTH_SEGMENTS + 1) + ix + 1];
                const b = grid[(iy    )*(WIDTH_SEGMENTS + 1) + ix    ];
                const c = grid[(iy + 1)*(WIDTH_SEGMENTS + 1) + ix    ];
                const d = grid[(iy + 1)*(WIDTH_SEGMENTS + 1) + ix + 1];

                if (iy !== 0                  ) geo_idx.push(a, b, d);
                if (iy !== HEIGHT_SEGMENTS - 1) geo_idx.push(b, c, d);
            }
        }
    }

    {
        gl.bindBuffer(gl.ARRAY_BUFFER, buf.skydome_v_pos);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo_pos), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, buf.skydome_v_uv);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo_uv), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.skydome_i);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geo_idx), gl.STATIC_DRAW);
    }

    buf.skydome_i_count = geo_idx.length;
}

let delta_time;
let last_timestamp;

const save = {

    cutscene_active: false,

    player: {
        // pos: { x: 0, y: 0 },
        pos: { x: -70, y: 0 },
        vel: { x: 0, y: 0 },
        wep: false,
        last_shot_timestamp: 0,

        /* player has its own copy of this data (also found in input) so that cutscene
         * taking over doesn't have to interfere with the player controller. */
        damped_cam_pivot_x: 0,
        damped_cam_pivot_y: 0,

        pos_z() {
            return save.platform.height_at(save.player.pos);
        },

        update() {
            save.bullet.for_collisions(
                save.bullets,
                LAYER_PLAYER,
                this.pos,
                0.95,
                bullet => {
                    const angle = Math.atan2(bullet.dir.y, bullet.dir.x);
                    save.flinch.trigger(angle);

                    save.player.vel.x += 0.18*bullet.dir.x;
                    save.player.vel.y += 0.18*bullet.dir.y;

                    return true;
                }
            );
        },

        draw({ pushImgUV, pushSpriteXYZ }) {
            const z = this.pos_z();
            pushImgUV(ATLAS_NINJA);
            pushSpriteXYZ(
                save.player.pos.x,
                save.player.pos.y,
                z,
                1,
            );

            if (save.player.wep) {
                /* speed is the length of velocity */
                const vl = Math.sqrt(save.player.vel.x*save.player.vel.x +
                                     save.player.vel.y*save.player.vel.y) * (!save.cutscene_active);
                const drag = Math.min(0.07, vl);
                const breathe = Math.sin(last_timestamp * 80 / 35.0) / 30;
                const jog = Math.sin(last_timestamp * 80 / 6.85) * Math.min(vl, 0.175);

                const wep_x = 0.55 * + breathe / 3.2 + jog * 1.5 * + drag;
                const wep_y = (breathe + jog) / 2.8 + drag * 0.5;

                //pushImgUV(ATLAS_KNIFE, 0, 1, 1, 1);
                pushImgUV(ATLAS_CARROT, 0, 1, 0, 1);

                pushSpriteXYZ(
                     save.player.pos.x - 0.5 + wep_x,
                     save.player.pos.y + 0.1 + wep_y,
                     z + 0.2,
                     0.4,
                );
            }
        },

        controls_aiming() {
            if (!save.player.wep) return;
            if (!input.lmb_down) return;
            if ((last_timestamp - this.last_shot_timestamp) < 0.5) return;

            const mouse = input.mouse_to_ground(1);

            this.last_shot_timestamp = last_timestamp;
            const dx = mouse[0] - save.player.pos.x;
            const dy = mouse[1] - save.player.pos.y;
            const angle = Math.atan2(dy, dx);
            save.bullets.push({
                layer: LAYER_ENEMIES,
                z: 1 + this.pos_z(),
                pos: { x: this.pos.x, y: this.pos.y },
                dir: { x: Math.cos(angle), y: Math.sin(angle) },
                range: 10,
                speed: 20,
                sprite: ATLAS_CARROT
            });
        },

        controls_movement() {
            let movement_x = (input.keysdown.get("a") ?? 0) - (input.keysdown.get("d") ?? 0);
            let movement_y = (input.keysdown.get("s") ?? 0) - (input.keysdown.get("w") ?? 0);
            if (Math.abs(movement_x) > 0 || Math.abs(movement_y) > 0) {
                const movement_len = Math.sqrt(movement_x*movement_x + movement_y*movement_y);
                movement_x /= movement_len;
                movement_y /= movement_len;
            }

            save.player.vel.x += movement_x*0.03;
            save.player.vel.y += movement_y*0.03;
            save.player.vel.x *= 0.85;
            save.player.vel.y *= 0.85;

            const p = { x: save.player.pos.x, y: save.player.pos.y };

            const SPEED = 0.02;
            p.x += movement_x*SPEED + save.player.vel.x;
            p.y += movement_y*SPEED + save.player.vel.y;

            /* platform collision
             * - weird combination of SAT and SDFs */
            {
                let next_p_x = save.player.pos.x;
                let next_p_y = save.player.pos.y;
                const axes = [{ x: save.player.pos.x, y: p.y }, { x: p.x, y: save.player.pos.y }];
                for (let i = 0; i < axes.length; i++) {
                    const o = axes[i];

                    /* how far you're trying to go */
                    let moved_dist = Math.sqrt((save.player.pos.x - o.x)*(save.player.pos.x - o.x) +
                                               (save.player.pos.y - o.y)*(save.player.pos.y - o.y));

                    /* how far you can go w/o hitting something */
                    let max_dist = save.platform.collision(o);

                    const min = Math.min(-max_dist, moved_dist);

                    const cut_dist = Math.abs(min - moved_dist);

                    /* here we address an edge case where the user gets stuck in a wall
                     * we get the normal of the surface and push them out. */
                    if (cut_dist > SPEED*0.9) {
                        let best_vec, best_vec_dist = Infinity;
                        for (let j = 0; j < 2; j++) {
                            const perp = axes[j];
                            const perp_backwards = {
                                x: save.player.pos.x - (perp.x - save.player.pos.x),
                                y: save.player.pos.y - (perp.y - save.player.pos.y)
                            };
                            for (const p of [perp, perp_backwards]) {
                                const dist = save.platform.collision(p);
                                if (dist < best_vec_dist) {
                                    best_vec_dist = dist;
                                    best_vec = p;
                                }
                            }
                        }

                        if (best_vec) {
                            const dx = save.player.pos.x - best_vec.x;
                            const dy = save.player.pos.y - best_vec.y;
                            save.player.vel.x += dx * 0.1;
                            save.player.vel.y += dy * 0.1;
                        }
                    }

                    let dx = o.x - save.player.pos.x;
                    let dy = o.y - save.player.pos.y;

                    if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
                        const d_len = Math.sqrt(dx*dx + dy*dy);
                        dx /= d_len;
                        dy /= d_len;

                        next_p_x += dx*min;
                        next_p_y += dy*min;
                    }
                }
                save.player.pos.x = next_p_x;
                save.player.pos.y = next_p_y;
            }

            if (input.last_action == LAST_ACTION_KEY) {
                const t = Math.pow(1 - 0.95, 60*delta_time);
                this.damped_cam_pivot_x = input.cam_pivot_x = lerp(this.damped_cam_pivot_x, save.player.pos.x, t);
                this.damped_cam_pivot_y = input.cam_pivot_y = lerp(this.damped_cam_pivot_y, save.player.pos.y, t);

                input.pitch = lerp(input.pitch, DEFAULT_PITCH, t);
                input.yaw   = lerp(input.yaw  , DEFAULT_YAW,   t);
            }
        }
    },

    bullets: [],
    bullet: {
        update(bullets) {
            for (let i = 0; i < bullets.length; i++) {
                const bullet = bullets[i];

                bullet.pos.x += bullet.speed * bullet.dir.x * delta_time;
                bullet.pos.y += bullet.speed * bullet.dir.y * delta_time;
                bullet.range -= bullet.speed * delta_time;

                if (bullet.range < 0) bullets.splice(i--, 1);
            }
        },
        
        draw({ pushImgUV, pushFlatXYZ }, bullet) {
            pushImgUV(bullet.sprite, 0, unit_clamp(inv_lerp(0.0, 1.5, bullet.range)));
            pushFlatXYZ(
                bullet.pos.x,
                bullet.pos.y,
                bullet.z,
                1,
                /* spin x10/second */
                (-last_timestamp * 10) % (Math.PI*2)
            );
        },
        
        for_collisions(bullets, layer, pos, radius, callback) {
            for (let i = 0; i < bullets.length; i++) {
                const bullet = bullets[i];
                if (!(bullet.layer & layer)) continue;

                const dx = bullet.pos.x - pos.x;
                const dy = bullet.pos.y - pos.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist > radius) continue;

                if (callback(bullet)) {
                    bullets.splice(i--, 1);
                }
            }
        }
    },

    particles: [],
    particle: {
        update(particles) {
            for (let i = 0; i < particles.length; i++) {
                const particle = particles[i];

                particle.pos.x += particle.speed * particle.dir.x * delta_time;
                particle.pos.y += particle.speed * particle.dir.y * delta_time;
                particle.range -= particle.speed * delta_time;

                particle.pos.z -= 2.0*delta_time;

                if (particle.range < 0) particles.splice(i--, 1);
            }
        },
        
        draw({ pushImgUV, pushSpriteXYZ }, particle) {
            pushImgUV(particle.sprite, 0, unit_clamp(inv_lerp(0.0, 1.5, particle.range)));
            pushSpriteXYZ(
                particle.pos.x,
                particle.pos.y,
                particle.z,
                particle.size,
            );
        },

        blood(particles, dir, pos, z = 0) {
            for (let i = 0; i < 15; i++) {
                const t = i / 15;
                const edge = 1 - 2 * Math.abs(t - 0.5);

                const randomness = 0.2 * edge;
                const base_range = Math.PI*0.8;
                const half = (randomness + base_range)*0.5;
                const angle = dir + (Math.random()*randomness + base_range*t) - half;
                particles.push({
                    z: 1 + z,
                    pos: {
                        x: pos.x - Math.cos(angle) * 0.2,
                        y: pos.y - Math.sin(angle) * 0.2
                    },
                    dir: {
                        x: Math.cos(angle),
                        y: Math.sin(angle)
                    },
                    range: (3 + 0.5*Math.random()) * lerp(1.0, 1.6, edge),
                    speed: (3 + 4.0*Math.random()) * lerp(1.0, 1.8, edge),
                    size: (0.1 + 0.1*Math.random()) * lerp(0.2, 1.0, edge),
                    sprite: ATLAS_BLOOD
                });
            }
        }
    },

    flinch: {
        timestamp: null,
        dir_x: 0,
        dir_y: 0,

        trigger(direction) {
            this.timestamp = last_timestamp;
            const angle = Math.random() * Math.PI * 2;
            this.dir_x = Math.cos(angle);
            this.dir_y = Math.sin(angle);

            save.particle.blood(
                save.particles,
                direction,
                save.player.pos,
                save.player.pos_z()
            );
        },

        t() {
            if (this.timestamp == null) return 0;
            let t = (last_timestamp - this.timestamp) / 1;

            if (t > 1.0) t = 0;

            return t;
        },

        camera() {
            let t = this.t();
            t = ease_out_circ(unit_clamp(t / 0.6));
            if (t == 0) return;

            input.pitch = lerp(DEFAULT_PITCH + 0.09*this.dir_x, DEFAULT_PITCH, t);
            input.yaw   = lerp(DEFAULT_YAW   + 0.09*this.dir_y,   DEFAULT_YAW, t);
        },

        draw({ geo }) {
            const t = this.t();
            if (t == 0) return;

            const size = 10000;
            const x = 0;
            const y = 0;
            const z = 0;

            {
                const rot_x = 1 * size;
                const rot_z = 0 * size;

                const vbuf_i = geo.pos.length / 3;

                geo.pos.push(x+rot_x, y + rot_z, z);
                geo.pos.push(x+rot_z, y - rot_x, z);
                geo.pos.push(x-rot_x, y - rot_z, z);
                geo.pos.push(x-rot_z, y + rot_x, z);

                geo.layer.push(1e6);
                geo.layer.push(1e6);

                geo.idx.push(vbuf_i + 0, vbuf_i + 1, vbuf_i + 2,
                             vbuf_i + 2, vbuf_i + 3, vbuf_i + 0);
            }

            {
                const opacity = 0.4 * (1 - t);
                const r = 1.0;
                const g = 0.1;
                const b = 0.1;
                geo.uv.push(
                    r*opacity, g*opacity, b*opacity, opacity,
                    r*opacity, g*opacity, b*opacity, opacity,
                    r*opacity, g*opacity, b*opacity, opacity,
                    r*opacity, g*opacity, b*opacity, opacity
                );
            }
        },
    },

    platform: {
        PICKUP_X: -65.8,
        PICKUP_Y:   0.0,
        pickup_get: false,
        pickup_get_timestamp: null,

        CUTSCENE_CENTER_X: -30,
        CUTSCENE_CENTER_Y: 0,
        move_earth_t: 0,
        pickup_get_t: 0,

        enemies_living: [true, true],

        for_circles(circle) {
            /*      x,  y,  size */
            circle(  2.0,   3.0,     7.0);
            circle( -4.0,   0.0,     9.0);
            circle(  2.0,  -3.0,     9.5);

            circle(-35.8,   0.0,     6.5);
            circle(-66.8,   0.0,     6.5);

            /* enemy platforms */
            this.for_enemies((_, x, y) => circle(x, y, 6.5), false);
        },

        for_enemies(enemy, only_living = true) {
            const t = this.move_earth_t;
            if (!only_living || this.enemies_living[0]) enemy(0, lerp(-25.0, -34.5, t), lerp(-15.0, -6.5, t));
            if (!only_living || this.enemies_living[1]) enemy(1, lerp(-45.0, -37.5, t), lerp( 12.5,  6.5, t));
        },

        for_bridges(bridge) {
            bridge({ path_from: -10, path_to: -29 });
            bridge({ path_from: -40, path_to: -60 });
        },

        camera_animate() {
            if (this.pickup_get_timestamp == null) return;

            /* we bite off bits of t and assign them to our animations */
            let t = last_timestamp - this.pickup_get_timestamp;
            let out_t = 0, back_t = 0;
            {
                if (t > 0) save.cutscene_active = true;

                /* one little pause right after they get the pickup */
                const PICKUP_GET_DURATION = 2.0;
                this.pickup_get_t = unit_clamp(t / PICKUP_GET_DURATION); t -= PICKUP_GET_DURATION;

                t -= 1;

                const OUT_DURATION = 1;
                out_t = unit_clamp(t / OUT_DURATION); t -= OUT_DURATION;

                /* small pauses before and after MOVE_EARTH */
                {
                    t -= 0.75;

                    const MOVE_EARTH_DURATION = 2;
                    this.move_earth_t = unit_clamp(t / MOVE_EARTH_DURATION); t -= MOVE_EARTH_DURATION;

                    t -= 1.75;
                }

                const BACK_DURATION = 1;
                back_t = unit_clamp(t / BACK_DURATION); t -= BACK_DURATION;

                /* pause at the end */
                t -= 0.75;
            }

            if (t > 0) {
                save.cutscene_active = false;
                return;
            }

            if (this.pickup_get_t >= 1) {
                save.player.wep = true;
                this.pickup_get = true;
            }

            if (out_t > 0) {
                input.zoom = lerp(DEFAULT_ZOOM,           70,  out_t);
                input.zoom = lerp(  input.zoom, DEFAULT_ZOOM, back_t);

                const p = save.player;
                input.cam_pivot_x = lerp(p.damped_cam_pivot_x, this.CUTSCENE_CENTER_X,  out_t);
                input.cam_pivot_y = lerp(p.damped_cam_pivot_y, this.CUTSCENE_CENTER_Y,  out_t);
                input.cam_pivot_x = lerp(   input.cam_pivot_x,   p.damped_cam_pivot_x, back_t);
                input.cam_pivot_y = lerp(   input.cam_pivot_y,   p.damped_cam_pivot_y, back_t);
            }
        },

        draw(ctx) {
            const { pushSpriteXYZ, pushImgUV, drawImg } = ctx;

            this.for_circles((x, y, size) => {
                drawImg(
                    AXIS_FLAT,
                    x, y,
                    size * 0.9,
                    ATLAS_MOON,
                    SHADER_FLAG_GREENIFY
                );
            });

            this.for_enemies((_, enemy_x, enemy_y) => {
                drawImg(AXIS_SPRITE, enemy_x, enemy_y, 1, ATLAS_NINJA);
            });

            drawImg(AXIS_SPRITE, -5, -3,  2.0, ATLAS_TREE);
            drawImg(AXIS_SPRITE,  2, -5,  4.0, ATLAS_TREE);
            drawImg(AXIS_SPRITE,  2,  7,  1.0, ATLAS_BAMBOO);
            drawImg(AXIS_SPRITE,  4,  5,  1.2, ATLAS_BAMBOO);

            if (!this.pickup_get) {
                let x = this.PICKUP_X;
                let y = this.PICKUP_Y + 0.2 + 0.2*Math.sin(last_timestamp*3);
                let z = 0;
                let opacity = 1;
                let scale = 1.0;

                {
                    let t = this.pickup_get_t;

                    const UP_DURATION = 0.2;
                    const up_t = unit_clamp(t / UP_DURATION); t -= UP_DURATION;

                    t -= 0.1;

                    const JUMP_DURATION = 0.4;
                    const jump_t = unit_clamp(t / JUMP_DURATION); t -= JUMP_DURATION;

                    x = lerp(x, save.player.pos.x, up_t);
                    y = lerp(y, save.player.pos.y, up_t);

                    z = 1.6*up_t;

                    const jump_saw_t = 1 - Math.abs(jump_t - 0.5)*2;
                    z = lerp(z, z+0.25, jump_saw_t);
                    scale *= 1 + jump_saw_t*0.2;

                    t -= 0.2;

                    if (t > 0) opacity = 1 - t / 0.1;
                }

                pushImgUV(ATLAS_CARROT, 0, opacity);
                pushSpriteXYZ(x, y, z, scale);
            }

            this.for_bridges((bridge) => {
                this.bridge.draw(bridge, ctx);
            });
        },

        collision(pos) {
            let min_dist = Infinity;

            this.for_circles((x, y, size) => {
                const dx = pos.x - x;
                const dy = pos.y - y;
                min_dist = Math.min(min_dist, Math.sqrt(dx*dx + dy*dy) - size*0.65);
            });

            this.for_bridges((bridge) => {
                min_dist = Math.min(min_dist, this.bridge.distance(bridge, pos));
            });

            return min_dist;
        },

        height_at(p) {
            let height = Infinity;

            this.for_bridges((bridge) => {
                const bridge_height = Math.min(0, 0.5 + this.bridge.height_at(bridge, p));
                height = Math.min(height, bridge_height);
            });

            return height;
        },

        bridge: {
            PLANK_SPACING: 3.6,
            BENDYNESS    : 0.4,

            plank_points(bridge) {
                let planks_min = Math.min(bridge.path_from, bridge.path_to)-3.5;
                let planks_max = Math.max(bridge.path_from, bridge.path_to)+2.5;
                let player_t = inv_lerp(planks_min+1, planks_max-1, save.player.pos.x);
                player_t = Math.min(1, Math.max(0, player_t));

                const control0 = [planks_min - 5, 5 + 30*(0 + player_t)];
                const control1 = [planks_max + 5, 5 + 30*(1 - player_t)];
                const start = [planks_min, 0];
                const end   = [planks_max, 0];
                const arg = { p0: control0, p1: start, p2: end, p3: control1, alpha: this.BENDYNESS };

                return catmull_uniformly_spaced(arg, this.PLANK_SPACING);
            },

            height_at(bridge, p) {
                let planks_min = Math.min(bridge.path_from, bridge.path_to)-3.5;
                let planks_max = Math.max(bridge.path_from, bridge.path_to)+2.5;
                let player_t = inv_lerp(planks_min+1, planks_max-1, p.x);
                player_t = Math.min(1, Math.max(0, player_t));

                const control0 = [planks_min - 5, 5 + 30*(0 + player_t)];
                const control1 = [planks_max + 5, 5 + 30*(1 - player_t)];
                const start = [planks_min, 0];
                const end   = [planks_max, 0];
                return catmull(control0, start, end, control1, player_t, this.BENDYNESS)[1];
            },

            /* distance from point to bridge */
            distance(bridge, p) {
                return sd_segment(
                    p,
                    bridge.path_from + 3, 0,
                    bridge.path_to   - 3, 0
                ) - 1.5;
            },

            draw(bridge, ctx) {
                const { geo, pushImgUV, drawImg } = ctx;

                let path_min = Math.min(bridge.path_from, bridge.path_to);
                let path_max = Math.max(bridge.path_from, bridge.path_to);


                /* add poles to each end of the bridge */
                for (let x = 0; x < 2; x += 1)
                    for (let y = -1; y <= 2; y += 2)
                        drawImg(
                            /* axis */ AXIS_SPRITE,
                            /* x, y */ lerp(path_min-1.5, path_max+0.5, x), 1.8*y,
                            /* size */ 1,
                            /* img  */ ATLAS_THREAD
                        );

                /* draw the planks */
                {
                    let last;
                    for (const p of this.plank_points(bridge)) {
                        if (!last) {
                            last = p;
                            continue;
                        }
                        pushImgUV(ATLAS_DOOR);

                        const size = 2.5;

                        let x0 = last[0];
                        let z0 = last[1];
                        let x1 = p   [0];
                        let z1 = p   [1];

                        /* we need to "expand" the vector that goes from x0,z0 to z1,x1 because
                         * the image doesn't fill 100% of the square. (the UVs aren't "tight") */
                        {
                            let dx = x1 - x0;
                            let dz = z1 - z0;
                            const d_len = Math.sqrt(dx*dx + dz*dz);
                            dx /= d_len;
                            dz /= d_len;

                            x0 -= dx;
                            z0 -= dz;
                            x1 += dx;
                            z1 += dz;
                        }

                        const vbuf_i = geo.pos.length / 3;
                        geo.pos.push(x0, -size, z0 + 1.0);
                        geo.pos.push(x1, -size, z1 + 1.0);
                        geo.pos.push(x1,  size, z1 + 1.0);
                        geo.pos.push(x0,  size, z0 + 1.0);
                        geo.layer.push(-1e6 - (z0 + z1));
                        geo.layer.push(-1e6 - (z0 + z1));

                        geo.idx.push(vbuf_i + 0, vbuf_i + 1, vbuf_i + 2,
                                     vbuf_i + 2, vbuf_i + 3, vbuf_i + 0);

                        last[0] = p[0];
                        last[1] = p[1];
                    }
                }
            }
        },

        update() {
            let i = 0;

            if (save.cutscene_active) return;

            this.for_enemies((idx, x, y) => {
                const pos = { x, y };

                const t = ~~(last_timestamp / delta_time) % 70;

                if (t == 0) {
                    const dx = save.player.pos.x - pos.x;
                    const dy = save.player.pos.y - pos.y;
                    const angle = Math.atan2(dy, dx);
                    save.bullets.push({
                        layer: LAYER_PLAYER,
                        z: 1,
                        pos,
                        /* using "sign" instead of "sin" here makes them slightly bad
                         * at aiming -- good for tutorial */
                        dir: { x: Math.cos(angle), y: Math.sign(angle) },
                        range: 25,
                        speed: 7,
                        sprite: ATLAS_KNIFE
                    });
                }

                save.bullet.for_collisions(
                    save.bullets,
                    LAYER_ENEMIES,
                    pos,
                    0.95,
                    bullet => {
                        const direction = Math.atan2(bullet.dir.y, bullet.dir.x);
                        save.particle.blood(save.particles, direction, pos, 1);
                        this.enemies_living[idx] = false;
                        return true;
                    }
                );
            });

            if (this.pickup_get_timestamp == null) {
                const dx = save.player.pos.x - this.PICKUP_X;
                const dy = save.player.pos.y - this.PICKUP_Y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 0.7) {
                    this.pickup_get_timestamp = last_timestamp;
                }
            }
        }
    },
};

requestAnimationFrame(function frame(timestamp) {
    requestAnimationFrame(frame);

    timestamp *= 0.001;
    last_timestamp ??= timestamp;
    delta_time = timestamp - last_timestamp;
    last_timestamp = timestamp;

    save.cutscene_active = false; /* if platform sets this to true in camera_animate, no e.g. movement or enemy AI occurs */
    save.platform.camera_animate();

    if (!save.cutscene_active) {
        save.player.controls_movement();
        save.player.controls_aiming();

        save.flinch.camera();
    }

    /* click and drag camera controls */
    if (CAMERA_CONTROLS_ACTIVE) input.camera_controls()

    input.camera_construct();

    /* rendering */
    const geo = {
        idx: [],
        pos: [],
        uv : [],

        /* this isn't uploaded to the GPU, but is used for sorting beforehand.
         *  per-triangle. */
        layer: []
    };

    /* filling the geo buffers */
    {
        /* don't use this without also pushing a pos; see drawImg */
        function pushImgUV(atlas_index, flag=0, opacity=1, flip_x=0, flip_y=0) {

            /* generate UVs from atlas_index */
            {
                const u = (           atlas_index % ATLAS_SIZE );
                const v = (Math.floor(atlas_index / ATLAS_SIZE));

                let min_x = (flip_x) ? 0.98 : 0.02;
                let max_x = (flip_x) ? 0.02 : 0.98;
                let min_y = (flip_y) ? 0.98 : 0.02;
                let max_y = (flip_y) ? 0.02 : 0.98;

                geo.uv.push(
                    -(u+max_x)/ATLAS_SIZE, -(v+max_y)/ATLAS_SIZE, flag, opacity,
                    -(u+min_x)/ATLAS_SIZE, -(v+max_y)/ATLAS_SIZE, flag, opacity,
                    -(u+min_x)/ATLAS_SIZE, -(v+min_y)/ATLAS_SIZE, flag, opacity,
                    -(u+max_x)/ATLAS_SIZE, -(v+min_y)/ATLAS_SIZE, flag, opacity
                );
            }
        }

        function pushFlatXYZ(x, y, z, size, rot=0) {
            const rot_x = Math.cos(rot) * size;
            const rot_z = Math.sin(rot) * size;

            const vbuf_i = geo.pos.length / 3;

            geo.pos.push(x+rot_x, y + rot_z, z);
            geo.pos.push(x+rot_z, y - rot_x, z);
            geo.pos.push(x-rot_x, y - rot_z, z);
            geo.pos.push(x-rot_z, y + rot_x, z);

            geo.layer.push(y);
            geo.layer.push(y);

            geo.idx.push(vbuf_i + 0, vbuf_i + 1, vbuf_i + 2,
                         vbuf_i + 2, vbuf_i + 3, vbuf_i + 0);
        }

        const back = Math.cos(Math.PI*0.25);
        function pushSpriteXYZ(x, y, z, size, rot=-Math.PI*0.25) {
            const center_x = x;
            const center_z = z + back*size;

            const vbuf_i = geo.pos.length / 3;

            geo.pos.push(center_x+size, y          , center_z - back*size);
            geo.pos.push(center_x-size, y          , center_z - back*size);
            geo.pos.push(center_x-size, y-back*size, center_z + back*size);
            geo.pos.push(center_x+size, y-back*size, center_z + back*size);

            geo.idx.push(vbuf_i + 0, vbuf_i + 1, vbuf_i + 2,
                         vbuf_i + 2, vbuf_i + 3, vbuf_i + 0);

            geo.layer.push(y);
            geo.layer.push(y);
        }

        function drawImg(axis, x, y, size, atlas_index, flag=0) {
            pushImgUV(atlas_index, flag);

            switch (axis) {
                case (AXIS_FLAT): {
                    const vbuf_i = geo.pos.length / 3;

                    geo.pos.push(x+size, y-size, 0.0);
                    geo.pos.push(x-size, y-size, 0.0);
                    geo.pos.push(x-size, y+size, 0.0);
                    geo.pos.push(x+size, y+size, 0.0);

                    geo.idx.push(vbuf_i + 0, vbuf_i + 1, vbuf_i + 2,
                                 vbuf_i + 2, vbuf_i + 3, vbuf_i + 0);

                    geo.layer.push(-1e6);
                    geo.layer.push(-1e6);
                }; break;

                case (AXIS_SPRITE): {
                    pushSpriteXYZ(x, y, 0, size);
                }; break;
            }

        }

        save.platform.update();
        save.player  .update();
        save.bullet  .update(save.bullets  );
        save.particle.update(save.particles);

        const ctx = { geo, pushFlatXYZ, pushSpriteXYZ, pushImgUV, drawImg };
        save.flinch.draw(ctx);
        save.bullets  .forEach(b => save.bullet  .draw(ctx, b));
        save.particles.forEach(b => save.particle.draw(ctx, b));
        save.platform.draw(ctx);

        save.player.draw(ctx);
    }

    /* sorting triangles for order-dependent transparency
     * there are probably very trivial ways to optimize this */
    {
        const tris = [];

        for (let i = 0; i < geo.idx.length; i += 3) {
            tris.push([
                [
                    geo.idx[i + 0],
                    geo.idx[i + 1],
                    geo.idx[i + 2]
                ],
                geo.layer[i / 3]
            ]);
        }

        tris.sort((a, b) => a[1] - b[1]);

        geo.idx = tris.map(x => x[0]).flat();
    }

    /* submitting geometry to the GPU */
    {
        /* no point in enabling depth since things need to be sorted anyway :thinking: */
        // gl.enable(gl.DEPTH_TEST);
        // gl.depthFunc(gl.LEQUAL);

        /* set up premultiplied alpha */
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);

        /* clear all */
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

        /* skydome pass */
        {
            gl.useProgram(shaders.skydome.program);
            gl.enableVertexAttribArray(shaders.skydome.a_pos);
            gl.enableVertexAttribArray(shaders.skydome.a_uv);

            gl.uniformMatrix4fv(shaders.skydome.u_matrix, false, input.vp_skydome);

            /* bind tex_skydome */
            {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex_skydome);
                gl.uniform1i(shaders.skydome.u_texture, 0);
            }

            /* bind geometry */
            {
                gl.bindBuffer(gl.ARRAY_BUFFER, buf.skydome_v_pos);
                gl.vertexAttribPointer(shaders.skydome.a_pos, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, buf.skydome_v_uv);
                gl.vertexAttribPointer(shaders.skydome.a_uv, 2, gl.FLOAT, true, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.skydome_i);
            }

            gl.drawElements(gl.TRIANGLES, buf.skydome_i_count, gl.UNSIGNED_SHORT, 0);
        }

        /* geo pass */
        {
            gl.useProgram(shaders.geo.program);
            gl.enableVertexAttribArray(shaders.geo.a_pos);
            gl.enableVertexAttribArray(shaders.geo.a_uv);

            gl.uniformMatrix4fv(shaders.geo.u_matrix, false, input.vp);

            /* upload/bind atlas */
            {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, atlas);
                gl.uniform1i(shaders.geo.u_texture, 0);
            }

            /* upload/bind geometry */
            {
                gl.bindBuffer(gl.ARRAY_BUFFER, buf.geo_v_pos);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo.pos), gl.STATIC_DRAW);
                gl.vertexAttribPointer(shaders.geo.a_pos, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, buf.geo_v_uv);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo.uv), gl.STATIC_DRAW);
                gl.vertexAttribPointer(shaders.geo.a_uv, 4, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.geo_i);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geo.idx), gl.STATIC_DRAW);
            }

            gl.drawElements(gl.TRIANGLES, geo.idx.length, gl.UNSIGNED_SHORT, 0);
        }
    }
})

/* math utils */

const mat4_scratch = mat4_create();

function mat4_create() {
    let out = new Float32Array(16);
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
}

function mat4_transform_vec4(out, a, m) {
    let x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
}

function mat4_mul(out, a, b) {
    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    /* Cache only the current line of the second matrix */
    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}

function mat4_target_to(out, eye, target, up=VEC3_UP) {
    let eyex = eye[0], eyey = eye[1], eyez = eye[2],
         upx =  up[0],  upy =  up[1],  upz =  up[2];
    let z0 = eyex - target[0],
        z1 = eyey - target[1],
        z2 = eyez - target[2];
    let len = z0 * z0 + z1 * z1 + z2 * z2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        z0 *= len;
        z1 *= len;
        z2 *= len;
    }
    let x0 = upy * z2 - upz * z1,
        x1 = upz * z0 - upx * z2,
        x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
}

function mat4_perspective(out, fovy, aspect, near, far) {
    let f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
    } else {
        out[10] = -1;
        out[14] = -2 * near;
    }
    return out;
}

function mat4_from_y_rotation(out, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    /* Perform axis-specific matrix multiplication */
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

function mat4_from_z_rotation(out, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    /* Perform axis-specific matrix multiplication */
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

function mat4_invert(out, a) {
    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    let b00 = a00 * a11 - a01 * a10;
    let b01 = a00 * a12 - a02 * a10;
    let b02 = a00 * a13 - a03 * a10;
    let b03 = a01 * a12 - a02 * a11;
    let b04 = a01 * a13 - a03 * a11;
    let b05 = a02 * a13 - a03 * a12;
    let b06 = a20 * a31 - a21 * a30;
    let b07 = a20 * a32 - a22 * a30;
    let b08 = a20 * a33 - a23 * a30;
    let b09 = a21 * a32 - a22 * a31;
    let b10 = a21 * a33 - a23 * a31;
    let b11 = a22 * a33 - a23 * a32;
    /* Calculate the determinant */
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
        return null;
    }
    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
}

function catmull(p0, p1, p2, p3, t, alpha=0.5) {
  function get_t(t, alpha, p0, p1) {
    const dx = p1[0] - p0[0];
    const dy = p1[1] - p0[1];
    const a = dx*dx + dy*dy; /* dot product */
    const b = Math.pow(a, alpha*0.5);
    return (b + t);
  }

  const t0 = 0.0;
  const t1 = get_t(t0, alpha, p0, p1);
  const t2 = get_t(t1, alpha, p1, p2);
  const t3 = get_t(t2, alpha, p2, p3);
  t = lerp(t1, t2, t);

  const A1_x = (t1 - t)/(t1 - t0)*p0[0] + (t - t0)/(t1 - t0)*p1[0];
  const A1_y = (t1 - t)/(t1 - t0)*p0[1] + (t - t0)/(t1 - t0)*p1[1];

  const A2_x = (t2 - t)/(t2 - t1)*p1[0] + (t - t1)/(t2 - t1)*p2[0];
  const A2_y = (t2 - t)/(t2 - t1)*p1[1] + (t - t1)/(t2 - t1)*p2[1];

  const A3_x = (t3 - t)/(t3 - t2)*p2[0] + (t - t2)/(t3 - t2)*p3[0];
  const A3_y = (t3 - t)/(t3 - t2)*p2[1] + (t - t2)/(t3 - t2)*p3[1];

  const B1_x = (t2 - t)/(t2 - t0)*A1_x + (t - t0)/(t2 - t0)*A2_x;
  const B1_y = (t2 - t)/(t2 - t0)*A1_y + (t - t0)/(t2 - t0)*A2_y;

  const B2_x = (t3 - t)/(t3 - t1)*A2_x + (t - t1)/(t3 - t1)*A3_x;
  const B2_y = (t3 - t)/(t3 - t1)*A2_y + (t - t1)/(t3 - t1)*A3_y;

  const C_x  = (t2 - t)/(t2 - t1)*B1_x + (t - t1)/(t2 - t1)*B2_x;
  const C_y  = (t2 - t)/(t2 - t1)*B1_y + (t - t1)/(t2 - t1)*B2_y;

  return [C_x, C_y];
}

function catmull_uniformly_spaced(catmull_args, desired_spacing) {
    catmull_args.alpha ??= 0.5;
    const { p0, p1, p2, p3, t, alpha } = catmull_args;

    const TABLE_SEGMENTS = 100;

    const arc_len_table = Array.from({ length: TABLE_SEGMENTS }, _ => 0);
    let last = catmull(p0, p1, p2, p3, 0, alpha);
    for (let last_len = 0, i = 0; i < (TABLE_SEGMENTS + 1); i++) {
        const t = i / TABLE_SEGMENTS;

        const p = catmull(p0, p1, p2, p3, t, alpha);
        const len = Math.sqrt((p[0] - last[0])*(p[0] - last[0]) +
                              (p[1] - last[1])*(p[1] - last[1]));
        arc_len_table[i] = last_len + len;
        last_len = len;
    }
    const arc_len_of_t = t => lerp(
        arc_len_table[Math.floor(t * TABLE_SEGMENTS)],
        arc_len_table[Math. ceil(t * TABLE_SEGMENTS)],
        (t * TABLE_SEGMENTS) - Math.floor(t * TABLE_SEGMENTS)
    );

    let spacing, can_fit;
    {
        const total_space = arc_len_table[arc_len_table.length - 1];
        can_fit = Math.floor(total_space / desired_spacing);
        spacing = total_space / can_fit;
    }
    const pad = desired_spacing - spacing;

    const evenly_spaced = [];

    let last_t = 0;
    for (let i = 1; i < can_fit; i++) {
        const desired_arc_len = i * spacing + pad/2;

        let min = last_t;
        let max = 1;
        let mid;
        for (let i = 0; i < 4096; i++) {
            mid = lerp(min, max, 0.5);
            const mid_arc_len = arc_len_of_t(mid);

            if (desired_arc_len < mid_arc_len) {
                max = mid;
            } else {
                min = mid;
            }

            if (Math.abs(mid_arc_len - desired_arc_len) < 0.01)
                break;
        }
        last_t = mid;

        evenly_spaced.push(catmull(p0, p1, p2, p3, mid, alpha));
    }

    return evenly_spaced;
}

/* sauce: https://iquilezles.org/articles/distfunctions2d/ */
function sd_segment(p, a_x, a_y, b_x, b_y) {
    const pa_x = p.x-a_x;
    const pa_y = p.y-a_y;
    const ba_x = b_x-a_x;
    const ba_y = b_y-a_y;

    let h = (pa_x*ba_x+pa_y*ba_y)/(ba_x*ba_x+ba_y*ba_y)
    h = Math.max(0, h);
    h = Math.min(1, h);

    const dx = pa_x - ba_x*h;
    const dy = pa_y - ba_y*h;
    return Math.sqrt(dx*dx + dy*dy);
}

/* 
 * I somehow translated this from GLSL to JS wrong.
 *
 * could debug it by using it in a nested for loop to rasterize an image,
 * comparing results to the shader.
 *
 * function sd_oriented_box(p, a_x, a_y, b_x, b_y, th) {
 *     const l = Math.sqrt((b_x - a_x)*(b_x - a_x) +
 *                         (b_y - a_y)*(b_y - a_y));
 *     const d_x = (b_x-a_x)/l;
 *     const d_y = (b_y-a_y)/l;

 *     let q_x = p.x - (a_x+b_x)*0.5;
 *     let q_y = p.y - (a_y+b_y)*0.5;

 *     {
 *         let x = q_x, y = a_y;
 *         q_x = d_x*x + -d_y*y;
 *         q_y = d_y*x +  d_x*y;
 *     }

 *     q_x = Math.abs(q_x)- l*0.5;
 *     q_y = Math.abs(q_y)-th*0.5;

 *     const _q_x = Math.max(q_x, 0);
 *     const _q_y = Math.max(q_y, 0);
 *     return Math.sqrt(_q_x*_q_x + _q_y*_q_y) + Math.min(Math.max(q_x,q_y), 0.0);
 * }
 */

function ray_hit_plane(
    out,

    ray_origin_x, ray_origin_y, ray_origin_z,
    ray_vector_x, ray_vector_y, ray_vector_z,

    plane_origin_x, plane_origin_y, plane_origin_z,
    plane_vector_x, plane_vector_y, plane_vector_z
) {
    const delta_x = plane_origin_x - ray_origin_x;
    const delta_y = plane_origin_y - ray_origin_y;
    const delta_z = plane_origin_z - ray_origin_z;

    const ldot = delta_x*plane_vector_x +
                 delta_y*plane_vector_y +
                 delta_z*plane_vector_z ;

    const rdot = ray_vector_x*plane_vector_x +
                 ray_vector_y*plane_vector_y +
                 ray_vector_z*plane_vector_z ;

    const d = ldot / rdot;
    out[0] = ray_origin_x + ray_vector_x * d;
    out[1] = ray_origin_y + ray_vector_y * d;
    out[2] = ray_origin_z + ray_vector_z * d;

    return out;
}

function ease_out_circ(x) { return Math.sqrt(1 - Math.pow(x - 1, 2)); }
function unit_clamp(p) { return Math.max(0, Math.min(1, p)); }
function inv_lerp(min, max, p) { return (p - min) / (max - min); }
function lerp(v0, v1, t) { return (1 - t) * v0 + t * v1; }
function lerp_rads(a, b, t) {
  let difference = fmodf(b - a, Math.PI*2.0),
        distance = fmodf(2.0 * difference, Math.PI*2.0) - difference;
  return a + distance * t;
}

    </script>
  </body>
</html>
