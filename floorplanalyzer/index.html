<!-- vim: sw=2 ts=2 expandtab smartindent ft=javascript
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Floorplanalyzer</title>
    <style>
document, body { margin: 0px; padding: 0px; overflow: hidden; }
.hud {
    position: absolute;
    top: 0px;
    right: 0px;
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
    font-family: monospace;
    padding: 0.3rem;

    button {
        margin: 0.3rem;
    }

    .labeled_input {
        display: flex;
        justify-content: space-between;
        gap: 0.8rem;
        padding: 0.3rem;
        label {
            height: 100%;
            margin-top: auto;
            margin-bottom: auto;
        }
    }
}
    </style>
  </head>

  <body>
    <div class="hud">
        <div class="labeled_input">
            <label for="line_finder_filter_on">Filter</label>
            <input  id="line_finder_filter_on" type="checkbox" checked="true"></input>
        </div>
        <div class="labeled_input">
            <label for="line_finder_filter_blur">Filter Blur</label>
            <input  id="line_finder_filter_blur" type="number" step="0.25"></input>
        </div>
        <div class="labeled_input">
            <label for="line_finder_filter_threshold">Filter Threshold</label>
            <input  id="line_finder_filter_threshold" type="number" step="1"></input>
        </div>
        <button id="floorplans_prev"> ⬅️  prev plan </button>
        <button id="floorplans_next"> next plan ➡️ </button>
    </div>
    <canvas id="glcanvas"></canvas>
    <script>"use strict";

const canvas = document.getElementById("glcanvas");
const ctx = canvas.getContext('2d');
(window.onresize = () => {
  canvas.width = window.innerWidth*window.devicePixelRatio,
  canvas.height = window.innerHeight*window.devicePixelRatio
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
})();

const full_scale = true;
const WORKING_SCALE = full_scale ? 1000 : 100;
const UI_SCALE      = full_scale ? 1    : 0.1;

const floorplans = new (class FloorPlanUI {
  static LOCALSTORAGE_KEY = "floorplananalyzer";

  static default_save() {
    return {
      active_index: 8,
      filter: {
        on: true,
        blur_px: 3,
        threshold: 1000
      },
      debug: {
        pos: { x: 0, y: 0 }
      }
    };
  }
  static get_save() {
    const fallback = FloorPlanUI.default_save;

    let stored = window.localStorage.getItem(FloorPlanUI.LOCALSTORAGE_KEY);
    if (stored) {
      stored = JSON.parse(stored);
      stored = Object.assign(fallback(), stored);
      stored.filter = Object.assign(fallback().filter, stored.filter);
      stored.debug = Object.assign(fallback().debug, stored.debug);
      return stored;
    }

    return fallback();
  }
  do_save() {
    window.localStorage.setItem(FloorPlanUI.LOCALSTORAGE_KEY, JSON.stringify(this.save));
  }

  active() {
    return this.images[this.save.active_index];
  }

  constructor() {
    this.save = FloorPlanUI.get_save();

    {
      const next = () => {
        this.save.active_index = (this.save.active_index + 1) % this.images.length;
        this.do_save();
        this.analysis = analyze_floorplan(this.active());
      }
      const prev = () => {
        const i = this.save.active_index;
        this.save.active_index = (i == 0) ? (this.images.length - 1) : (i - 1);
        this.do_save();
        this.analysis = analyze_floorplan(this.active());
      }
      const extract_float = (value) => {
          value = parseFloat(value);
          if (isNaN(value)) return 0;
          return value;
      }

      window.onkeydown = e => {
        if (e.key == " ") next();
      }
      floorplans_next.onclick = () => next();
      floorplans_prev.onclick = () => prev();

      line_finder_filter_on.checked = this.save.filter.on;
      line_finder_filter_on.oninput = () => {
        this.save.filter.on = line_finder_filter_on.checked;
        this.do_save();
        this.analysis = analyze_floorplan(this.active());
      }

      line_finder_filter_blur.value = this.save.filter.blur_px;
      line_finder_filter_blur.oninput = () => {
        this.save.filter.blur_px = extract_float(line_finder_filter_blur.value);
        this.do_save();
        this.analysis = analyze_floorplan(this.active());
      }

      line_finder_filter_threshold.value = this.save.filter.threshold;
      line_finder_filter_threshold.oninput = () => {
        this.save.filter.threshold = extract_float(line_finder_filter_threshold.value);
        this.do_save();
        this.analysis = analyze_floorplan(this.active());
      }
    }

    this.images = [
      "1-bed-Model-page-0-1184123436.jpg",
      "16820554805262d-floor-plan-without-dimensions-1-882012818.jpg",
      "226-Golf-Edge-2nd-Floor-Plan-e1602425648574-502954129.jpg",
      "2D-FloorPlans-Examples-Samples-1390924798.jpg",
      "4548508ef40e615e64ad3b9b6535654b-2138654924.png",
      "74eb007405350b06e6b1d136a45fa262-1594902549.jpg",
      "CBOF-Gabbard-Floorplan-3291614927.jpg",
      "Design-3257-floorplan-4268359515.jpg",
      "Duplex-no-garage-2-1693832074.png",
      "GROUND-FLOOR-PLAN-1855630524.jpg",
      "HC-Floor-Plan-1-3578889741.jpg",
      "Screenshot 2025-02-10 at 1.18.25 PM.png",
      "Screenshot 2025-02-10 at 1.20.31 PM.png",
      "Screenshot 2025-02-10 at 1.21.30 PM.png",
      "e52739c83f666a2062c8e4c918192c47-620348724.png",
      "example-floor-plan-3700536382.jpg",
      "first-floor-plan-1476202743.gif",
      "floor-plan-2171195143.gif",
      "floor-plan-house-design-storey-technical-drawing-png-favpng-CpiaV2kRKKc0NmqGVReg5kJQP-3020256790.jpg",
      "floorplanf-655005126.jpg",
      "forestwood-floor-plan-2br-935-corridor-building-sq-ft-93215580.jpg",
      "franklin_a_flr1_stairs-539485727.jpg",
      "ground-floor-plan-3672060057.gif",
      "th-22295632.jpg",
      "th-94093388.jpg",
    ].map(x => {
      const m = new Image();
      m.src = 'floorplans/' + x;
      return m;
    });

    (async () => {
      await new Promise(res => this.active().onload = res);
      this.analysis = analyze_floorplan(this.active());
    })();
  }
})();

function analyze_floorplan(img) {
  let pixels, size_x, size_y, imgdata;
  let working_canvas, ctx;
  {
    const tmp = working_canvas = document.createElement("canvas");
    size_x = tmp.width = WORKING_SCALE;
    size_y = tmp.height = WORKING_SCALE * (img.height / img.width);
    ctx = tmp.getContext("2d");

    const filter = floorplans.save.filter;
    ctx.filter = `contrast(${filter.threshold}%) blur(${filter.blur_px}px) contrast(${filter.threshold}%)`;

    ctx.drawImage(img, 0, 0, tmp.width, tmp.height);
    ctx.filter = 'none';
    imgdata = ctx.getImageData(0, 0, tmp.width, tmp.height, { colorSpace: 'srgb' });
    pixels = imgdata.data;
  }

  const bbox = { min: { x: Infinity, y: Infinity }, max: { x: -Infinity, y: -Infinity } };

  for (let y = 0; y < size_y; y++) {
    for (let x = 0; x < size_x; x++) {
      const r = pixels[(y*size_x + x)*4];

      if (r < 250) {
        bbox.min.x = Math.min(x, bbox.min.x);
        bbox.min.y = Math.min(y, bbox.min.y);
        bbox.max.x = Math.max(x, bbox.max.x);
        bbox.max.y = Math.max(y, bbox.max.y);
      }
    }
  }

  /* generate lines from raster using floodfill and ancestor tracing ala Djikstra */
  let lines;
  {
    const in_bounds = (x, y) => {
      if (x < bbox.min.x) return false;
      if (y < bbox.min.y) return false;
      if (x > bbox.max.x) return false;
      if (y > bbox.max.y) return false;
      return true;
    }

    const frontier = [];
    const came_from = new Map();
    const cost_from = new Map();

    const debug = floorplans.save.debug;
    const radius = Math.ceil(10 * UI_SCALE);
    for (let box_x = -radius; box_x <= radius; box_x++) {
      for (let box_y = -radius; box_y <= radius; box_y++) {
        if (Math.abs(box_x) != radius && Math.abs(box_y) != radius) continue;
        const x = debug.pos.x + box_x;
        const y = debug.pos.y + box_y;
        if (!in_bounds(x, y)) continue;

        const i = (y*size_x + x)*4 + 1;
        if (pixels[i] >= 250) continue;
        const pt = { x, y, traced_back: false };
        frontier.push(pt);
        came_from.set(pt, null);
        cost_from.set(pt, 0);
        pixels[i] = 255;
      }
    }

    for (let i = 0; frontier.length && i < 100_000; i++) {
      const pt = frontier.shift();

      /* naive version of this would be just:
       *  eval_pt(pt.x + 1, pt.y + 0);
       *  eval_pt(pt.x - 1, pt.y + 0);
       *  eval_pt(pt.x + 0, pt.y + 1);
       *  eval_pt(pt.x + 0, pt.y - 1);
       * but we want do whatever is farthest from our center point first.
       * best way to do that? keep going in the direction that gave good results
       */
      const parent = came_from.get(pt);
      const pdx = parent ? pt.x - parent.x : 1;
      const pdy = parent ? pt.y - parent.y : 0;

      /* ZIG-ZAG MODE */
      /* I think this works better than straight lines because
       * we sort by "number of steps from start" after this step. */
      // if (Math.abs(pdx) > Math.abs(pdy)) {
      //   eval_pt(pt.x + pdx, pt.y + 0);
      //   eval_pt(pt.x - pdx, pt.y + 0);
      //   eval_pt(pt.x +   0, pt.y + 1);
      //   eval_pt(pt.x +   0, pt.y - 1);
      // } else {
      //   eval_pt(pt.x + 0, pt.y + pdy);
      //   eval_pt(pt.x + 0, pt.y - pdy);
      //   eval_pt(pt.x + 1, pt.y +   0);
      //   eval_pt(pt.x - 1, pt.y +   0);
      // }

      /* STRAIGHT MODE */
      if (Math.abs(pdx) > Math.abs(pdy)) {
        eval_pt(pt.x +   0, pt.y + 1);
        eval_pt(pt.x +   0, pt.y - 1);
        eval_pt(pt.x + pdx, pt.y + 0);
        eval_pt(pt.x - pdx, pt.y + 0);
      } else {
        eval_pt(pt.x + 1, pt.y +   0);
        eval_pt(pt.x - 1, pt.y +   0);
        eval_pt(pt.x + 0, pt.y + pdy);
        eval_pt(pt.x + 0, pt.y - pdy);
      }

      function eval_pt(x, y) {
        if (in_bounds(x, y) && pixels[(y*size_x + x)*4 + 1] < 250) {
          pixels[(y*size_x + x)*4 + 1] = 255;
          const new_pt = { x, y, traced_back: false };
          frontier.push(new_pt);
          came_from.set(new_pt, pt);
          cost_from.set(new_pt, cost_from.get(pt) + 1);
        }
      }
    }

    let start = { x: debug.pos.x, y: debug.pos.y };
    lines = []

    /* make a tree by walking back through each "came_from"
     * and making sure each unique segment is in the list o' lines */
    const step_size = 100; /* lever to control LOD */

    const most_distal = [...cost_from.entries()].sort((a, b) => b[1] - a[1]);
    for (let [step, _] of most_distal) {
      const path = [step];
      let trunk = null;

      let ancestor = came_from.get(step);
      if (ancestor) {
        let last_dx = ancestor.x - step.x;
        let last_dy = ancestor.y - step.y;

        for (; ancestor = came_from.get(ancestor); ) {
          if (ancestor.traced_back) {
            path.push(ancestor);
            trunk = ancestor;
            break;
          }

          let dx = Math.sign(ancestor.x - step.x);
          let dy = Math.sign(ancestor.y - step.y);
          if ((dx || dy) && dx != last_dx || dy != last_dy) {
            step = ancestor;
            last_dx = dx;
            last_dy = dy;
            path.push(step);
          }

          ancestor.traced_back = true;
        }
      }

      if (path.length > 2)
        lines.push({ trunk, path });
    }

  }

  // lines = lines.slice(1); // [lines[0]];

  /* simplify the overly detailed raster lines */
  if (0) {
    const refined_paths = [];
    const raw_paths = lines;

    const SEGMENT_ANGLE = 0.2;
    const SEGMENT_THRESHOLD = 50;

    for (const path of lines) {

      if (path.length > 3) do {
        const out = [path[0]];
        let segment_start = path[0];

        let current_delta_x, current_delta_y;

        for (let i = 0; i < path.length; i++) {
          const p = path[i];
          const delta_x = segment_start.x - path[i].x;
          const delta_y = segment_start.y - path[i].y;
          const len = Math.sqrt(delta_x*delta_x + delta_y*delta_y);
          if (len == 0) continue;
          current_delta_x = delta_x / len;
          current_delta_y = delta_y / len;
          break;
        }
        if (current_delta_x == null) break;

        for (let i = 1; i < path.length; i++) {
          const last_p = path[i - 1];
          const this_p = path[i];

          let to_start_x = last_p.x - this_p.x;
          let to_start_y = last_p.y - this_p.y;
          const to_start_len = Math.sqrt(to_start_x*to_start_x + to_start_y*to_start_y);
          if (to_start_len <= 0) continue;
          to_start_x /= to_start_len;
          to_start_y /= to_start_len;

          const dot = to_start_x*current_delta_x + to_start_y*current_delta_y;
          if (isNaN(dot)) debugger;
          if (Math.abs(1 - dot) > SEGMENT_ANGLE) {
            let broke = false;

            for (let next_i = i + 1; ; next_i++){
              if (next_i >= path.length) break;
              current_delta_x = this_p.x - path[next_i].x;
              current_delta_y = this_p.y - path[next_i].y;
              const len = Math.sqrt(current_delta_x*current_delta_x + current_delta_y*current_delta_y);
              if (len <= SEGMENT_THRESHOLD) continue;
              current_delta_x /= len;
              current_delta_y /= len;
              broke = true;
              i = next_i;
              break;
            }

            if (broke) {
              segment_start = this_p;
              out.push(segment_start);
            }

          }
        }

        out.push(path.at(-1));
        refined_paths.push(out);
      } while(false);
      else
        refined_paths.push(path);

    }

    lines = refined_paths;
  }

  ctx.putImageData(imgdata, 0, 0);
  return { bbox, working_canvas, lines };
}

let mouse_down = false;
let mouse = new DOMPoint();
let debug_hovered = false;
let debug_dragging = false;
let world_transform;
canvas.onmousedown = e => {
  if (debug_hovered) {
    debug_dragging = true;
  }
  mouse_down = true;
}
window.onmouseup = e => {
  mouse_down = false;
  debug_dragging = false;
}
window.onmousemove = e => {
  if (world_transform) {
      mouse.x = e.offsetX * window.devicePixelRatio;
      mouse.y = e.offsetY * window.devicePixelRatio;
      mouse = world_transform.transformPoint(mouse);

      if (debug_dragging) {
        floorplans.save.debug.pos.x = Math.floor(mouse.x);
        floorplans.save.debug.pos.y = Math.floor(mouse.y);
        floorplans.do_save();
        floorplans.analysis = analyze_floorplan(floorplans.active());
      }
  }
};

requestAnimationFrame(function render(now) {
  requestAnimationFrame(render);

  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  {
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.scale(1.5/UI_SCALE, 1.5/UI_SCALE);

    {
      if (floorplans.analysis && floorplans.save.filter.on) {
        const floorplan = floorplans.analysis.working_canvas;

        ctx.translate(-floorplan.width*0.5, -floorplan.height*0.5)

        ctx.drawImage(floorplan, 0, 0, floorplan.width, floorplan.height);
      } else {
        const floorplan = floorplans.active();

        const scale = WORKING_SCALE / floorplan.width;
        ctx.translate(-floorplan.width*0.5*scale, -floorplan.height*0.5*scale)

        ctx.drawImage(floorplan, 0, 0, floorplan.width*scale, floorplan.height*scale);
      }

      if (floorplans.analysis) {
        const a = floorplans.analysis;

        ctx.strokeStyle = "rgba(255, 0, 0, 0.4)";
        ctx.lineWidth = 4 * UI_SCALE;
        const w = a.bbox.max.x - a.bbox.min.x;
        const h = a.bbox.max.y - a.bbox.min.y;
        ctx.strokeRect(a.bbox.min.x, a.bbox.min.y, w, h);

        /* DeBug is drawn in the space of the working canvas,
         * because that's what DeBug debugs. */
        {
          const debug = floorplans.save.debug;
          const dist = Math.sqrt((mouse.x - debug.pos.x)*(mouse.x - debug.pos.x) + 
                                 (mouse.y - debug.pos.y)*(mouse.y - debug.pos.y));
          debug_hovered = dist < 15*UI_SCALE;
          const font_size = (debug_hovered ? 30 : 20) * UI_SCALE;
          ctx.font = font_size + 'px monospace';
          ctx.textBaseline = 'middle';
          const text = '🕷️';
          ctx.fillText(text, debug.pos.x - ctx.measureText(text).width*0.5, debug.pos.y);
          world_transform = ctx.getTransform().inverse();
        }

        for (const { trunk, path } of floorplans.analysis.lines) {

          /* draw trunk */
          if (trunk) {
            ctx.fillStyle = "magenta";
            const size = 15 * UI_SCALE;
            ctx.fillRect(trunk.x - size*0.5, trunk.y - size*0.5, size, size);
          }

          ctx.beginPath();
          ctx.moveTo(path[0].x, path[0].y);
          for (let i = 0; i < path.length; i++) {
            const p = path[i];

            ctx.lineTo(p.x, p.y);

            ctx.fillStyle = "blue";
            const size = 5 * UI_SCALE;
            ctx.fillRect(p.x - size*0.5, p.y - size*0.5, size, size);
          }
          ctx.strokeStyle = 'purple';
          ctx.lineWidth = 2*UI_SCALE;
          ctx.stroke();
        }
      }
    }
  }
  ctx.restore();
})

function lerp(v0, v1, t) { return (1 - t) * v0 + t * v1; }
function inv_lerp(min, max, p) { return (p - min) / (max - min); }
    </script>
  </body>
</html>
