<!-- vim: sw=2 ts=2 expandtab smartindent ft=javascript
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Floorplanalyzer</title>
    <style>
document, body { margin: 0px; padding: 0px; overflow: hidden; }
.hud {
    position: absolute;
    top: 0px;
    left: 0px;
    background-color: rgba(70, 70, 70, 0.8);
    color: white;
    font-family: monospace;
    padding: 0.3rem;

    display: flex;
    flex-direction: column;
    gap: 1.2rem;

    button {
        margin: 0.3rem;
    }

    .labeled_input {
        display: flex;
        justify-content: space-between;
        gap: 0.8rem;
        padding: 0.3rem;
        label {
            height: 100%;
            margin-top: auto;
            margin-bottom: auto;
        }
    }
}

#side_canvas {
  position: absolute;
  right: 50px;
}

#floodfill_controls {
  button { opacity: 0.7; }
}

.directional_group {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
    </style>
  </head>

  <body>
    <div class="hud">

        <div class="directional_group">
          <button id="floorplans_prev"> ⬅️  prev plan </button>
          <span id="floorplans_index_readout"> floorplan 0/25 </span>
          <button id="floorplans_next"> next plan ➡️ </button>
        </div>

        <div>
          <div class="labeled_input">
              <label for="line_finder_filter_on">Show with preprocessing filters</label>
              <input  id="line_finder_filter_on" type="checkbox" checked="true"></input>
          </div>
          <div class="labeled_input">
              <label for="line_finder_filter_blur">Filter Blur</label>
              <input  id="line_finder_filter_blur" type="number" step="0.25"></input>
          </div>
          <div class="labeled_input">
              <label for="line_finder_filter_threshold">Filter Threshold</label>
              <input  id="line_finder_filter_threshold" type="number" minimum="100" step="1"></input>
          </div>
        </div>

        <div>
          <div class="labeled_input">
              <label for="floodfill_on">Show floodfill progress</label>
              <input  id="floodfill_on" type="checkbox" checked="true"></input>
          </div>
          <div id="floodfill_controls">
            <div class="labeled_input">
                <label for="floodfill_recurse">Recursively floodfill < 50% occupancy blocks</label>
                <input  id="floodfill_recurse" type="checkbox" checked="true"></input>
            </div>
            <div class="directional_group">
              <button id="floodfill_prever"> ⏪ </button>
              <button id="floodfill_prev"> ⬅️  less fill </button>
              <span id="floodfill_progress_readout"> pixel 0 </span>
              <button id="floodfill_next"> more fill ➡️ </button>
              <button id="floodfill_nexter"> ⏩ </button>
            </div>
          </div>
        </div>
    </div>
    <canvas id="floorplan_canvas"></canvas>
    <canvas id="side_canvas"></canvas>
    <script>"use strict";

const canvas = document.getElementById("floorplan_canvas");
const ctx = canvas.getContext('2d');
(window.onresize = () => {
  canvas.width = window.innerWidth*window.devicePixelRatio,
  canvas.height = window.innerHeight*window.devicePixelRatio
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
})();

const full_scale = true;
const WORKING_SCALE = full_scale ? 1000 : 100;
const UI_SCALE      = full_scale ? 1    : 0.1;

const floorplans = new (class FloorPlanUI {
  static LOCALSTORAGE_KEY = "floorplananalyzer";

  static default_save() {
    return {
      active_index: 8,
      filter_on: false,

      floodfill_on: false,
      floodfill_recurse: true,
      floodfill_progress: 10_000,

      cam: { x: 0, y: 0, zoom: 1 },
      filters: [
        { "on": true,  "blur_px": 1.00, "threshold":  100000 },
        { "on": true,  "blur_px": 2.50, "threshold":    1000 },
        { "on": true,  "blur_px": 2.50, "threshold":    1000 },
        { "on": true,  "blur_px": 2.50, "threshold":    1000 },
        { "on": true,  "blur_px": 2.50, "threshold":    1000 },
        { "on": true,  "blur_px": 4.50, "threshold":    1000 },
        { "on": true,  "blur_px": 2.50, "threshold":    1000 },
        { "on": true,  "blur_px": 3.25, "threshold":    1000 },
        { "on": true,  "blur_px": 2.50, "threshold":    1000 },
        { "on": true,  "blur_px": 0.75, "threshold":    1000 },
        { "on": false, "blur_px": 2.25, "threshold":   10000 },
        { "on": true,  "blur_px": 5.00, "threshold":   10000 },
        { "on": true,  "blur_px": 1.00, "threshold":    1000 },
        { "on": true,  "blur_px": 2.25, "threshold":   10000 },
        { "on": true,  "blur_px": 3.00, "threshold":    1000 },
        { "on": true,  "blur_px": 4.75, "threshold":    1000 },
        { "on": true,  "blur_px": 2.25, "threshold":    1000 },
        { "on": true,  "blur_px": 0.75, "threshold":    2000 },
        { "on": true,  "blur_px": 5.75, "threshold":    1000 },
        { "on": true,  "blur_px": 2.50, "threshold":    1000 },
        { "on": true,  "blur_px": 2.50, "threshold":    1000 },
        { "on": true,  "blur_px": 4.50, "threshold":    1000 },
        { "on": true,  "blur_px": 2.25, "threshold":   10000 },
        { "on": true,  "blur_px": 2.50, "threshold":    1000 },
        { "on": true,  "blur_px": 2.00, "threshold": 1000000 },
        { "on": true,  "blur_px": 0.75, "threshold":    1000 }
      ],
    };
  }
  static get_save() {
    const fallback = FloorPlanUI.default_save;

    let stored = window.localStorage.getItem(FloorPlanUI.LOCALSTORAGE_KEY);
    if (stored) {
      stored = JSON.parse(stored);
      stored = Object.assign(fallback(), stored);
      stored.filters = Object.assign(fallback().filters, stored.filters);
      stored.cam     = Object.assign(fallback().cam    , stored.cam    );
      return stored;
    }

    return fallback();
  }
  do_save() {
    window.localStorage.setItem(FloorPlanUI.LOCALSTORAGE_KEY, JSON.stringify(this.save));
  }

  active() { return this.images[this.save.active_index]; }
  filter() { return this.save.filters[this.save.active_index]; }

  constructor() {
    this.save = FloorPlanUI.get_save();

    this.images = FloorPlanUI.image_paths.map(x => {
      const m = new Image();
      m.src = 'floorplans/' + x;
      return m;
    });

    (async () => {
      await new Promise(res => this.active().onload = res);
      this.analysis = analyze_floorplan(this.active());
    })();

    {
      floorplans_index_readout.textContent = `floorplan ${1 + this.save.active_index}/${this.images.length}`;

      const sync_filter = () => {
        line_finder_filter_on.checked = this.save.filter_on;
        line_finder_filter_blur.value = this.filter().blur_px;
        line_finder_filter_threshold.value = this.filter().threshold;
      }

      const set_index = index => {
        this.save.active_index = index;
        this.do_save();
        this.analysis = analyze_floorplan(this.active());
        floorplans_index_readout.textContent = `floorplan ${index + 1}/${this.images.length}`;
        sync_filter();
      }

      const extract_float = (value) => {
          value = parseFloat(value);
          if (isNaN(value)) return 0;
          return value;
      }

      window.onkeydown = e => {
        if (e.key == " ") floorplans_next.click();
      }
      floorplans_next.onclick = () => set_index((this.save.active_index + 1) % this.images.length);
      floorplans_prev.onclick = () => {
        let i = this.save.active_index;
        return set_index((i == 0) ? (this.images.length - 1) : (i - 1));
      }

      /* preprocessing filter control group */
      {
        sync_filter();
        line_finder_filter_blur     .parentElement.style.display = this.save.filter_on ? '' : 'none';
        line_finder_filter_threshold.parentElement.style.display = this.save.filter_on ? '' : 'none';
        line_finder_filter_on.oninput = () => {
          this.save.filter_on = line_finder_filter_on.checked;
          line_finder_filter_blur     .parentElement.style.display = this.save.filter_on ? '' : 'none';
          line_finder_filter_threshold.parentElement.style.display = this.save.filter_on ? '' : 'none';
          this.do_save();
          this.analysis = analyze_floorplan(this.active());
        }
        line_finder_filter_blur.oninput = () => {
          this.filter().blur_px = extract_float(line_finder_filter_blur.value);
          this.do_save();
          this.analysis = analyze_floorplan(this.active());
        }
        line_finder_filter_threshold.oninput = () => {
          this.filter().threshold = Math.max(100, extract_float(line_finder_filter_threshold.value));
          this.do_save();
          this.analysis = analyze_floorplan(this.active());
        }
      }

      /* floodfill progress control group */
      {
        floodfill_on.checked = this.save.floodfill_on;
        floodfill_recurse.checked = this.save.floodfill_recurse;
        floodfill_controls.style.display = this.save.floodfill_on ? '' : 'none';
        floodfill_on.oninput = () => {
          this.save.floodfill_on = floodfill_on.checked;
          floodfill_controls.style.display = this.save.floodfill_on ? '' : 'none';
          this.do_save();
          this.analysis = analyze_floorplan(this.active());
        }

        floodfill_recurse.oninput = () => {
          this.save.floodfill_recurse = floodfill_recurse.checked;
          this.do_save();
          this.analysis = analyze_floorplan(this.active());
        }

        let floodfill_progress_delta = delta => {
          this.save.floodfill_progress += delta;
          floodfill_progress_readout.textContent = `pixel ${this.save.floodfill_progress}`;
          this.analysis = analyze_floorplan(this.active());
        }
        floodfill_progress_readout.textContent = `pixel ${this.save.floodfill_progress}`;

        let control_interval;
        floodfill_next.onmousedown = () => control_interval = setInterval(() => floodfill_progress_delta(+1), 1);
        floodfill_next.onmouseup   = () => clearInterval(control_interval);
        floodfill_prev.onmousedown = () => control_interval = setInterval(() => floodfill_progress_delta(-1), 1);
        floodfill_prev.onmouseup   = () => clearInterval(control_interval);

        floodfill_nexter.onmousedown = () => control_interval = setInterval(() => floodfill_progress_delta(+100), 1);
        floodfill_nexter.onmouseup   = () => clearInterval(control_interval);
        floodfill_prever.onmousedown = () => control_interval = setInterval(() => floodfill_progress_delta(-100), 1);
        floodfill_prever.onmouseup   = () => clearInterval(control_interval);
      }
    }
  }

  static image_paths = [
      "1-bed-Model-page-0-1184123436.jpg",
      "16820554805262d-floor-plan-without-dimensions-1-882012818.jpg",
      "226-Golf-Edge-2nd-Floor-Plan-e1602425648574-502954129.jpg",
      "2D-FloorPlans-Examples-Samples-1390924798.jpg",
      "4548508ef40e615e64ad3b9b6535654b-2138654924.png",
      "74eb007405350b06e6b1d136a45fa262-1594902549.jpg",
      "CBOF-Gabbard-Floorplan-3291614927.jpg",
      "Design-3257-floorplan-4268359515.jpg",
      "Duplex-no-garage-2-1693832074.png",
      "GROUND-FLOOR-PLAN-1855630524.jpg",
      "HC-Floor-Plan-1-3578889741.jpg",
      "Screenshot 2025-02-10 at 1.18.25 PM.png",
      "Screenshot 2025-02-10 at 1.20.31 PM.png",
      "Screenshot 2025-02-10 at 1.21.30 PM.png",
      "e52739c83f666a2062c8e4c918192c47-620348724.png",
      "example-floor-plan-3700536382.jpg",
      "first-floor-plan-1476202743.gif",
      "floor-plan-2171195143.gif",
      "floor-plan-house-design-storey-technical-drawing-png-favpng-CpiaV2kRKKc0NmqGVReg5kJQP-3020256790.jpg",
      "floorplanf-655005126.jpg",
      "forestwood-floor-plan-2br-935-corridor-building-sq-ft-93215580.jpg",
      "franklin_a_flr1_stairs-539485727.jpg",
      "ground-floor-plan-3672060057.gif",
      "th-22295632.jpg",
      "th-94093388.jpg",
      "IMG-20250125-WA0008.jpg"
    ];
})();

function analyze_floorplan(img) {
  let pixels, size_x, size_y, imgdata;
  let working_canvas, ctx;
  {
    const tmp = working_canvas = document.createElement("canvas");
    size_x = tmp.width = WORKING_SCALE;
    size_y = tmp.height = WORKING_SCALE * (img.height / img.width);
    ctx = tmp.getContext("2d");

    const filter = floorplans.filter();
    ctx.filter = `contrast(${filter.threshold}%) grayscale(100%) blur(${filter.blur_px}px) contrast(${filter.threshold}%)`;

    ctx.drawImage(img, 0, 0, tmp.width, tmp.height);
    ctx.filter = 'none';
    imgdata = ctx.getImageData(0, 0, tmp.width, tmp.height, { colorSpace: 'srgb' });
    pixels = imgdata.data;
  }

  const bbox_all = { min: { x: Infinity, y: Infinity }, max: { x: -Infinity, y: -Infinity } };

  for (let y = 0; y < size_y; y++) {
    for (let x = 0; x < size_x; x++) {
      const r = pixels[(y*size_x + x)*4];

      if (r < 250) {
        bbox_all.min.x = Math.min(x, bbox_all.min.x);
        bbox_all.min.y = Math.min(y, bbox_all.min.y);
        bbox_all.max.x = Math.max(x, bbox_all.max.x);
        bbox_all.max.y = Math.max(y, bbox_all.max.y);
      }
    }
  }

  const bbox_size_x = (bbox_all.max.x - bbox_all.min.x) + 1;
  const bbox_size_y = (bbox_all.max.y - bbox_all.min.y) + 1;
  const directions = new Uint8Array(bbox_size_x * bbox_size_y);
  const direction_at  = (x, y   ) => directions[(y - bbox_all.min.y)*bbox_size_x + (x - bbox_all.min.x)];
  const direction_set = (x, y, v) => directions[(y - bbox_all.min.y)*bbox_size_x + (x - bbox_all.min.x)] = v;

  // sometimes an early return here is useful for debugging
  // ctx.putImageData(imgdata, 0, 0);
  // return { bbox, working_canvas, lines: [] };

  /* generate lines from raster using floodfill and ancestor tracing ala Djikstra */
  let all_blocks = [], lines;
  {
    const in_bounds = (bbox, x, y) => {
      if (x < bbox.min.x) return false;
      if (y < bbox.min.y) return false;
      if (x > bbox.max.x) return false;
      if (y > bbox.max.y) return false;
      return true;
    }

    /* get some lines to start with by walking in from the bounding box */
    {
      const came_from = new Map();
      const cost_from = new Map();
      const frontier = [];
      for (let y = bbox_all.min.y; y <= bbox_all.max.y; y += 1) {
        for (let x = bbox_all.min.x; x <= bbox_all.max.x; x += 1) {
          const is_min = x == bbox_all.min.x || y == bbox_all.min.y;
          const is_max = x == bbox_all.max.x || y == bbox_all.max.y;
          const is_x   = x == bbox_all.min.x || x == bbox_all.max.x;
          const is_y   = y == bbox_all.min.y || y == bbox_all.max.y;
          if (!is_min && !is_max) continue;
          if (is_x && is_y) continue; /* I hate edge cases */
          if (!in_bounds(bbox_all, x, y)) continue;

          const i = (y*size_x + x)*4 + 1;
          if (pixels[i] >= 250) continue;
          const pt = { x, y };
          frontier.push(pt);

          let origin_x = x;
          let origin_y = y;
          if (is_x) origin_x += is_min ? 1 : -1;
          if (is_y) origin_y += is_min ? 1 : -1;

          direction_set(x, y, is_y ? (is_min ? 1 : 2) : (is_min ? 3 : 4));

          came_from.set(pt, { x: origin_x, y: origin_y });
          cost_from.set(pt, 0);
          pixels[i] = 255;
        }
      }

      lines = walk_frontier(frontier, bbox_all).lines;
    }

    function walk_frontier(reserve, bbox) {
      let seeds = [];
      let frontier = [];
      /* either not walkable or visited previously */
      let walkable = (x, y) => pixels[(y*size_x + x)*4 + 1] < 254;
      let walked   = (x, y) => pixels[(y*size_x + x)*4 + 1] > 254 && pixels[(y*size_x + x)*4 + 2] < 254;

      let i = 0;
      while (true) {
        if (!frontier.length && !reserve.length) break;
        let from_frontier = frontier.length;
        const pt = frontier.length ? frontier.shift() : reserve.shift();
        if (from_frontier && !walkable(pt.x, pt.y)) continue;

        if (from_frontier) seeds.push(pt);
        pixels[(pt.y*size_x + pt.x)*4 + 1] = 255;

        const dir = direction_at(pt.x, pt.y);
        let x = pt.x;
        let y = pt.y;
        for (; i < floorplans.save.floodfill_progress; i++) {

          let dx = 0, dy = 0;
          if (dir == 1) dy += 1;
          if (dir == 2) dy -= 1;
          if (dir == 3) dx += 1;
          if (dir == 4) dx -= 1;
          x += dx, y += dy;

          if (!walkable(x, y)) break;
          pixels[(y*size_x + x)*4 + 1] = 255;
          direction_set(x, y, dir);

          const is_y = Math.abs(dy) > Math.abs(dx);
          const is_pos = (is_y) ? dy == 1 : dx == 1;
          const forward = is_y ? ( is_pos ? 1 : 2) : ( is_pos ? 3 : 4);
          const back    = is_y ? (!is_pos ? 1 : 2) : (!is_pos ? 3 : 4);
          const left    = is_y ? ( is_pos ? 3 : 4) : ( is_pos ? 1 : 2);
          const right   = is_y ? (!is_pos ? 3 : 4) : (!is_pos ? 1 : 2);

          const eval_point = (x, y, dir) => {
            if (dir == 1) y += 1;
            if (dir == 2) y -= 1;
            if (dir == 3) x += 1;
            if (dir == 4) x -= 1;
            if (in_bounds(bbox, x, y) && walkable(x, y)) {
              frontier.push({ x, y });
              direction_set(x, y, dir);
            }
          }
          eval_point(x, y, forward);
          eval_point(x, y, back);
          eval_point(x, y, left);
          eval_point(x, y, right);
        }
      }

      /* floodfill across everything again, finding contiguous blocks of territory sharing the same direction
       * - make bounding boxes for the blocks */
      function boxify(seeds, do_unbroken) {
        const unbroken_blocks = [];
        let blocks = [];
        for (const seed of seeds) {
          let frontier = [seed];
          const dir = direction_at(seed.x, seed.y);
          const block_bbox = { min: { x: Infinity, y: Infinity }, max: { x: -Infinity, y: -Infinity } };
          let block_population = 0;
          const block_pixels = [];

          while (frontier.length) {
            const p = frontier.pop();
            const { x, y } = p;
            if (pixels[(y*size_x + x)*4 + 2] > 254) continue;

            block_bbox.min.x = Math.min(x+0, block_bbox.min.x);
            block_bbox.min.y = Math.min(y+0, block_bbox.min.y);
            block_bbox.max.x = Math.max(x+1, block_bbox.max.x);
            block_bbox.max.y = Math.max(y+1, block_bbox.max.y);
            block_population++;

            /* NOTE: floodfilling through again is almost certainly going to be better than making this array, * but good enough for an MVP */
            block_pixels.push(p);

            pixels[(y*size_x + x)*4 + 2] = 255;

            if (in_bounds(bbox, x + 0, y + 1) && walked(x + 0, y + 1) && (direction_at(x + 0, y + 1) == dir)) frontier.push({ x: x + 0, y: y + 1 });
            if (in_bounds(bbox, x + 0, y - 1) && walked(x + 0, y - 1) && (direction_at(x + 0, y - 1) == dir)) frontier.push({ x: x + 0, y: y - 1 });
            if (in_bounds(bbox, x + 1, y + 0) && walked(x + 1, y + 0) && (direction_at(x + 1, y + 0) == dir)) frontier.push({ x: x + 1, y: y + 0 });
            if (in_bounds(bbox, x - 1, y + 0) && walked(x - 1, y + 0) && (direction_at(x - 1, y + 0) == dir)) frontier.push({ x: x - 1, y: y + 0 });
          }

          const w = block_bbox.max.x - block_bbox.min.x;
          const h = block_bbox.max.y - block_bbox.min.y;
          let occupancy = block_population / (w*h);

          if (block_population < 20) continue;

          if (block_population > 100 && occupancy < 0.34 && floorplans.save.floodfill_recurse && do_unbroken) {
            unbroken_blocks.push({ direction: dir, bbox: block_bbox, pixels: block_pixels, population: block_population, occupancy });
          }
          else
            blocks.push({ direction: dir, bbox: block_bbox, pixels: block_pixels, population: block_population, occupancy });
        }
        return { blocks, unbroken_blocks };
      }

      let { blocks, unbroken_blocks } = boxify(seeds, true);

      /* - break them down if those bounding boxes are mostly hollow */
      {
        let seeds = [];

        break_down:
        for (const block of unbroken_blocks) {
          let test_pt = (candidate_x, candidate_y, dir) => {
            if (pixels[(candidate_y*size_x + candidate_x)*4 + 0] > 254) return false;

            /* clear */
            for (const { x, y } of block.pixels) {
              pixels[(y*size_x + x)*4 + 1] = pixels[(y*size_x + x)*4 + 0];
              pixels[(y*size_x + x)*4 + 2] = pixels[(y*size_x + x)*4 + 0];
              direction_set(x, y, 0);
            }

            let candidate_dir_b4 = direction_at(candidate_x, candidate_y);
            if (dir == 1) candidate_y -= 1;
            if (dir == 2) candidate_y += 1;
            if (dir == 3) candidate_x -= 1;
            if (dir == 4) candidate_x += 1;
            direction_set(candidate_x, candidate_y, dir);
            const new_blocks = walk_frontier([{ x: candidate_x, y: candidate_y }], block.bbox).blocks;
            const new_population = new_blocks.reduce((a, x) => x.population + a, 0);
            direction_set(candidate_x, candidate_y, candidate_dir_b4);

            if (new_population >= block.population*0.8) {
              /* idt these are the correct seeds but meh */
              for (const nb of new_blocks) seeds.push(nb.pixels[0]);
              return true;
            }

            return false;
          }

          if (test_pt(block.bbox.min.x + 0, block.bbox.min.y + 0, 3)) continue break_down;
          if (test_pt(block.bbox.min.x + 0, block.bbox.max.y - 1, 4)) continue break_down;
          if (test_pt(block.bbox.max.x - 1, block.bbox.max.y - 1, 2)) continue break_down;
          if (test_pt(block.bbox.max.x - 1, block.bbox.min.y + 0, 1)) continue break_down;

          for (let i = 0; i < block.pixels.length; i++)
            for (let dir = 1; dir <= 4; dir++) 
              if (test_pt(block.pixels[i].x, block.pixels[i].y, dir))
                continue break_down;
        }

        /* clear grouping floodfill color */
        for (let y = bbox_all.min.y; y < bbox_all.max.y; y++)
          for (let x = bbox_all.min.x; x < bbox_all.max.x; x++)
            pixels[(y*size_x + x)*4 + 2] = pixels[(y*size_x + x)*4 + 0];

        const new_boxes = boxify(seeds, false).blocks;
        blocks = blocks.concat(new_boxes);
      }

      let lines = [];
      for (const b of blocks) {
        let line;

        if (b.direction == 1 || b.direction == 2) line = {
          path: [ { x: lerp(b.bbox.min.x, b.bbox.max.x, 0.5), y: b.bbox.min.y },
                  { x: lerp(b.bbox.min.x, b.bbox.max.x, 0.5), y: b.bbox.max.y } ],
          direction: b.direction
        };
        if (b.direction == 3 || b.direction == 4) line = {
          path: [ { x: b.bbox.min.x, y: lerp(b.bbox.min.y, b.bbox.max.y, 0.5) },
                  { x: b.bbox.max.x, y: lerp(b.bbox.min.y, b.bbox.max.y, 0.5) } ],
          direction: b.direction
        };

        lines.push(line);
      }

      all_blocks = all_blocks.concat(blocks);
      return { blocks, lines };
    }

    /* continue along lines to find more floodfill candidates,
     * continue until we run out of lines */
    {
      let line_frontier = lines.slice();
      for (let i = 0; i < 50_000 && line_frontier.length; i++) {
      // while (line_frontier.length) {
        const { path: [a, b], direction: dir } = line_frontier.pop();

        let dx = 0, dy = 0;
        if (dir == 1) dy += 1;
        if (dir == 2) dy -= 1;
        if (dir == 3) dx += 1;
        if (dir == 4) dx -= 1;
        const extension_len = 175;

        // lines.push({ path: [a, { x: b.x + dx*extension_len, y: b.y + dy*extension_len }], direction: dir });

        {
          const frontier = [];

          for (let i = 1; i < extension_len; i++) {
            const x = Math.floor(b.x + dx*i);
            const y = Math.floor(b.y + dy*i);

            const pt = { x, y };
            frontier.push(pt);

            if (!in_bounds(bbox_all, x, y)) break;
            /* stop when you hit a floorplan pixel */
            if (pixels[(y*size_x + x)*4 + 1] < 254) {
              direction_set(x, y, dir);
              break;
            }
          }

          const new_lines = walk_frontier(frontier, bbox_all).lines;
          lines = lines.concat(new_lines);
          line_frontier = line_frontier.concat(new_lines)
        }
      }
    }

  }

  // lines = lines.slice(1);
  // lines = lines.slice(0, 1);

  lines = lines.filter(line => {
    let dx = line.path[0].x - line.path[1].x;
    let dy = line.path[0].y - line.path[1].y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    return (dist > 25);
  });

  ctx.putImageData(imgdata, 0, 0);
  return { bbox: bbox_all, directions, working_canvas, blocks: all_blocks, lines };
}

let world_transform;
let input = {
  mouse_down: false,
  cam_down_x: 0,
  cam_down_y: 0,
  mouse_down_x: 0,
  mouse_down_y: 0,
  mouse_x: 0,
  mouse_y: 0,
}
canvas.onmousedown = e => {
  input.mouse_down = true;
  input.mouse_down_x = e.offsetX*window.devicePixelRatio;
  input.mouse_down_y = e.offsetY*window.devicePixelRatio;
  input.cam_down_x = floorplans.save.cam.x;
  input.cam_down_y = floorplans.save.cam.y;
}
canvas.mouseleave = window.onmouseup = e => {
  input.mouse_down = false;
}
canvas.onmousemove = e => {
  input.mouse_x = e.offsetX*window.devicePixelRatio;
  input.mouse_y = e.offsetY*window.devicePixelRatio;
  if (input.mouse_down) {
    floorplans.save.cam.x = input.cam_down_x + (input.mouse_x - input.mouse_down_x);
    floorplans.save.cam.y = input.cam_down_y + (input.mouse_y - input.mouse_down_y);
    floorplans.do_save();
  }
};
canvas.onwheel = e => {
  if (!world_transform) return;

  const mouse = world_transform.transformPoint(new DOMPoint(input.mouse_x, input.mouse_y));

  let next_zoom = floorplans.save.cam.zoom * (1 - e.deltaY * 0.001);
  next_zoom = Math.max(0.15, next_zoom);


  /* offset camera.x such that it stays centered around the mouse,
   * accounting for the new zoom */
  {
      const x_t = mouse.x / canvas.width;
      const  nowSizeX = canvas.width * floorplans.save.cam.zoom;
      const nextSizeX = canvas.width * next_zoom;
      const deltaX = nextSizeX - nowSizeX;
      floorplans.save.cam.x -= deltaX * x_t;
  }

  /* ditto on the Y axis; keep the mouse as the focal point */
  {
      const y_t = mouse.y / canvas.height;
      const  nowSizeY = canvas.height * floorplans.save.cam.zoom;
      const nextSizeY = canvas.height * next_zoom;
      const deltaY = nextSizeY - nowSizeY;
      floorplans.save.cam.y -= deltaY * y_t;
  }

  floorplans.save.cam.zoom = next_zoom;
  floorplans.do_save();
}

requestAnimationFrame(function render(now) {
  requestAnimationFrame(render);

  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  {
    ctx.translate(floorplans.save.cam.x, floorplans.save.cam.y);
    ctx.scale(floorplans.save.cam.zoom, floorplans.save.cam.zoom);
    world_transform = ctx.getTransform().inverse();

    const left_pad = 50 * window.devicePixelRatio;
    ctx.translate(left_pad, canvas.height/2);
    ctx.scale(1.5/UI_SCALE, 1.5/UI_SCALE);

    {
      if (floorplans.analysis && floorplans.save.filter_on) {
        const floorplan = floorplans.analysis.working_canvas;

        ctx.translate(0, -floorplan.height*0.5)

        ctx.drawImage(floorplan, 0, 0, floorplan.width, floorplan.height);
      } else {
        const floorplan = floorplans.active();

        const scale = WORKING_SCALE / floorplan.width;
        ctx.translate(0, -floorplan.height*0.5*scale)

        ctx.drawImage(floorplan, 0, 0, floorplan.width*scale, floorplan.height*scale);
      }

      if (floorplans.analysis) {
        const a = floorplans.analysis;
        const w = (a.bbox.max.x - a.bbox.min.x) + 1;
        const h = (a.bbox.max.y - a.bbox.min.y) + 1;

        ctx.strokeStyle = "rgba(255, 0, 0, 0.4)";
        ctx.lineWidth = 4 * UI_SCALE;
        ctx.strokeRect(a.bbox.min.x, a.bbox.min.y, w, h);

        for (const l of floorplans.analysis.lines) {
          const line = l.path;
          ctx.beginPath();
          ctx.moveTo(line[0].x, line[0].y);
          for (let i = 0; i < line.length; i++) {
            const p = line[i];

            ctx.lineTo(p.x, p.y);

            ctx.fillStyle = "blue";
            const size = 2 * UI_SCALE;
            ctx.fillRect(p.x - size*0.5, p.y - size*0.5, size, size);
          }
          ctx.strokeStyle = 'purple';
          ctx.lineWidth = 1*UI_SCALE;
          ctx.stroke();
        }

        if (floorplans.save.floodfill_on) {
          ctx.textBaseline = 'middle';
          const size = 1;
          ctx.font = size + 'px monospace';
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {

              const dir = a.directions[y*w + x];
              if (dir == undefined) debugger;
              let emoji, color;
              if (dir == 0) continue;
              else if (dir == 1) emoji = '⬇️', color = 'magenta';
              else if (dir == 2) emoji = '⬆️', color = 'orange';
              else if (dir == 3) emoji = '➡️', color = 'cyan';
              else if (dir == 4) emoji = '⬅️', color = 'chartreuse';

              ctx.fillStyle = color;
              ctx.fillRect((a.bbox.min.x + 0.5) + x - size*0.5, (a.bbox.min.y + 0.5) + y - size*0.5, size, size);
              ctx.globalAlpha = 0.2;
              ctx.fillText(emoji, (a.bbox.min.x + 0.5) + x - size*0.5, (a.bbox.min.y + 1.11) + y - size*0.5);
              ctx.globalAlpha = 1.0;
            }
          }
          ctx.textBaseline = 'none';
        }

        ctx.globalAlpha = 0.5;
        if (0) for (const { bbox, occupancy } of floorplans.analysis.blocks) {
          ctx.strokeStyle = occupancy > 0.34 ? "black" : "red";
          ctx.fillStyle   = occupancy > 0.34 ? "black" : "red";

          ctx.lineWidth = (3/floorplans.save.cam.zoom)*UI_SCALE;
          ctx.strokeRect(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);

          ctx.font = "5px monospace";
          ctx.fillText((occupancy * 100).toFixed(1) + '%', bbox.min.x, bbox.max.y + 5);
        }
        ctx.globalAlpha = 1.0;

      }
    }
  }
  ctx.restore();
})

{
  const side_canvas = document.getElementById("side_canvas");

  const resize = () => {
    const size = Math.min(window.innerWidth - WORKING_SCALE, window.innerWidth * 0.5);
    side_canvas.style.top = (window.innerHeight - size) * 0.5 + 'px';
    side_canvas.width = size*window.devicePixelRatio;
    side_canvas.height = size*window.devicePixelRatio;
    side_canvas.style.width = size + 'px';
    side_canvas.style.height = size + 'px';
  }
  window.addEventListener("resize", resize);
  resize();

  let lines_lo = [];
  let lines_hi = [];
  canvas3D(
    side_canvas,
    {
      fullscreen: false,
      clear_color: "rgb(40 50 60)",
      zoom: 1600,
      max_zoom: 2500
    },
    (ctx, timestamp, transform) => {

      ctx.globalAlpha = 0.5;
      ctx.lineWidth = 0.15 * 40;
      ctx.miterLimit = 1; /* prevents lines from looking wobbly at oblique angles */

      if (!floorplans.analysis?.lines) return;

      const floorplan = floorplans.active();

      const size_x = WORKING_SCALE;
      const size_y = WORKING_SCALE * (floorplan.height / floorplan.width);
      const t = (pt, z) => 
        transform(new DOMPoint(
           size_x*0.5 - pt.x,
          -size_y*0.5 + pt.y,
          z
        ));


      const WALL_HEIGHT = 150;
      for (let i = 0; i < floorplans.analysis.lines.length; i++) {
        lines_lo[i*2 + 0] = t(floorplans.analysis.lines[i].path[0], 0);
        lines_lo[i*2 + 1] = t(floorplans.analysis.lines[i].path[1], 0);
        lines_hi[i*2 + 0] = t(floorplans.analysis.lines[i].path[0], WALL_HEIGHT);
        lines_hi[i*2 + 1] = t(floorplans.analysis.lines[i].path[1], WALL_HEIGHT);
      }

      /* draw bbox */
      {
        const bbox = floorplans.analysis.bbox;
        ctx.beginPath();
        let pt = { x: 0, y: 0 };

        const bl = t({ x: bbox.min.x, y: bbox.min.y }, 0);
        const tl = t({ x: bbox.min.x, y: bbox.max.y }, 0);
        const tr = t({ x: bbox.max.x, y: bbox.max.y }, 0);
        const br = t({ x: bbox.max.x, y: bbox.min.y }, 0);
        ctx.moveTo(bl.x, bl.y);
        ctx.lineTo(tl.x, tl.y);
        ctx.lineTo(tr.x, tr.y);
        ctx.lineTo(br.x, br.y);
        ctx.fillStyle = 'black';
        ctx.fill();
      }

      /* draw tops and bottoms of walls */
      for (const lines of [lines_lo, lines_hi]) {
        for (let i = 0; i < floorplans.analysis.lines.length; i++) {
          ctx.beginPath();
          ctx.moveTo(lines[i*2 + 0].x, lines[i*2 + 0].y);
          ctx.lineTo(lines[i*2 + 1].x, lines[i*2 + 1].y);
          ctx.strokeStyle = 'orange';
          ctx.lineWidth = 9;
          ctx.stroke();
        }
      }

      /* draw sides of walls */
      for (let side = 0; side < 2; side++) {
        for (let i = 0; i < floorplans.analysis.lines.length; i++) {
          ctx.beginPath();
          ctx.moveTo(lines_lo[i*2 + side].x, lines_lo[i*2 + side].y);
          ctx.lineTo(lines_hi[i*2 + side].x, lines_hi[i*2 + side].y);
          ctx.strokeStyle = 'orange';
          ctx.lineWidth = 9;
          ctx.stroke();
        }
      }

      /* draw walls themselves */
      for (let i = 0; i < floorplans.analysis.lines.length; i++) {
        ctx.beginPath();
        ctx.moveTo(lines_lo[i*2 + 0].x, lines_lo[i*2 + 0].y);
        ctx.lineTo(lines_lo[i*2 + 1].x, lines_lo[i*2 + 1].y);
        ctx.lineTo(lines_hi[i*2 + 1].x, lines_hi[i*2 + 1].y);
        ctx.lineTo(lines_hi[i*2 + 0].x, lines_hi[i*2 + 0].y);
        ctx.fillStyle = 'orange';
        ctx.globalAlpha = 0.1;
        ctx.fill();
        ctx.globalAlpha = 1.0;
      }
      ctx.miterLimit = 10;

      ctx.globalAlpha = 1.0;
    }
  );

  function canvas3D(canvas, opts, render_cb) {
    const fullscreen = opts.fullscreen ?? false;

    let input = {
      zoom:   opts.zoom ?? 10,
      scroll: 0,

      pitch:  Math.PI*0.90,
      yaw:   -Math.PI*0.25,
      eye: new DOMPoint(0, 0, 0, 1),
      cam_pivot: new DOMPoint(0, 0, 0, 1),

      dampedEvent: { button: 0, movementX: 0, movementY: 0 },

      lmb_down: false,
      rmb_down: false,
      mouse_x:  0,
      mouse_y:  0,
    }

    /* mouse controls */
    {
        const opts = { passive: false };

        canvas.addEventListener('wheel', e => {
            e.preventDefault();

            if (input.mouse_down) return;
            input.scroll += e.deltaY;
        }, opts);
        canvas.addEventListener('mousedown', ev => {
            ev.preventDefault();

            input.dampedEvent.button = ev.button ? 2 : 0;

            if (ev.button == 0) input.lmb_down = true;
            if (ev.button == 2) input.rmb_down = true;
        }, opts);
        window.addEventListener('mousemove', ev => {
            if (input.lmb_down || input.rmb_down) {
                input.dampedEvent.movementX += ev.movementX;
                input.dampedEvent.movementY += ev.movementY;
            }

            input.mouse_x = ev.offsetX*window.devicePixelRatio;
            input.mouse_y = ev.offsetY*window.devicePixelRatio;
        }, opts);
        window.addEventListener("contextmenu", ev => {
            ev.preventDefault();
        }, opts);
        window.addEventListener('mouseup', ev => {
            if (ev.button == 0) input.lmb_down = false;
            if (ev.button == 2) input.rmb_down = false;
        }, opts);
        window.addEventListener('mouseleave', ev => {
            if (ev.button == 0) input.lmb_down = false;
            if (ev.button == 2) input.rmb_down = false;
        }, opts);
    }

    /* touch controls */
    {
        const opts = { passive: false };

        let touch_x = 0;
        let touch_y = 0;
        window.addEventListener("touchstart", ev => {
            ev.preventDefault();

            touch_x = ev.changedTouches[0].clientX;
            touch_y = ev.changedTouches[0].clientY;

            input.lmb_down = true;
        }, opts);

        window.addEventListener("touchmove", ev => {
            ev.preventDefault();
            input.dampedEvent.button = 0;

            input.dampedEvent.movementX += ev.changedTouches[0].clientX - touch_x;
            input.dampedEvent.movementY += ev.changedTouches[0].clientY - touch_y;

            touch_x = ev.changedTouches[0].clientX;
            touch_y = ev.changedTouches[0].clientY;
        }, opts);

        window.addEventListener("touchend", ev => {
            ev.preventDefault();

            input.lmb_down = false;
        }, opts);
    }

    const ctx = canvas.getContext('2d');
    if (fullscreen) (window.onresize = () => {
       canvas.width = window.innerWidth*window.devicePixelRatio,
       canvas.height = window.innerHeight*window.devicePixelRatio
       canvas.style.width = window.innerWidth + 'px';
       canvas.style.height = window.innerHeight + 'px';
     })();

    let last_timestamp;
    requestAnimationFrame(function render(timestamp) {
      requestAnimationFrame(render);

      timestamp *= 0.001;
      last_timestamp ??= timestamp;
      const deltaTime = timestamp - last_timestamp;
      last_timestamp = timestamp;

      {
        const ev = input.dampedEvent;

        /* based on the assumption that if you're zoomed in more,
         * you're doing finer-detailed work and want more precise movements. */
        const zoom_fudge = Math.sqrt(input.zoom/(opts.zoom ?? 10))*2;

        if (ev.button == 0) {
          input.pitch -= ev.movementX * 0.0005 * zoom_fudge;
          input.yaw   -= ev.movementY * 0.0005 * zoom_fudge;
          input.yaw = Math.max(-Math.PI*0.5 + 0.01, Math.min(Math.PI*0.5 - 0.01, input.yaw));
        }
        if (ev.button == 2) {
          const unit = new DOMPoint(0, -ev.movementX*0.15*zoom_fudge, ev.movementY*0.15*zoom_fudge, 1)
            .matrixTransform(new DOMMatrix().rotateSelf(0, input.yaw / Math.PI * 180, input.pitch / Math.PI * 180));

          input.cam_pivot.x += unit.x;
          input.cam_pivot.y += unit.y;
          input.cam_pivot.z += unit.z;
        }

        ev.movementX *= Math.pow(1 - 0.17, 60*deltaTime);
        ev.movementY *= Math.pow(1 - 0.17, 60*deltaTime);

        {
          const t = Math.cbrt(Math.abs(input.scroll)) * Math.sign(input.scroll);

          input.zoom += 0.005*t*input.zoom;
          input.scroll *= Math.pow(1 - 0.5, 60*deltaTime);
          input.zoom = Math.max(800, Math.min(opts.max_zoom ?? 200, input.zoom));
        }
      }

      let mvp;
      {
        const FIELD_OF_VIEW = 50 / 180 * Math.PI;
        const ar = canvas.width / canvas.height;
        const projection = mat4_perspective(new DOMMatrix(), FIELD_OF_VIEW, ar, 0.01, 10_000.0);

        const view = new DOMMatrix().rotateSelf(0, input.yaw / Math.PI * 180, input.pitch / Math.PI * 180);
        {
          const eye = input.eye = new DOMPoint(input.zoom, 0, 0, 1).matrixTransform(view);

          eye.x += input.cam_pivot.x;
          eye.y += input.cam_pivot.y;
          eye.z += input.cam_pivot.z;
          mat4_target_to(view, eye, input.cam_pivot, new DOMPoint(0, 0, 1));
          view.invertSelf();
        }

        mvp = new DOMMatrix(projection).multiplySelf(view);
      }

      ctx.globalAlpha = 1.0;
      ctx.fillStyle = opts.clear_color ?? "rgb(30 40 50)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalAlpha = 1.0;

      const transform = (p) => {
        p.w = 1;
        p = p.matrixTransform(mvp);
        const w = p.w;
        p.x = (0 + (p.x/w*0.5 + 0.5))*canvas.width;
        p.y = (1 - (p.y/w*0.5 + 0.5))*canvas.height;
        return p;
      }

      render_cb(ctx, timestamp, transform);

    })

    function mat4_perspective(out, fovy, aspect, near, far) {
        let f = 1.0 / Math.tan(fovy / 2),
            nf;
        out.m11 = f / aspect;
        out.m12 = 0;
        out.m13 = 0;
        out.m14 = 0;
        out.m21 = 0;
        out.m22 = f;
        out.m23 = 0;
        out.m24 = 0;
        out.m31 = 0;
        out.m32 = 0;
        out.m33 = 0;
        out.m34 = -1;
        out.m41 = 0;
        out.m42 = 0;
        out.m43 = 0;
        out.m44 = 0;
        if (far != null && far !== Infinity) {
            nf = 1 / (near - far);
            out.m33 = (far + near) * nf;
            out.m43 = 2 * far * near * nf;
        } else {
            out.m33 = -1;
            out.m43 = -2 * near;
        }
        return out;
    }

    function mat4_target_to(out, eye, target, up) {
        let z0 = eye.x - target.x,
            z1 = eye.y - target.y,
            z2 = eye.z - target.z;
        let len = z0 * z0 + z1 * z1 + z2 * z2;
        if (len > 0) {
            len = 1 / Math.sqrt(len);
            z0 *= len;
            z1 *= len;
            z2 *= len;
        }
        let x0 = up.y * z2 - up.z * z1,
            x1 = up.z * z0 - up.x * z2,
            x2 = up.x * z1 - up.y * z0;
        len = x0 * x0 + x1 * x1 + x2 * x2;
        if (len > 0) {
            len = 1 / Math.sqrt(len);
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }
        out.m11 = x0;
        out.m12 = x1;
        out.m13 = x2;
        out.m14 = 0;
        out.m21 = z1 * x2 - z2 * x1;
        out.m22 = z2 * x0 - z0 * x2;
        out.m23 = z0 * x1 - z1 * x0;
        out.m24 = 0;
        out.m31 = z0;
        out.m32 = z1;
        out.m33 = z2;
        out.m34 = 0;
        out.m41 = eye.x;
        out.m42 = eye.y;
        out.m43 = eye.z;
        out.m44 = 1;
        return out;
    }
  }
}

function lerp(v0, v1, t) { return (1 - t) * v0 + t * v1; }
function inv_lerp(min, max, p) { return (p - min) / (max - min); }
    </script>
  </body>
</html>
